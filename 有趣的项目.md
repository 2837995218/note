# EasyExcel

## 导入

### 快速入门

- 引入依赖

  ```xml
  <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>easyexcel</artifactId>
      <version>3.1.4</version>
  </dependency>
  ```

- Excel 表格

  | id   | 姓名 | 性别 | 生日          |
  | ---- | ---- | ---- | ------------- |
  | 1    | 张三 | 男   | 2002年3月12日 |

- 读取 Excel 文件

  ```java
  File file  = new File("C:\\Users\\yoga\\Desktop\\test.xlsx");
  List<Map<Integer, Object>> list = EasyExcel
      .read(file)
      .sheet() // 指定工作表。可填参数：表名(sheet1)、索引(0)、空参(第一张表)
      .head(映射模型.class) // 指定映射模型
      .headRowNumber(5) // 指定表头行数，即从（指定行数+1）行开始读取数据，默认0
      .doReadSync();
  
  Map<Integer, Object> map = list.get(0);
  System.out.println(map); // {0=1, 1=张三, 2=男, 3=2002年3月12日}
  ```



### 模型映射

- 关系映射
  - `@ExcelProperty`：默认**属性在映射类中的次序**与**map的key值**对应
  - `@ExcelProperty(value = "列名")`：指定对应列名
  - `@ExcelProperty(index = 0)`：指定对应key值

- 自定义解析

  - `@ExcelProperty(converter = 自定义格式转换.class)`

- 使用

  ```java
  List<映射模型类> list = EasyExcel
      .read(file)
      .head(映射模型.class) // 指定映射模型
      .sheet()
      .doReadSync();
  ```

  ```java
  @Data
  @ToString
  public class Person {
      @ExcelProperty("id")
      private int id;
  
      @ExcelProperty("姓名")
      private String name;
  
      @ExcelProperty("性别")
      private String gender;
  
      @ExcelProperty(value = "生日", converter = LocalDateConverter.class)
      private LocalDate birthday;
  }
  ```

  ```java
  public class LocalDateConverter implements Converter<LocalDate> {
      @Override
      public LocalDate convertToJavaData(ReadCellData cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {
  
          String stringValue = cellData.getStringValue();
          return LocalDate.parse(stringValue, DateTimeFormatter.ofPattern("yyyy年MM月dd日"));
      }
  }
  ```




### 监听器(处理器)

> 事实上，为了代码的美观，可以将数据处理部分放在监听器（ReadListener）中。
>
> 最后调用 void doRead() 方法做读取

- 使用

  ```java
  EasyExcel
      .read(file)
      .head(映射模型.class)
      .registerReadListener(new ReadListener<映射模型>() { ... })
      .sheet()
      .doRead();
  ```

- `ReadListener<T>` 接口

  ```java
  public interface ReadListener<T> extends Listener {
      // 读取一条数据后出现异常调用的方法
      default void onException(Exception exception, AnalysisContext context) throws Exception {
          throw exception;
      }
  
      default void invokeHead(Map<Integer, ReadCellData<?>> headMap, AnalysisContext context) {
      }
  
      // 读取到每条数据后调用的方法
      void invoke(T var1, AnalysisContext var2);
  
      default void extra(CellExtra extra, AnalysisContext context) {
      }
  
      // 所有数据执行完后调用的方法
      void doAfterAllAnalysed(AnalysisContext var1);
  
      default boolean hasNext(AnalysisContext context) {
          return true;
      }
  }
  ```

- 异常获取

  ```java
  @Override
  public void onException(Exception exception, AnalysisContext context) throws Exception {
      if (exception instanceof ExcelDataConvertException) {
          ExcelDataConvertException e = (ExcelDataConvertException) exception;
          e.getColumnIndex();
          e.getRowIndex();
          e.getCellData();
          e.getExcelContentProperty();
      }
  }
  ```

- 优点：**访问者模式**

  - 一方面可以将处理逻辑独立出来，使代码更美观
  - 另一方面可以添加多个ReadListener，实现只遍历一遍excel数据，达到多处理器**实时处理**（读取一条处理一条）的效果




### 上传文件读取

```java
@PostMapping("/upload")
public List<InfoModel> upload(MultipartFile file) {
    InputStream inputStream = file.getInputStream();
    return EasyExcel.read(inputStream).head(InfoModel.class).doReadSync();
}
```





## 导出

### 快速入门

- 到处方法

  ```java
  EasyExcel
      .write(导出目标)
      .sheet()
      .head(映射模型.class) // 指定映射模型
      
      .doWrite(集合数据);
  ```

- 导出目标

  - String 文件路径
  - File 文件对象
  - OutStream 输出流

- 集合数据

  - `List<List<Object>>`：{{1, "张三", "男"}, ...}
  - `List<Map<Integer, Object>>`：{{0=1, 1="张三", 2="男"}, ...}
  - `List<Object>`：同一个类



### 模型映射

- 关系映射

  - `@ExcelIgnore`：不导出该属性
  - 无注解、`@ExcelProperty`：默认**属性在映射类中的次序**与**map的key值**对应
  - `@ExcelProperty(value = "列名")`：指定对应列名
  - `@ExcelProperty(index = 0)`：指定对应key值
  - `@ExcelProperty(value = {"标签1", "标签2", ...})`

- 格式转化

  - `@DateTimeFormat(value = "yyyy年MM月dd日")`：截止目前(3.3.1)只支持`java.util.Date`

  - `@NumberFormat(value = "￥#.##%")`：**.**后几个**#**会被解析成几位小数，**.**前**#**无用。加**%**表示转成百分数

  - `@ExcelProperty(converter = 自定义格式转换.class)`

    ```java
    public class LocalDateConverter implements Converter<LocalDate> {
        @Override
        public WriteCellData<?> convertToExcelData(LocalDate value, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {
            String str = value.format(DateTimeFormatter.ofPattern("yyyy年MM月dd日"));
            return new WriteCellData<LocalDate>(str);
        }
    }
    ```

- 多value值

  ```java
  public class Person {
      @ExcelProperty(value = {"基本信息", "姓名"})
      private String name;
      
      @ExcelProperty(value = {"基本信息", "性别"})
      private String gender;
      
      @ExcelProperty("积分")
      @NumberFormat("#.##")
      private double score;
      
      @ExcelProperty(value = {"基本信息", "生日"})
      @DateTimeFormat(value = "yyyy年MM月dd日")
      private Date birthday;
  }
  ```

  <table>
      <tr><td colspan=2>基本信息</td><td rowspan=2>积分</td><td>基本信息</td></tr>
      <tr><td>姓名</td><td>性别</td><td>生日</td></tr>
      <tr><td>张三</td><td>男</td><td>78.33</td><td>2003年5月1日</td></tr>
  </table>

- 排除部分属性导出

  - `@ExcelIgnore`
  - EasyExcel 静态方法
  
    - `.excludeColumnFieldNames(Arrays.asList("password", ...))`：排除
    - `.includeColumnFieldNames(Arrays.asList("username", ...))`：包括
  



### 行高列宽

- 手动设置（加在映射模型类的属性上）

  - `@ContentRowHeight(value = 10)`
  - `@HeadRowHeight(value = 15)`
  - `@ColumnWidth(value 25)`

- 自动列宽（依旧可能存在问题，建议与注解一起使用）

  ```java
  EasyExcel
      .write(file)
      .sheet()
      .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()) // 长度匹配内容
      .registerWriteHandler(new AbstractColumnWidthStyleStrategy(){ ... }) // 也可以自己实现该接口
      .doWrite(data);
  ```



### 跨行列合并

- 静态合并

  - 使用注解
    - `@OnceAbsoluteMerge(firstRowIndex = 5, lastRowIndex = 6, firstColumnIndex = 1, lastColumnIndex = 2)`
      - 加载模型类上
      - 表示：从1列5行 到 2列6行 合并
    - `@ContentLoopMerge(eachRow=2, columnExtend=2)`
      - 添加在映射模型类的属性上
      - 仅对数据部分生效
      - eachRow=2：数据部分每两行进行合并
      - columnExtend=2：数据部分跨两列

  - 使用默认策略

    ```java
    EasyExcel
        .write(file)
        .sheet()
        .registerWriteHandler(new LoopMergeStrategy(eachRow: 2, columnIndex: 0))
        .registerWriteHandler(new OnceAbsoluteMergeStrategy(FR: 0, LR: 1, FC: 4, LC: 4))
        .doWrite(data);
    ```

- 动态合并（自定义策略 `registerWriteHandler()`）

  - `CellWriteHandlerContext`：该类对象存储了对应单元格中的相关信息

  - 实现此接口并注册：`CellWriteHandler`

    ```java
    public interface CellWriteHandler extends WriteHandler {
        default void beforeCellCreate(CellWriteHandlerContext context) {
            this.beforeCellCreate(context.getXXX, context.getXXX, ...);
        }
        default void beforeCellCreate(
            WriteSheetHolder writeSheetHolder, 
            WriteTableHolder writeTableHolder, 
            Row row, 
            Head head, 
            Integer columnIndex, 
            Integer relativeRowIndex, 
            Boolean isHead) {
        }
    
    
        default void afterCellCreate(CellWriteHandlerContext context) {
            this.afterCellCreate(context.getXXX, context.getXXX, ...);
        }
        default void afterCellCreate(
            WriteSheetHolder writeSheetHolder, 
            WriteTableHolder writeTableHolder, 
            Cell cell, 
            Head head, 
            Integer relativeRowIndex, 
            Boolean isHead) {
        }
    
    
        default void afterCellDataConverted(CellWriteHandlerContext context) {
            WriteCellData<?> writeCellData = CollectionUtils.isNotEmpty(context.getCellDataList()) ? (WriteCellData)context.getCellDataList().get(0) : null;
            this.afterCellDataConverted(writeCellData, context.getXXX, context.getXXX, ...);
        }
        default void afterCellDataConverted(
            WriteSheetHolder writeSheetHolder, 
            WriteTableHolder writeTableHolder, 
            WriteCellData<?> cellData, 
            Cell cell, 
            Head head, 
            Integer relativeRowIndex, 
            Boolean isHead) {
        }
    
    
        default void afterCellDispose(CellWriteHandlerContext context) {
            this.afterCellDispose(context.getXXX, context.getXXX, ...);
        }
        default void afterCellDispose(
            WriteSheetHolder writeSheetHolder, 
            WriteTableHolder writeTableHolder, 
            List<WriteCellData<?>> cellDataList, 
            Cell cell, 
            Head head, 
            Integer relativeRowIndex, 
            Boolean isHead) {
        }
    }
    ```

  - 实现类

    ```java
    public class MergeCellWriteHandler implements CellWriteHandler {
        private final List<String> fieldsNeedMerge;
    
        public MergeCellWriteHandler(List<String> columnsNeedNotMerge) {
            fieldsNeedMerge = columnsNeedNotMerge;
        }
    
        @Override
        public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, List<WriteCellData<?>> cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) {
            // 如果该行属于表头行，则不处理
            if (isHead) return;
    
            // 如果该行属于数据区第一行，则不处理。relativeRowIndex：是对应数据的相对行数
            if (relativeRowIndex == 0) return;
    
            // 如果该列不需要合并，则不处理
            if (fieldsNeedMerge == null || !fieldsNeedMerge.contains(head.getFieldName())) return;
    
            // 获得本单元格和本列上一行的单元格，并判断两格内值是否相同，从而判断是否需要合并
            Sheet sheet = cell.getSheet();
            int rowIndexCurrent = cell.getRowIndex();
            int rowIndexPrev = rowIndexCurrent-1;
            Row rowPrev = sheet.getRow(rowIndexPrev);
            int columnIndex = cell.getColumnIndex();
            Cell prevCell = rowPrev.getCell(columnIndex);
    
            // 判断两格内容是否相同。（只做了简单的数据校验，可能存在问题，如：null值，其他类型的CellType）
            Object currentCellValue = cell.getCellType() == CellType.STRING ?
                    cell.getStringCellValue() : cell.getNumericCellValue();
            Object prevCellValue = prevCell.getCellType() == CellType.STRING ?
                    prevCell.getStringCellValue() : prevCell.getNumericCellValue();
            boolean flag = currentCellValue.equals(prevCellValue);
            // 不相同，则不处理
            if (!flag) return;
    
            // 获取一个表中已经合并的区域（所有的大单元格）
                // 理论上只要获取需要合并列的所有大单元格，但没有这个api，
                // 因为单元格还可以跨列合并，跨列的大单元格不能确定属于哪一列
            List<CellRangeAddress> mergedRegions = sheet.getMergedRegions();
            // 上一个单元格是否与之前的单元格形成大单元格
            boolean merged = false;
            for (int i = 0; i < mergedRegions.size(); i++) {
                CellRangeAddress cellAddresses = mergedRegions.get(i);
                // 判断上一个单元格是否在合并的大单元格内
                if (cellAddresses.isInRange(rowIndexPrev, columnIndex)) {
                    // 在，说明现单元格需要和上一个大单元格合并
                    // 需要先取消上一个大单元格
                    sheet.removeMergedRegion(i);
                    cellAddresses.setLastRow(rowIndexCurrent);
                    // 再将重新划分好的新大单元格设置回去
                    sheet.addMergedRegion(cellAddresses);
                    merged = true;
                    break;
                }
            }
            // 如果上一单元格没有与之前的单元格形成大单元格，则只需将上一个单元格和现单元格合并
            if (!merged) {
                CellRangeAddress addresses = new CellRangeAddress(rowIndexPrev, rowIndexCurrent, columnIndex, columnIndex);
                sheet.addMergedRegion(addresses);
            }
        }
    }
    ```

    











































































