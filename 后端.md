# Linux



## 基础篇

#### 网络连接的三种方式

- 桥接模式：虚拟系统可以和外部系统通讯，但是容易造成IP冲突
- NAT模式：网络地址转换模式，虚拟系统可以和外部系统通讯，不造成IP冲突
- 主机模式：独立的系统



#### 目录结构

- /bin：【常用】（/usr/bin、/usr/local/bin）是Binary的缩写，存放着最常用的命令
- /sbin：（/usr/sbin、/usr/local/sbin）是系统管理员使用的系统管理程序
- /home：【常用】存放普通用户的主目录，在Linux中每个用户都有一个自己的目录
- /root：【常用】系统管理员的用户目录
- /lib：系统开机所需要的最基本动态连接共享库
- /lost+found：这个目录一般情况下是空的，当系统非法关机后，会在这存放一些文件
- /etc：【常用】所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库的my.conf
- /usr：【常用】这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下
- /boot：【常用】存放的是启动Linux时使用的已一些核心文件，包括一些连接文件和镜像文件
- /proc：这是个虚拟目录，它是系统内存的映射，访问这个目录来获取系统信息
- /srv：service的缩写，该目录存放一些服务启动之后需要提供的数据
- /sys：这是linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs
- /tmp：这个目录是用来存放一些临时文件的
- /dev：类似于windows的设备管理器，把所有的硬件用文件的形式存储
- /media：【常用】linux系统会自动识别一些设备，如u盘，光驱等，识别后，把设备挂载到这个目录
- /mnt：【常用】系统提供该目录是为了让用户临时挂载别的文件系统的，可以将外部存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。myshare
- /opt：这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可以放到该目录下。
- /usr/local：【常用】这是另一个给主机上的软件安装的目录，一般是通过编译源码方式安装的程序
- /var：存放着不断扩充着的东西，习惯将经常被修改的目录放到这个目录下，包括各种日志文件
- /silinux [security-enhanced linux]：SELinux是一种安全子系统，它能控制程序只能访问特定的文件，有三种工作模式，可以自行设置



#### vim

- 拷贝当前行 yy，拷贝当前行向下的5行 5yy，并粘贴（输入p）
- 删除当前行 dd，删除当前行向下的5行 5dd
- 在文本中查找某个单词（命令行下 /关键词，回车查找，输入 n 就是查找下一个）
- 设置文件的行号，取消文件的行号（命令行下 :set nu 和 :set nonu）
- 编辑 /etc/profile 文件，一般模式下，使用快捷键到该文件的最末行（G）和最初行（gg）
- 在一个文本中输入“hello”，然后又撤销这个动作（一般模式下：u）
- 编辑 /etc/profile 文件，并将光标移动到20行（一般模式下：20+Shift+g）



#### 基本操作

- 关机重启

  - shutdown -h now（立即关机）

  - shutdown -h 1（1分钟后关机）

  - shutdown -r now（立即重启）

  - halt（关机，作用和上面一样）

  - reboot（立即重启）

  - sync（把内存的数据同步到磁盘）
  
- 用户管理

  - 用户注销：
    - 提示符下输入 logout 即可注销用户
    - logout 注销指令在图形运行级别无效，在运行级别3下有效
  - 添加用户：
    - useradd 用户名
    - useradd -d 指定目录 新的用户名
    - passwd 用户名
  - 删除用户：
    - 保留home目录：userdel 用户名
    - 全部删除：userdel -r 用户名
  - 查询用户：id 用户名
  - 切换用户：
    - su - 用户名
    - 权限高的用户到权限低的用户不需要密码
  - 当前用户：who am i
  - 添加组：groupadd 组名
  - 删除组：groupdel 组名
  - 添加用户到组：useradd -g 组名 用户名
  - 修改用户的组：usermod -g 组名 用户名
  - 相关文件
    - /etc/passwd：用户的配置文件，记录了用户的各种信息
    - /etc/shadow：口令的配置文件
    - /etc/group：组的配置文件，记录Linux包含的组的信息
  
- 环境变量
  - vim /etc/profile
  
  - 文件末尾添加
  
    ```ini
    export JAVA_HOME=/usr/local/java/jdk1.8.0_333
    export PATH=$JAVA_HOME/bin:$PATH
    ```
  
    ```shell
    # 刷新环境变量
    source /ect/profile
    # 查看环境变量
    echo $PATH
    ```




#### 运行级别

- 0：关机
- 1：单用户，可找回密码
- 2：多用户状态没有网络服务
- 3：多用户状态有网络服务
- 4：系统未使用保留给用户
- 5：图形界面
- 6：系统重启
- 切换不同级别：init 级别
- CentOS7后运行级别说明
  - 在centos7以前，/etc/inittab文件中。
  - 7后进行简化
    - multi-user.target: analogous to runlevel 3
    - graphical.target: analogous to runlevel 5
  - 查看运行级别：systemctl get-default
  - 设置默认运行级别：systemctl set-default multi-user.target/graphical.target



#### 一些指令

- \>（输出重定向）和\>>（追加）
  - ls -l > 文件：列表的内容覆盖写入指定文件中
  - ls -al >> 文件：列表的内容追加到指定文件中
  - cat 文件1 > 文件2：将文件1的内容覆盖到文件2中
  - echo "内容" >> 文件：追加内容到指定文件

- ln指令：创建一个软（或硬）链接
  - 基本语法：ln [-s] 源文件或目录 软连接名
  - 携带参数 -s：创建软链接（快捷方式）
  - 不携带参数 -s：创建硬链接（复制并让内容保持同步）
- history指令
  - history	：看最近执行的全部命令
  - history 条数：看最近的指定条数
- date指令
  - date：显示当前时间
  - date +%Y：显示当前年份
  - date +%m：月
  - date +%d：日
  - date "+%Y-%m-%d %H:%M:%S"：年-月-日 时:分:秒
  - 设施日期：date -s "2020-01-01 12:00:00"
  - cal (年份)：日历指令
- find指令
  - find 位置 -name 文件名
  - find 位置 -user 用户名
  - find 位置 -size +大小（+n大于、-n小于、n等于，单位有k，M，G）
- locate指令
  - 先执行updatedb
  - locate 文件名

- grep和管道指令 |：
  - cat 文件 | grep (-n显示行数) (-i不区分大小写) "字段"
  - grep (-n) "字段" 文件
- 解压与压缩
  - gzip 文件
  - gunzip 文件.gz
  - zip -r 压缩后的文件名.zip 文件
  - unzip -d 解压的地址 需要解压的文件.zip
  - tar
    - -z：打包的同时压缩
    - -c：创建.tar的打包文件
    - -v：显示运行过程的详细信息
    - -f：指定压缩后的文件名
    - -x：解包.tar文件
    - tar -zcvf 文件名.tar.gz 文件
    - tar -zxvf 需要解压的文件.tar.gz -C 解压的位置









# Java SE



## <a href="https://www.bilibili.com/video/BV16J411h7Rd/?p=209&vd_source=25ad2de4838bd28372a4956bac63c618">线程池</a>

### 快速入门

```java
public ThreadPoolExecutor(int corePollSize, // 核心线程数
                        int maximumPoolSize, // 最大线程数
                        long keepAliveTime, // 最大空闲时间
                        TimeUnit unit, // 时间单位
                        BlockingQueue<Runnable> workQueue, // 任务队列
                        ThreadFactory threadFactory, // 线程工厂
                        RejectedExecutionHandler handler) // 饱和处理机制
```

- 在总线程数量没有达到核心线程数之前，若任务队列有线程，会持续创建线程，直至达到核心线程数
- 任务队列满后，若总线程数量未达到最大线程数，则开辟新线程处理任务



### ExecutorService

- 成员方法
  - void shutdown()：启动一次顺序关闭，执行以前提交的任务，但不再接收新任务
  - List\<Runnable> shutdownNow()：停止所有正在执行的任务，暂停处理等待的任务，并返回等待执行的任务队列 
  - \<T> Future\<T> submit(Callable\<T> task)：执行带返回值的任务，返回一个表示该任务的Future对象
  - Future\<?> submit(Runable task)：执行Runable任务，并返回一个表示该任务的Future
  - \<T> Future\<T> submit(Runnable task, T result)：执行Runnable任务，并返回一个表示该任务的Future对象
  
- Future

  ```java
  public interface Future<V> {
      // true：取消正在等待执行、正在执行的任务，无法取消已经完成的任务
      // false：取消正在等待执行的任务，无法取消正在执行、已经完成的任务
      boolean cancel(boolean mayInterruptIfRunning);
      // 判断任务是否被取消
      boolean isCancelled();
      // 判断任务是否完成
      boolean isDone();
      // 阻塞等待获得任务结果
      V get() throws InterruptedException, ExecutionException;
      // 阻塞等待一定时间，获得任务结果
      V get(long timeout, TimeUnit unit)
          throws InterruptedException, ExecutionException, TimeoutException;
  }
  ```

  

- 获得对象
  - 介绍
    - ExecutorService是一个接口
    - 可通过Executors类中的静态方法，获得ExecutorService的对象
  - Executors
    - static ExecutorService newCachedThreadPool()：不定线程数
    - static ExecutorService newCachedThreadPool(ThreadFactory factory)
    - static ExecutorService newFixedThreadPool()：指定线程数
    - static ExecutorService newFixedThreadPool(ThreadFactory factory)
    - static ExecutorService newSingleThreadExecutor()：单一线程
    - static ExecutorService newSingleThreadExecutor(ThreadFactory factory)





## jdk新特性

> 语法上的新特性

### jdk8

#### lambda

- 快速入门

  - 原始

    - ```java
      Comparator<Customer> comparator1 = new Comparator<Customer>() {
          @Override
          public int compare(Customer o1, Customer o2) {
              return o1.getAge() - o2.getAge();
          }
      };
      ```

  - lambda

    - ```java
      Comparator<Customer> comparator2 = (o1, o2) -> o1.getAge()-o2.getAge();
      ```

- 语法

  - 格式
    - ->：lambda 操作符 或 箭头操作符
    - ->左边：lambda形参列表（接口中的抽象方法的形参列表）
    - ->右边：lambda体（重写的抽象方法的方法体）
  - 6种情况
    - 无参，无返回值
    - lambda需要一个参数，但是没有返回值
    - 数据类型可以省略，因为可由编译器推断得出，称为”类型推断“
    - lambda若只需要一个参数时，参数的小括号可以省略
    - lambda需要两个或以上的参数，多条执行语句，并且可以有返回值
    - 当lambda只有一条语句时，return与大括号若有，都可以省略



#### 函数式接口

- 定义：只有一个方法的接口

- java内置四大核心函数式接口

  - | 函数式接口      | 参数类型 | 返回类型 | 方法              |
    | :-------------- | :------- | -------- | ----------------- |
    | Consumer\<T>    | T        | void     | void accept(T t)  |
    | Supplier\<T>    | 无       | T        | T get()           |
    | Function\<T, R> | T        | R        | R apply(T t)      |
    | Predicate \<T>  | T        | boolean  | boolean test(T t) |

  - ```java
    @Test
    public void test() {
        List<String> list = Arrays.asList("北京", "南京", "天津", "东京");
        List<String> resultList = filterString(list, s -> s.contains("京"));
        System.out.println(resultList);
    }
    
    public List<String> filterString(List<String> list, Predicate<String> predicate) {
        ArrayList<String> filterList = new ArrayList<>();
        list.forEach(str -> {
            if (predicate.test(str)) filterList.add(str);
        });
        return filterList;
    }
    ```
  
- 其他接口

  - | 函数式接口                                                   | 参数类型              | 返回类型              | 方法                   |
    | ------------------------------------------------------------ | --------------------- | --------------------- | ---------------------- |
    | UnaryOperator\<T>                                            | T                     | T                     | T apply(T t)           |
    | BiFunction\<T, U, R>                                         | T, U                  | R                     | R apply(T t, U u)      |
    | BinaryOperator\<T>                                           | T, T                  | T                     | T apply(T t1, T t2)    |
    | BiConsumer\<T, U>                                            | T, U                  | void                  | void accept(T t, U u)  |
    | BiPredicate\<T, U>                                           | T, U                  | boolean               | boolean test(T t, U u) |
    | ToIntFunction\<T><br>ToLongFunction\<T><br>ToDoubleFunction\<T> | T                     | int<br>long<br>double |                        |
    | IntFunction\<R><br>LongFunction\<R><br>DoubleFunction\<R>    | int<br>long<br>double | R                     |                        |
    



#### 方法引用

- 方法引用

  - 本质就是lambda表达式，而lambda表达式作为函数式接口的实例。所以方法引用也是函数式接口的实例

  - 使用格式： 类（或对象）**::** 方法名

  - 使用要求
    - 要求函数式接口中的方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同

  - 具体情况

    - 对象 **::** 非静态方法

    - 类 **::** 静态方法

    - 类 **::** 非静态方法

      - ```java
        BiPredicate<String, String> biPredicate1 = new BiPredicate<String, String>() {
            @Override
            public boolean test(String s, String s2) {
                return s.equals(s2);
            }
        };
        BiPredicate<String, String> biPredicate2 = (s1, s2) -> s1.equals(s2);
        BiPredicate<String, String> biPredicate3 = String::equals;
        System.out.println(biPredicate3.test("abc", "abc"));
        ```

- 构造器引用

  - 使用要求

    - 要求函数式接口中的方法的形参列表与构造器引用的形参列表相同，返回值为构造器创建的对象

  - ```java
    // 调用有参构造器，函数式接口方法：User apply(Integer integer)
    Function<Integer, User> function = User :: new;
    // 调用无参构造器，函数式接口方法：User get()
    Supplier<User> supplier = User :: new;
    ```

- 数组引用

  - ```java
    Function<Integer, String[]> function1 = length -> new String[length];
    Function<Integer, String[]> function2 = String[] :: new;
    ```



#### Stream

- stream是操作渠道，用于操作数据源（集合、数组等》所生成的元素序列

- 注意

  - Stream 自己不会存储元素
  - Stream 不会改变源对象。相反，会返回一个持有结果的新Stream
  - Stream 操作是延时执行的。这意味着它会等到需要结果的时候才执行

- Stream 操作的三个步骤

  - 创建 Stream

    - 通过集合获取

      - ```java
        List<String> list = Arrays.asList("北京", "南京", "天津", "东京");
        Stream<String> stream = list.stream();
        // parallelStream其实就是一个并行执行的流.它通过默认的ForkJoinPool,可能提高你的多线程任务的速度
        Stream<String> parallelStream = list.parallelStream();
        ```
  
    - 通过数组获取
  
      - ```java
        String[] arr = {"北京", "南京", "天津", "东京"};
        Stream<String> stream = Arrays.stream(arr);
        ```
  
    - 通过Stream的of方法
  
      - ```java
        Stream<String> areas = Stream.of("北京", "南京", "天津", "东京");
        ```
  
    - 创建无限流
  
      - ```java
        // Stream.iterate(T seed, UnaryOperator<T> f)
        Stream.iterate("23", t -> t + "3");
        // Stream.generate(Supplier<? extends T>)
        Stream.generate(() -> "Hello,world")
        ```
  
  - 中间操作
  
    - 筛选与切片
  
      - 过滤：filter(Predicate p)
      - 截断：limit(int maxSize)
      - 跳过：skip(long n)
      - 筛选：distinct()（通过hashCode()和equals()方法去重）
  
    - 映射
  
      - map(Function f)
  
        - 接收一个转化规则函数作为参数，将Stream中的元素按规则转成其他形式
  
        - ```java
          Customer customer = new Customer(1, "张三", 28, true);
          List<Customer> list = Arrays.asList(customer);
          list.stream().map(Customer::getName).filter((str) -> str.length()<3).forEach(System.out::println);
          ```
  
      - flatMap(Function f)
  
        - 接收一个转化规则作为参数，将Stream中的元素按规则转成Stream，最终形成Stream套Stream
  
    - 排序
  
      - 自然排序：sorted()
        - 按 Stream中元素实现Comparable\<T>接口后重写的compareTo方法 进行排序
      - 规则排序：sorted(Comparator com)
  
  - 终止操作
  
    - 匹配与查找
  
      - allMatch(Predicate p)：检查所有元素是否匹配
      - anyMatch(Predicate p)：检查是否有元素匹配
      - noneMatch(Predicate p)：检查是否没有匹配的元素
      - findFirst()：返回第一个元素
      - findAny()：返回当前流中的任意元素
  
      - count()：返回流中元素总数
      - max(Comparator c)：返回流中的最大值
      - min(Comparator c)：返回流中的最小值
      - forEach(Consumer c)：内部迭代
  
    - 规约
  
      - reduce(T identity, BinaryOperator b)：可以将流中的元素反复结合起来，得到一个值
      - reduce(BinaryOperator b)
  
    - 收集
  
      - collect(Collector c)
        - Collectors的toList，toMap和toCollection方法可以获得一个Collector对象



#### Option

- Option of(T t)：返回一个包含t值的容器，t不允许为null
- Option empty()：返回一个空容器
- Option ofNullable(T t)：返回一个包含t值的容器，t允许为null
- T get()：如果调用对象包含值，则返回该值，否则抛异常
- T orElse(T other)：如果有值，则返回该值，否则返回指定的other对象





### jdk9

#### 模块化系统

- 创建 module-info.java 文件

  - 暴露

    - ```java
      module customerServer{
          exports cn.Eli.domain;
      }
      ```

  - 引进

    - ```java
      module orderServer{
          requires openFeign;
      }
      ```



#### 接口

- java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法和默认方法。
- java 9中，方法的访问权限修饰符也可以声明为private

```java
public interface MyInterface {
    // 如下三个方法 java8 可用，权限修饰符省略，都是public
    void methodAbstract();
    
    // 接口中的静态方法只能由接口自己调用，实现类不能调用 MyInterface.methodStatic()
    static void methodStatic() {
        System.out.println("静态方法");
    }
    
    default void methodDefault() {
        System.out.println("默认方法");
    }
    
    // java9 特性：允许接口中定义私有方法，私有方法不能在接口外部使用
    private void methodDefault() {
        System.out.println("私有方法");
    }
}
```



#### 钻石

```java
// jdk7 中特性：类型推断，后面的 String等 可以省略
ArrayList<String> strings = new ArrayList<>();

// jdk9 中特性：后面的 Object等 可以省略
Comparator<Object> comparator = new Comparator<>() {
    @Override
    public int compare(Object o1, Object o2) {
        return 0;
    }
};
```



#### try

- java8 前，资源释放在 finally{} 中

- java8 可在try后的小括号中声明需要释放的资源

  - ```java
    // 要求执行后必须关闭的所有资源必须在try子句中初始化
    try (InputStreamReader isr = new InputStreamReader(System.in)) {
        // IO 操作
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
    ```

- java9 资源的初始化可以放在外面

  - ```java
    InputStreamReader isr = new InputStreamReader(System.in);
    // 此时的资源属性是常量，声明为final，不可修改
    try(isr) {
        // IO 操作
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
    ```

    

#### 其他特性

- 目录结构变更

- JShell：java 的REPL（交互式编程环境）
- String底层由原先的 char[] 变更为 byte[]
- 不可修改集合
  - 调用 Collections 的 unmodifiableCollection(Collection c)、unmodifiableList(List l)、unmodifiableSet(Set s) 返回的集合是不可修改集合
  - List/Set/Map 新增of方法，返回的集合是不可修改集合
  - 补充：Arrays.asList(Object ... ) 返回的集合也是不可修改集合
- InputStream 中的 transferTo(OutputStream os) 方法可以把输入流中的所有数据直接自动复制的输出流中
- Stream增强
  - takeWhile(Predicate p)：中间操作，从头开始一直读取数据直到predicate断定为false
  - dropWhile(Predicate p)：中间操作，从prediate断定为false开始一直往后读取数据
  - ofNullable(T t)：创建操作，能且只能存储一个值，该值可以为null
    - of(T ... values)：创建操作，jdk8提供，存储多个值。但若存且只存入一个null，则报错
  - iterate(T seed, Predicate\<T> p, UnaryOperator\<T> f)：创建操作，jdk9重载方法
- Optional增强
  - Stream\<T> stream()：获得stream
  - ifPresentOrElse(Consumer action, Runnable emptyAction)：value不为空，执行前一个参数功能，否则执行后一个参数功能
  - Optional\<T> or(Supplier\<? extends Optional\<? extends T>> supplier)：value非空，返回对应的Optional；value为空，返回形参函数中返回的Optional
- 升级的Nashorn（为java提供轻量级的javascript运行，jdk11又移除）





### jdk10

#### 类型推断

- 声明变量时，根据所赋的值，推断出变量的类型

```java
var num = 10;
var list = new ArrayList<String>();
for(var i : list) {
    System.out.println(i.getClass());
}
```



#### 集合

- copyOf 方法：返回一个只读的集合

```java
// copyOf(Xxx coll) 如果传入的本身是一个只读的集合，则会返回该集合，否则则会创建一个只读的集合
var list1 = List.of("Java", "Pythod", "C");
var copy1 = List.copyOf(list1);
System.out.println(list1 == copy1); // true

var list2 = new ArrayList<String>();
var copy2 = List.copyOf(list2);
System.out.println(list2 == copy2); // false
```





### jdk11

#### jre

```shell
bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre
```



#### String

- isBlank()：判断字符串是否为空白
- strip()：去除首尾的空白（相比于trim()方法，可去除全角符号）
- stripTrailing()：去除尾部的空白
- stripLeading()：去除首部的空白
- repeat(int times)：复制字符串
- "A\nB\nC".lines().count()：行数统计



#### 其他特性

- ZGC

  ```shell
  -XX:+UseZGC
  ```

- 局部变量类型推断的升级
- 支持编译解释一次完成：java HelloWorld.java
- HttpClient（jdk9提出）升级
- 废弃 Nashorn 引擎





### jdk12-17

#### switch

- 原switch

  ```java
  int days = 21;
  String desc;
  switch (days/10) {
      case 1:
          desc = "一旬";
          break;
      case 2:
          desc = "二旬";
          break;
      default:
          desc = "其他";
          break;
  }
  ```
  
- 增强 switch（jdk12）：只支持对数值和字符串常量匹配

  ```java
  int days = 21;
  String desc = switch (days/10) {
      case 1 -> "一旬";
      case 2 -> "二旬";
      default -> "其他";
  }
  ```
  
- 增强 switch（jdk17）

  - 匹配数值

    ```java
    int days = 21;
    String desc = switch (days/10) {
        case 0, 1, 2 -> {
            System.out.println("一个月不到了！");
            yield "一月以内";
        }
        case 3, 4, 5 -> "两月以内";
        default -> "两月以上";
    }
    ```

  - 匹配对象类型

    ```java
    String type = switch(object) {
            case null -> "null";
            case Integer i -> "是个Integer数值";
            default -> "其他类型";
    }
    ```
    



#### 密封类

```java
// sealed 标注的类，只能有 permits 指定的类继承
public sealed class Animal permits Dog, Cat {
    
}

// 子类必须被 final 或 non-sealed 修饰
// 子类和父类必须同包
public final class Cat {}
public non-sealed class Dog {}
```



#### Record类

```java
public class RecordTest {
    public static void main(String[] args) {
        User userRecord1 = new User(1L, "zhangsan");
        User userRecord2 = new User(1L, "zhangsan");
        // 属性值相同的不同record对象，equals 为 true
        System.out.println(userRecord1.equals(userRecord2))
    }
}

// 提供且只提供 全参构造方法 和 属性获取方法
// 并重写 equals hashcode toString 方法
// 但中途不能修改属性
public record User(Long userId, String name) {}
```



#### 其他特性

- 文本块

  - jdk15

    ```java
    String html = """
        <html>
            <body>
                <h1>%s</h1>
            </body>
        </html>
        """;
    
    String parseHtml = String.format(html, "这是一个标题");
    ```
  
  - jdk17：新增符号
  
    - \：至于行尾，用来将两行连接为一行
    - \s：单个空白字符
  
- 增强 instanceof（jdk14预览版提出，jdk16正式加入）

  - 原

    ```java
    Object o = 1;
    if (o instanceof Integer) {
        Integer i = (Integer) o; // 需要强转
        System.out.println("这是一个Integer，值为："+i);
    }
    ```

  - 新

    ```java
    Object o = 1;
    if (o instanceof Integer i) {
        System.out.println("这是一个Integer，值为："+i);
    }
    ```

- 空指针异常优化：指出那个对象报出空指针异常

- ZGC垃圾收集器：

  - 优化
    - STW：垃圾回收时触发，所有工作线程停止，会出现卡顿，jdk17将 STW 时间控制在10ms内，垃圾回收时不卡顿
    - jdk17 堆内存可以设置特别大，减少垃圾回收次数
  - 使用：jdk11和jdk17默认垃圾回收器依旧是G1
    - 添加JVM选项即可开启ZGC   `-xx:+UseZGC`





### jdk18-21

#### switch

- jdk17

  ```java
  record Point(int x, int y) {}
  
  static void printSum(Object obj) {
      if (obj instanceof Point(int x, int y)) {
          System.out.println(x+y);
      }
  }
  ```

- jdk21

  ```java
  record Point(int x, int y) {}
  
  static void printSum(Object obj) {
      switch(obj) {
          case Point(int x, int y) -> System.out.println(x+y);
          case null, default -> {
              // Do something
          }
      }
  }
  ```









# 结构与算法



## 数据结构

### 分类

- 线性结构：数据之间存在一对一的线性关系，包括数组、队列、链表、栈
  - 顺序存储结构
    - 顺序储存的线性表称为顺序表，顺序表中的存储元素是连续的
  - 链式存储结构
    - 链式存储的线性表称为链表，链表存储的元素不一定是连续的，元素节点存放数据元素以及相邻元素的地址信息
- 非线性结构：包括二维数组、多维数组、广义表、树结构、图结构



### 稀疏数组

- 当一个数组中大部分元素是0，或者同一个值的数组时，可以用稀疏数组来保存该数组

![](D:\picture\typora\java\1234567890.png)

- 二维数组转稀疏数组
  - 遍历二维数组，得到有效数据的个数
  - 根据sum就可以创建稀疏数组sparseArr int[sum+1]\[3]
  - 将二维数组的有效数据存入稀疏数组中
- 稀疏数组转原始数组
  - 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
  - 再读取稀疏数组的后几行，并赋值给原始的二维数组



### 其他结构

- 队列

  - 队列是一个有序列表，可以用数组或是链表来实现

  - 遵循先入先出的原则


- 链表
  - 单项链表
  - 双向链表
  - 环形链表
- 栈
  - 前缀表达式（波兰表达式）
  - 中缀表达式
  - 后缀表达式（逆波兰表达式）
  - 中缀表达式转后缀表达式
  - 递归
- 哈希表



### 二叉树

- 遍历

  - 前序：父节点 -> 左子树 -> 右子树
  
  - 中序：左子树 -> 父节点 -> 右子树
  
  - 后序：左子树 -> 右子树 -> 父节点
  
    ![二叉树](D:\picture\typora\java\二叉树.jpeg)
  
- 顺序存储二叉树

  - 顺序存储二叉树只考虑完全二叉树
  - 第n个元素的左子节点为 2*n+1
  - 第n个元素的右子节点为 2*n+2
  - 第n个元素的父节点为 (n-1)/2
    - n表示二叉树的第几个元素（从上到下，从左到右）

- 线索化二叉树

  - 利用二叉树链表中的空指针域，存放指向该节点在**某种遍历次序下**的前驱和后继节点的指针
    - 一个节点的前一个节点叫**前驱**节点，后一个节点叫**后继**节点
  - 遍历线索化二叉树

- 霍夫曼树

- 二叉排序树

- 平衡二叉树

- B树、B+树、B*树



### 图

- 常用概念
  - 顶点
  - 边
  - 路径
  - 无向图
  - 有向图
  - 带权图
- 表达方式
  - 二维数组表示（邻接矩阵）
  - 链表表示（邻接表）
- 遍历
  - 深度优先遍历
    - 压栈与弹栈

  - 广度优先遍历
    - 入队与出队











## 算法

### 排序

- 插入排序
  - 直接插入排序
  - 希尔排序
- 选择排序
  - 简单选择排序
  - 堆排序
- 交换排序
  - 冒泡排序
  - 快速排序
- 归并排序
- 基数排序
- 堆排序

| 排序法 | 平均时间    | 最差情况      | 稳定度 | 额外空间 | 备注                    |
| ------ | ----------- | ------------- | ------ | -------- | ----------------------- |
| 冒泡   | O(n²)       | O(n²)         | 稳定   | O(1)     | n较小时好               |
| 交换   | O(n²)       | O(n²)         | 不稳定 | O(1)     | n较小时好               |
| 选择   | O(n²)       | O(n²)         | 不稳定 | O(1)     | n较小时好               |
| 插入   | O(n²)       | O(n²)         | 稳定   | O(1)     | 大部分已排序时较好      |
| 基数   | O(log~R~ B) | O(log~R~ B)   | 稳定   | O(n)     | B（0~9）<br>R（个十百） |
| Shell  | O(logn)     | O(n^s^) 1<s<2 | 不稳定 | O(1)     | 指数大小取决于所选分区  |
| 快速   | O(logn)     | O(n²)         | 不稳定 | O(nlogn) | n较大时好               |
| 归并   | O(logn)     | O(nlogn)      | 稳定   | O(1)     | n较大时好               |
| 堆     | O(logn)     | O(nlogn)      | 不稳定 | O(1)     | n较大时好               |

- 解释
  - 稳定：原数组中相同的元素，经过排序后可能不再维持原排序



### 查找

- 线性查找
- 二分法查找
  - mid=(low+high)/2=low+(high-low)/2
- 插值查找
  - mid=low+(key-arr[low])/(arr[high]-arr[low])*(high-low)
- 斐波那契查找
  - mid=low+F(k-1)-1





### 十大算法

#### 分治算法

- 分治算法在每一层递归上都有三个步骤

  - 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
  - 解决：若子问题规模较小而容易被解决则直接解决，否则递归地解决各个子问题
  - 合并：将各个子问题的解合并为原问题的解

- 汉诺塔问题

  - ```java
    public static void hanoiTower(int num, char a, char b, char c) {
        if (num = 1) {
            System.out.println("第1个盘从 " +a+ "->" +c);
        } else {
            // 如果有 n>2 的情况，我们总是可以看作为两个盘：最下面的盘和上面所有的盘作为一个整体
            // 先把最上面的所有盘从a->b，期间用到c
            hanoiTower(num - 1, a, c, b);
            System.out.println("第"+ num +"个盘从 " +a+ "->" +c);
            // 把b塔中所有的盘从b->c，期间用到a
            hanoiTower(num - 1, b, a, c);
        }
    }
    ```



#### 动态规划算法



#### KMP算法

- 暴力匹配算法



#### 贪心算法















# 设计模式



## 设计原则

- 单一职责原则
  - 应该有且仅有一个原因引起类的变更
- 接口隔离原则
  - 客户端不应该依赖它不需要的接口，或者说类间的依赖关系应该建立在最小的接口上
- 依赖倒置原则
  - 抽象不应该依赖细节，细节应该依赖抽象
  - 依赖倒置的中心思想是面向接口编程
- 里氏替换原则
  - 子类必须完全实现父类的方法
  - 子类可以有自己的个性
  - 覆盖或实现父类的方法时，输入参数可以被放大
  - 覆盖或实现父类的方法时，输出结果可以被缩小
- 开闭原则
  - 一个软件实体如：类、模块和函数应该对扩展开放，对修改关闭。也就是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化
- 迪米特原则
  - 一个对象应该对其他对象有最少的了解
- 合成复用原则
  - 尽量使用组合、聚合的方式，而不是高耦合的继承方式







## 设计模式



### 创建型模式

#### 单例模式

##### 构建单例

- 静态常量、静态代码块（饿汉式）

  ```java
  class Singleton01{
      // 类的内部创建
      private final static Singleton01 instance = new SingleTon01();
      /*private final static Singleton01 instance;
      static {instance = new Singleton01();}*/
      
      // 构造器私有化
      private Singleton01(){}
      
      // 向外暴露一个静态的公共方法。getInstance
      public static Singleton01 getInstance(){
          return instance;
      }
  }
  ```

  - 说明
    - 写法简单，在类装载的时候就完成实例化，避免了线程的同步问题
    - 在类装载是就完成实例化，没有达到Lazy Loading的效果，如果从始至终未使用过这个实例，则会造成内存的浪费

- 懒加载（懒汉式）

  ```java
  class Singleton02(){
      private Singleton02(){}
      
      private static Singleton instance;
      
      public static synchronized Singleton02 getInstance(){
          if(instance == null){
              instance = new Singleton02();
          }
          return instance;
      }
  }
  ```

  - 说明
    - 此方法上：不加同步处理，线程不安全；加同步处理，效率低

- 双重检查

  ```java
  class Singleton03(){
      private Singleton03(){}
      
      private static volatile Singleton instance;
      
      public static Singleton getInstance(){
          if(instance == null){
              synchronized (Singleton03.class){
                  if(instance == null){
                      instance = new Singleton03();
                  }
              }
          }
          return instance;
      }
  }
  ```

  - 说明
    - 线程安全，效率加快

- 静态内部类

  ```java
  class Singleton04(){
      private Singleton04(){}
      
      private static class SingleInstance{
          private static final Singleton04 INSTANCE = new Singleton4();
      }
      
      private static Singleton getInstance(){
          return SingletonInstance.INSTANCE;
      }
  }
  ```

  - 说明
    - 外部类装载时，静态内部类并不会立即装载
    - 类装载时，线程是安全的
    - 调用getInstance方法时，才会让静态内部类装载
    - 类的静态属性，只会在第一次加载类的时候初始化

- 枚举

  ```java
  public class SingletonTest {
      public static void main(String[] args){
          Singleton instance1 = Singleton.INSTANCE;
          Singleton instance2 = Singleton.INSTANCE;
          // instance1 == instance2
      }
  }
  
  enum Singleton {
      INSTANCE;
  }
  ```

  - 说明
    - jdk1.5添加的枚举可以实现单例模式
    - 不仅能避免线程同步问题，而且还能防止反序列化重新创建新的对象



##### 破坏单例

- 序列化反序列化

  - SingletonTest实现可序列化接口Serializable

  - 测试反序列化后，对象是否一致

    ```java
    public class App {
        public static void main(String[] args) throws Exception {
            // writeObjectToFile();
            SingletonTest instance1 = readObjectFromFile();
            SingletonTest instance2 = readObjectFromFile();
            System.out.println(instance1 == instance2); // false
        }
    
        public static SingletonTest readObjectFromFile() throws Exception {
            ObjectInputStream ois = new ObjectInputStream(new FileInputStream("C:\\Users\\123\\Desktop\\singletonTest.obj"));
            SingletonTest instance = (SingletonTest) ois.readObject();
            ois.close();
            return instance;
        }
    
        public static void writeObjectToFile() throws Exception {
            SingletonTest instance = SingletonTest.getInstance();
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("C:\\Users\\123\\Desktop\\singletonTest.obj"));
            oos.writeObject(instance);
            oos.close();
        }
    }
    ```

  - 解决方法

    ```java
    class Singleton04(){
        private Singleton04(){}
    
        private static class SingleInstance{
            private static final Singleton04 INSTANCE = new Singleton4();
        }
    
        private static Singleton getInstance(){
            return SingletonInstance.INSTANCE;
        }
    
        // 添加readResolve()方法，当进行反序列化时，会自动调用该方法，将该方法的返回值直接返回
        public Object readResolve(){
            return SingleInstance.INSTANCE;
        }
    }
    ```

- 反射

  - 破坏单例

    ```java
    public class App2 {
        public static void main(String[] args) throws Exception {
            // 1.获取SingletonTest的字节码对象
            Class<SingletonTest> clazz = SingletonTest.class;
            // 2.获取无参构造方法
            Constructor<SingletonTest> cons = clazz.getDeclaredConstructor();
            // 3.取消访问检查
            cons.setAccessible(true);
            // 4.创建Singleton对象
            SingletonTest singletonTest1 = cons.newInstance();
            SingletonTest singletonTest2 = cons.newInstance();
            System.out.println(singletonTest1 == singletonTest2); // false
        }
    }
    ```

  - 改善方法

    ```java
    class Singleton04(){
        // 这个方法也能通过反射改flag值来破坏
        private static boolean flag = false;
        private SingletonTest(){
            // 需要解决线程安全
            synchronized (SingletonTest.class){
                if (flag) throw new RuntimeException("不能创建多个对象");
                flag = true;
            }
        }
    
        private static class SingleInstance{
            private static final Singleton04 INSTANCE = new Singleton4();
        }
    
        private static Singleton getInstance(){
            return SingletonInstance.INSTANCE;
        }
    }
    ```






#### 简单静态工厂模式

- 简单静态工厂模式（不是23种设计模式之一）

  ```java
  public class SimpleCoffeeFactory {
      public static Coffee createCoffee(String type){
          switch (type){
              case "美式":
                  return new AmericanCoffee();
              case "拿铁":
                  return new LatteCoffee();
              default:
                  throw new RuntimeException("没有这种咖啡");
          }
      }
  }
  ```

  ```java
  public class CoffeeStore {
      public Coffee orderCoffee(String type){
          Coffee coffee = SimpleCoffeeFactory.createCoffee(type);
          coffee.addMilk();
          coffee.addSugar();
          return coffee;
      }
  }
  ```

  - 依旧违背开闭原则

- 可通过【工厂模式+配置文件】形式解耦合

  - CoffeeFactory

    ```java
    public class CoffeeFactory {
        // 存储配置文件的解析数据
        private static HashMap<String, Coffee> map = new HashMap<>();
    
        // 读取并解析配置文件
        static {
            Properties properties = new Properties();
            InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");
            try {
                properties.load(is);
                Set<Object> keys = properties.keySet();
                for (Object key : keys) {
                    String className = properties.getProperty((String) key);
                    Class clazz = Class.forName(className);
                    Coffee coffee = (Coffee) clazz.newInstance();
                    map.put((String) key, coffee);
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    
        // 根据名称获取对象
        public static Coffee createCoffee(String name){
            return map.get(name);
        }
    }
    ```

  - bean.properties

    ```properties
    american = cn.Eli.coffee.AmericanCoffee
    latte = cn.Eli.coffee.LatteCoffee
    ```






#### 工厂方法模式

- 定义抽象工厂类

  ```java
  public abstract class CoffeeFactory {
      public abstract Coffee createCoffee();
  }
  ```

- 细化工厂

  ```java
  public class AmericanCoffeeFactory extends CoffeeFactory{
      @Override
      public Coffee createCoffee() {
          return new AmericanCoffee();
      }
  }
  ```

- 使用工厂

  ```java
  public class CoffeeStore {
      private CoffeeFactory factory;
  
      public void setFactory(CoffeeFactory factory){
          this.factory = factory;
      }
  
      public Coffee orderCoffee(){
          Coffee coffee = factory.createCoffee();
          coffee.addMilk();
          coffee.addSugar();
          return coffee;
      }
  }
  ```

- 遵循开闭原则





#### 抽象工厂模式

- uml图

  ![抽象工厂模式](D:\picture\typora\java\uml\抽象工厂模式.png)

- 具体工厂类

  ```java
  public class AmericanDessertFactory implements DessertFactory{
      @Override
      public Coffee createCoffee() {
          return new AmericanCoffee();
      }
  
      @Override
      public Dessert createDessert() {
          return new MatchMouse();
      }
  }
  ```





#### 原型模式

- 概述

  - 定义：用一个已经创建的实例对象作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象

  - 结构

    - 抽象原型类：规定了具体原型对象必须实现的 clone() 方法
    - 具体原型类：实现抽象原型类的 clone() 方法
    - 访问类：使用具体原型类中的 clone() 方法类复制新的对象

  - uml图

    ![原型模式](D:\picture\typora\java\uml\原型模式.png)

- 代码实现

  - 浅克隆：对于引用类型的属性，复制出来的对象中的属性仍指向原对象中属性的地址

    ```java
    public class Award implements Cloneable{
        private Student student;
        
        public Award(Student student){this.student = student;}
    
        @Override
        public Award clone() throws CloneNotSupportedException {
            return (Award) super.clone();
        }
    }
    ```

  - 深克隆：属性中引用的其他对象也会被克隆，不再指向原有地址

    - 可通过将对象序列化到硬盘上，再反序列化获得原对象的深克隆对象





#### 建造者模式

- 概述

  - 结构

    - 抽象建造者类(Builder)：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的对象部件的创建
    - 具体建造者类(ConcreteBuilder)：实现Builder接口，完成复杂产品的哥哥部件的具体创建方法。在构造过程完成后，提供产品的实例
    - 产品类(Product)：要创建的复杂对象（要求：创建的产品要有较多共同点）
    - 指挥者类(Director)：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建

  - uml图

    ![建造者模式](D:\picture\typora\java\uml\建造者模式.png)

- 代码实现

  - 抽象建造者

    ```java
    public abstract class Builder {
        protected Bike bike = new Bike();
    
        public abstract void buildFrame();
        public abstract void buildSeat();
        public abstract Bike createBike();
    }
    ```

  - 具体建造者

    ```java
    public class MobileBuilder extends Builder{
        @Override
        public void buildFrame() {bike.setFrame("铝合金车架");}
        
        @Override
        public void buildSeat() {bike.setSeat("真皮车座");}
        
        @Override
        public Bike createBike() {return bike;}
    }
    ```

  - 指挥者

    ```java
    public class Director {
        private Builder builder;
    
        public Director(Builder builder){this.builder = builder;}
    
        // 控制各部分是否组装，如何组装
        public Bike construct(){
            builder.buildFrame();
            builder.buildSeat();
            return builder.createBike();
        }
    }
    ```

- 拓展

  ```java
  public class Laptop {
      private String cpu;
      private String screen;
      private String memory;
      private String mainBoard;
  
      private Laptop(Builder builder){
          this.cpu = builder.cpu;
          this.screen = builder.screen;
          this.memory = builder.memory;
          this.mainBoard = builder.mainBoard;
      }
  
      public static final class Builder{
          private String cpu;
          private String screen;
          private String memory;
          private String mainBoard;
  
          public Builder cpu(String cpu){
              this.cpu = cpu;
              return this;
          }
          public Builder screen(String screen){
              this.screen = screen;
              return this;
          }
          public Builder memory(String memory){
              this.memory = memory;
              return this;
          }
          public Builder mainBoard(String mainBoard){
              this.mainBoard = mainBoard;
              return this;
          }
  
          public Laptop build(){
              return new Laptop(this);
          }
      }
  }
  ```

  ```java
  Laptop laptop = new Laptop.Builder()
      .cpu("intel")
      .screen("三星屏幕")
      .memory("金士顿内存条")
      .mainboard("华硕主板")
      .build();
  ```
  
  





### 结构型模式

#### 代理模式

- 静态代理模式

  - ```java
    public interface sellTickets {
        void sell();
    }
    ```

  - ```java
    public class TrainStation implements sellTickets {
        public void sell(){
            System.out.println("火车站卖票");
        }
    }
    ```

  - ```java
    public class ProxyPrint implements sellTickets {
        // 聚合火车站对象
        private TrainStation trainStation = new TrainStation();
        
        public void sell(){
            System.out.println("代售点收取一些手续费");
            trainStation.sell();
        }
    }
    ```

- jdk代理

  - ```java
    public class ProxyFactory {
        private Object target;
        
        public ProxyFactory(Object target) {
            this.target = target;
        }
        
        public Object getProxyInstance() {
            Object pi = Proxy.newProxyInstance(
                // 第一个参数：目标对象的类加载器
            	target.getclass().getClassLoader(),
                // 第二个参数：目标对象实现的所有接口
                target.getclass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args){
                        Object result = method.invoke(target, args);
                        return result;
                    }
                }
            );
            return pi;
        }
    }
    ```

  - 根据目标对象实现的接口得到目标对象中重写的方法，因此，目标对象中的方法没有对应的接口则不能代理
  
- Cglib代理

  - 引入Cglib相关依赖包

    ```xml
    <dependency>
        <groupId>cglib</groupId>
        <artifactId>cglib</artifactId>
        <version>3.3.0</version>
    </dependency>
    ```
  
  - 实现
  
    ```java
    public class ProxyFactory<T> implements MethodInterceptor {
        private T target;
        
        public ProxyFactory(T target) {
            this.target = target;
        }
        
        // 返回target的代理对象
        public T getProxyInstance() {
            // 1.创建一个工具类
            Enhancer enhancer = new Enhancer();
            // 2.设置父类
            enhancer.setSuperClass(target.getClass());
            // 3.设置回调函数
            enhancer.setCallback(this);
            // 4.创建子类对象，即代理对象
            return (T) enhancer.create();
        }
        
        @Override
        public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {
            Object result = method.invoke(target, args);
            return result;
        }
    }
    ```





#### 适配器模式

- 简单适配器（适配器类违背合成复用原则）

  - 类图
    - ![适配器模式](D:\picture\typora\java\uml\适配器模式.png)

  - SDAdapterTF类

    - ```java
      public class SDAdapterTF extends TFCardImpl implements SDCard{
          @Override
          public String readSD() {
              return readTF();
          }
      
          @Override
          public void writeSD() {
              writeTF();
          }
      }
      ```

- 对象适配器模式

  - ```java
    public class SDAdapterTF implements SDCard{
        private TFCard tfCard;
    
        public SDAdapterTF(TFCard tfCard) {
            this.tfCard = tfCard;
        }
    
        @Override
        public String readSD() {
            return tfCard.readTF();
        }
    
        @Override
        public void writeSD() {
            tfCard.writeTF();
        }
    }
    ```

- 接口适配器模式

  - 当不希望实现接口中的所有方法时，可以创建一个抽象类Adapter，实现所有方法，而此时我们只需要继承该抽象类即可





#### 桥接模式

- uml图
  - ![桥接模式](D:\picture\typora\java\uml\桥接模式.png)





#### 装饰模式

- uml图
  - ![装饰者模式](D:\picture\typora\java\uml\装饰者模式.png)

- 代码

  - ```java
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public abstract class FastFood {
        private float price;
        private String desc;
    
        public abstract float cost();
    }
    ```

  - ```java
    public class FiredRice extends FastFood{
        public FiredRice() {
            super(10, "炒饭");
        }
    
        @Override
        public float cost() {
            return getPrice();
        }
    }
    ```

  - ```java
    public abstract class Garnish extends FastFood{
        private FastFood fastFood;
    
        public FastFood getFastFood() {
            return fastFood;
        }
    
        public void setFastFood(FastFood fastFood) {
            this.fastFood = fastFood;
        }
    
        public Garnish(FastFood fastFood, float price, String desc) {
            super(price, desc);
            this.fastFood = fastFood;
        }
    }
    ```

  - ```java
    public class Egg extends Garnish {
    
        public Egg(FastFood fastFood) {
            super(fastFood, 2, "鸡蛋");
        }
    
        @Override
        public float cost() {
            return getFastFood().cost() + getPrice();
        }
    
        @Override
        public String getDesc() {
            return super.getDesc() + getFastFood().getDesc();
        }
    }
    ```

  - ```java
    @Test
    public void test() {
        FastFood fastFood = new FiredRice();
        Egg egg = new Egg(fastFood);
        System.out.println(egg.getDesc()+"   price："+egg.cost());
        Egg doubleEgg = new Egg(egg);
        System.out.println(doubleEgg.getDesc()+"   price："+doubleEgg.cost());
    }
    ```

    



#### 组合模式

- 透明组合模式
  - ![组合模式](D:\picture\typora\java\uml\组合模式.png)

- 安全组合模式

  - ![组合模式-安全性](D:\picture\typora\java\uml\组合模式-安全性.png)

  - 将方法从remove、add等方法从父类中移走，在Menu类中添加
    - 优点：MenuItem无法调用其本身不应该调用的方法，因此不会出现异常
    - 缺点：本质上区分了Menu类对象和MenuItem类对象，不能完全针对抽象编程，必须区别对待叶子构件和容器构件





#### 外观模式

- uml图
  - ![外观模式](D:\picture\typora\java\uml\外观模式.png)





#### 享元模式

- uml图
  - ![享元模式](D:\picture\typora\java\uml\享元模式.png)





### 行为型模式

#### 模板方式模式

- 主要组件
  - 抽象类
    - 模板方法：定义了具体方法的调用流程等算法
    - 基本方法
      - 抽象方法：父类定义抽象方法
      - 具体方法：子类重写父类的抽象方法
      - 钩子方法
  - 具体子类
- 特点：父类中的抽象方法由子类实现，子类执行结果会影响父类的结果，形成反向控制的结构





#### 命令模式

- uml图
  - ![命令模式](D:\picture\typora\java\uml\命令模式.png)

- 特点
  - 请求调用者和请求接受者解耦
  - 支持命令的撤销与恢复





#### 访问者模式

- uml图
  - ![访问者模式](D:\picture\typora\java\uml\访问者模式.png)

- 双分派

  - ```java
    public class Dog implements Animal {
        public void acceptPerson(Person person) {
            person.feed(this);
        }
    }
    ```

    





#### 迭代器模式

- uml图
  - ![迭代器模式](D:\picture\typora\java\uml\迭代器模式.png)

- jdk中使用迭代器
  - 聚合类实现 java.lang.Iterable 接口，并实现 iterator() 方法返回一个java.util.Iterator 的实现类





#### 观察者模式

- uml图
  - ![观察者模式](D:\picture\typora\java\uml\观察者模式.png)

- jdk中提供的实现
  
  - Observable：jdk9开始被废弃
  
    - Observable类：抽象主题类
  
      - void addObserver(Observer o)
  
      - void notifyObservers(Object arg)：越晚加入的观察者越早通知
  
      - void setChange()：将一个flag设置为true，该flag为true后，notify方法才能通知观察者，通知过后自动变为false
  
        ```java
        @Override
        public void notifyObservers(Object arg) {
            super.setChanged();
            super.notifyObservers(arg);
        }
        ```
  
    - Observer：抽象观察者
  
  - PropertyChangeSupport：监听bean
  
    - bean
  
      ```java
      @AllArgsConstructor
      @ToString(exclude = "changeSupport")
      class Student {
          private String name;
          private final PropertyChangeSupport changeSupport = new PropertyChangeSupport(this);
      
          public void setName(String name) {
              changeSupport.firePropertyChange("name", this.name, name);
              this.name = name;
          }
      
          public void addPropertyChangeListener(PropertyChangeListener listener) {
              changeSupport.addPropertyChangeListener(listener);
          }
      
          public void removePropertyChangeListener(PropertyChangeListener listener) {
              changeSupport.removePropertyChangeListener(listener);
          }
      }
      ```
  
    - linstener
  
      ```java
      @Slf4j
      public class ListenerImpl implements PropertyChangeListener {
          @Override
          public void propertyChange(PropertyChangeEvent evt) {
              log.info("修改的属性是：{}", evt.getPropertyName());
              log.info("由原来的值：{} ，改为新的值：{}", evt.getOldValue(), evt.getNewValue());
          }
      }
      ```
  





#### 中介者模式

- uml图
  - ![中介者模式](D:\picture\typora\java\uml\中介者模式.png)





#### 备忘录模式

- 白盒备忘录

  - ![白箱备忘录模式](D:\picture\typora\java\uml\白箱备忘录模式.png)
  - RoleStateCaretaker 作为管理 RoleStateMemento（存储数据类）的类，也可以对存储的数据进行修改

- 黑盒备忘录

  - 对发起人提供宽接口，对管理数据类提供窄接口
    - 定义一个空接口Memento作为窄接口 供RoleStateCaretaker声明使用
    - 在GameRole内部定义 Memento 的实现类，作为宽接口
  - ![黑箱备忘录模式](D:\picture\typora\java\uml\黑箱备忘录模式.png)

  - RoleStateCaretaker 不拿到具体实现类，无法向下转型





#### 解释器模式

- uml图
  - ![解释器模式](D:\picture\typora\java\uml\解释器模式.png)





#### 状态模式

- 简单模式
  - ![状态模式前](D:\picture\typora\java\uml\状态模式前.png)

- 状态模式
  - ![状态模式](D:\picture\typora\java\uml\状态模式.png)





#### 策略模式

- uml图
  - ![策略模式](D:\picture\typora\java\uml\策略模式.png)





#### 责任链模式

- uml图
  - ![责任链模式](D:\picture\typora\java\uml\责任链模式.png)







## 自定义Spring框架

### 7.1 spring使用回顾

自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。

* 数据访问层。定义UserDao接口及其子实现类

  ```java
  public interface UserDao {
      public void add();
  }
  
  public class UserDaoImpl implements UserDao {
  
      public void add() {
          System.out.println("userDaoImpl ....");
      }
  }
  ```

* 业务逻辑层。定义UserService接口及其子实现类

  ```java
  public interface UserService {
      public void add();
  }
  
  public class UserServiceImpl implements UserService {
  
      private UserDao userDao;
  
      public void setUserDao(UserDao userDao) {
          this.userDao = userDao;
      }
  
      public void add() {
          System.out.println("userServiceImpl ...");
          userDao.add();
      }
  }
  ```

* 定义UserController类，使用main方法模拟controller层

  ```java
  public class UserController {
      public static void main(String[] args) {
          //创建spring容器对象
          ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
          //从IOC容器中获取UserService对象
          UserService userService = applicationContext.getBean("userService", UserService.class);
          //调用UserService对象的add方法
          userService.add();
      }
  }
  ```

* 编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件

  ```java
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://www.springframework.org/schema/beans"
         xmlns:context="http://www.springframework.org/schema/context"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context.xsd">
  
      <bean id="userService" class="com.itheima.service.impl.UserServiceImpl">
          <property name="userDao" ref="userDao"></property>
      </bean>
  
      <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean>
  
  </beans>
  ```

  代码运行结果如下：

  ![image-20200429165544151](D:\picture\typora\java\IOC\image-20200429165544151.png)

通过上面代码及结果可以看出：

* userService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。
* 上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。
* UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。

上面三点体现了Spring框架的IOC（Inversion of Control）和DI（Dependency Injection, DI）



### 7.2 spring核心功能结构

Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:

核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图：

![image-20200429111324770](D:\picture\typora\java\IOC\image-20200429111324770.png)



核心容器由 beans、core、context 和 expression（Spring Expression Language，SpEL）4个模块组成。

* spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。
* spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，它的超类是 BeanFactory。与BeanFactory不同，ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。
* spring-context-support模块是对Spring IoC容器及IoC子容器的扩展支持。
* spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。
* spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同Spring IoC进行交互。



#### 7.2.1 bean概述

Spring 就是面向 `Bean` 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。

spring中bean用于对一个类进行封装。如下面的配置：

```xml
<bean id="userService" class="com.itheima.service.impl.UserServiceImpl">
    <property name="userDao" ref="userDao"></property>
</bean>
<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean>
```

为什么Bean如此重要呢？

* spring 将bean对象交由一个叫IOC容器进行管理。
* bean对象之间的依赖关系在配置文件中体现，并由spring完成。



### 7.3 Spring IOC相关接口分析

#### 7.3.1 BeanFactory解析

Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。

![image-20200429185050396](D:\picture\typora\java\IOC\image-20200429185050396.png)

其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。

那么为何要定义这么多层次的接口呢？

每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，

* ListableBeanFactory接口表示这些Bean可列表化。
* HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean
* AutowireCapableBeanFactory 接口定义Bean的自动装配规则。

这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码：

```java
public interface BeanFactory {

	String FACTORY_BEAN_PREFIX = "&";

	//根据bean的名称获取IOC容器中的的bean对象
	Object getBean(String name) throws BeansException;
	//根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了
	<T> T getBean(String name, Class<T> requiredType) throws BeansException;
	Object getBean(String name, Object... args) throws BeansException;
	<T> T getBean(Class<T> requiredType) throws BeansException;
	<T> T getBean(Class<T> requiredType, Object... args) throws BeansException;
	
	<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
	<T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);

	//判断容器中是否包含指定名称的bean对象
	boolean containsBean(String name);
	//根据bean的名称判断是否是单例
	boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
	boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
	boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
	boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;
	@Nullable
	Class<?> getType(String name) throws NoSuchBeanDefinitionException;
	String[] getAliases(String name);
}
```

在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。

BeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。

![image-20200430220155371](D:\picture\typora\java\IOC\image-20200430220155371.png)

要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：

* ClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。
* FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。
* AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。



#### 7.3.2 BeanDefinition解析

Spring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件

```xml
<bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean>

bean标签还有很多属性：
	scope、init-method、destory-method等。
```

其继承体系如下图所示。

![image-20200429204239868](D:\picture\typora\java\IOC\image-20200429204239868.png)



#### 7.3.3 BeanDefinitionReader解析

Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。

![image-20200429204700956](D:\picture\typora\java\IOC\image-20200429204700956.png)

看看BeanDefinitionReader接口定义的功能来理解它具体的作用：

```java
public interface BeanDefinitionReader {

	//获取BeanDefinitionRegistry注册器对象
	BeanDefinitionRegistry getRegistry();

	@Nullable
	ResourceLoader getResourceLoader();

	@Nullable
	ClassLoader getBeanClassLoader();

	BeanNameGenerator getBeanNameGenerator();

	/*
		下面的loadBeanDefinitions都是加载bean定义，从指定的资源中
	*/
	int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException;
	int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException;
	int loadBeanDefinitions(String location) throws BeanDefinitionStoreException;
	int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;
}
```



#### 7.3.4 BeanDefinitionRegistry解析

BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。

```java
public interface BeanDefinitionRegistry extends AliasRegistry {

	//往注册表中注册bean
	void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException;

	//从注册表中删除指定名称的bean
	void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;

	//获取注册表中指定名称的bean
	BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
    
	//判断注册表中是否已经注册了指定名称的bean
	boolean containsBeanDefinition(String beanName);
    
	//获取注册表中所有的bean的名称
	String[] getBeanDefinitionNames();
    
	int getBeanDefinitionCount();
	boolean isBeanNameInUse(String beanName);
}
```

继承结构图如下：

![image-20200429211132185](D:\picture\typora\java\IOC\image-20200429211132185.png)

从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：

* DefaultListableBeanFactory

  在该类中定义了如下代码，就是用来注册bean

  ```java
  private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);
  ```

* SimpleBeanDefinitionRegistry

  在该类中定义了如下代码，就是用来注册bean

  ```java
  private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(64);
  ```



#### 7.3.5 创建容器

ClassPathXmlApplicationContext对Bean配置资源的载入是从refresh（）方法开始的。refresh（）方法是一个模板方法，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh（）方法启动整个IoC容器对Bean定义的载入过程。





### 7.4 自定义SpringIOC

现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans>
    <bean id="userService" class="com.itheima.service.impl.UserServiceImpl">
        <property name="userDao" ref="userDao"></property>
    </bean>
    <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"></bean>
</beans>
```

#### 7.4.1 定义bean相关的pojo类

##### 7.4.1.1 PropertyValue类

用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。

```java
public class PropertyValue {

  private String name;
  private String ref;
  private String value;

  public PropertyValue() {
  }

  public PropertyValue(String name, String ref,String value) {
    this.name = name;
    this.ref = ref;
    this.value = value;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public String getRef() {
    return ref;
  }

  public void setRef(String ref) {
    this.ref = ref;
  }

  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }
}
```



##### 7.4.1.2 MutablePropertyValues类

一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。

```java
public class MutablePropertyValues implements Iterable<PropertyValue> {

    private final List<PropertyValue> propertyValueList;

    public MutablePropertyValues() {
        this.propertyValueList = new ArrayList<PropertyValue>();
    }

    public MutablePropertyValues(List<PropertyValue> propertyValueList) {
        this.propertyValueList = (propertyValueList != null ? propertyValueList : new ArrayList<PropertyValue>());
    }

    public PropertyValue[] getPropertyValues() {
        return this.propertyValueList.toArray(new PropertyValue[0]);
    }

    public PropertyValue getPropertyValue(String propertyName) {
        for (PropertyValue pv : this.propertyValueList) {
            if (pv.getName().equals(propertyName)) {
                return pv;
            }
        }
        return null;
    }

    @Override
    public Iterator<PropertyValue> iterator() {
        return propertyValueList.iterator();
    }

    public boolean isEmpty() {
        return this.propertyValueList.isEmpty();
    }

    public MutablePropertyValues addPropertyValue(PropertyValue pv) {
        for (int i = 0; i < this.propertyValueList.size(); i++) {
            PropertyValue currentPv = this.propertyValueList.get(i);
            if (currentPv.getName().equals(pv.getName())) {
                this.propertyValueList.set(i, new PropertyValue(pv.getName(),pv.getRef(), pv.getValue()));
                return this;
            }
        }
        this.propertyValueList.add(pv);
        return this;
    }

    public boolean contains(String propertyName) {
        return getPropertyValue(propertyName) != null;
    }
}
```



##### 7.4.1.3 BeanDefinition类

BeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。

```java
public class BeanDefinition {
    private String id;
    private String className;

    private MutablePropertyValues propertyValues;

    public BeanDefinition() {
        propertyValues = new MutablePropertyValues();
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getClassName() {
        return className;
    }

    public void setClassName(String className) {
        this.className = className;
    }

    public void setPropertyValues(MutablePropertyValues propertyValues) {
        this.propertyValues = propertyValues;
    }

    public MutablePropertyValues getPropertyValues() {
        return propertyValues;
    }
}
```



#### 7.4.2 定义注册表相关类

##### 7.4.2.1 BeanDefinitionRegistry接口

BeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能：

* 注册BeanDefinition对象到注册表中
* 从注册表中删除指定名称的BeanDefinition对象
* 根据名称从注册表中获取BeanDefinition对象
* 判断注册表中是否包含指定名称的BeanDefinition对象
* 获取注册表中BeanDefinition对象的个数
* 获取注册表中所有的BeanDefinition的名称

```java
public interface BeanDefinitionRegistry {

    //注册BeanDefinition对象到注册表中
    void registerBeanDefinition(String beanName, BeanDefinition beanDefinition);

    //从注册表中删除指定名称的BeanDefinition对象
    void removeBeanDefinition(String beanName) throws Exception;

    //根据名称从注册表中获取BeanDefinition对象
    BeanDefinition getBeanDefinition(String beanName) throws Exception;

    boolean containsBeanDefinition(String beanName);

    int getBeanDefinitionCount();

    String[] getBeanDefinitionNames();
}
```



##### 7.4.2.2 SimpleBeanDefinitionRegistry类

该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。

```java
public class SimpleBeanDefinitionRegistry implements BeanDefinitionRegistry {

    private Map<String, BeanDefinition> beanDefinitionMap = new HashMap<String, BeanDefinition>();

    @Override
    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) {
        beanDefinitionMap.put(beanName,beanDefinition);
    }

    @Override
    public void removeBeanDefinition(String beanName) throws Exception {
        beanDefinitionMap.remove(beanName);
    }

    @Override
    public BeanDefinition getBeanDefinition(String beanName) throws Exception {
        return beanDefinitionMap.get(beanName);
    }

    @Override
    public boolean containsBeanDefinition(String beanName) {
        return beanDefinitionMap.containsKey(beanName);
    }

    @Override
    public int getBeanDefinitionCount() {
        return beanDefinitionMap.size();
    }

    @Override
    public String[] getBeanDefinitionNames() {
        return beanDefinitionMap.keySet().toArray(new String[1]);
    }
}
```



#### 7.4.3 定义解析器相关类

##### 7.4.3.1 BeanDefinitionReader接口

BeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范：

* 获取注册表的功能，让外界可以通过该对象获取注册表对象。
* 加载配置文件，并注册bean数据。

```java
public interface BeanDefinitionReader {

	//获取注册表对象
    BeanDefinitionRegistry getRegistry();
	//加载配置文件并在注册表中进行注册
    void loadBeanDefinitions(String configLocation) throws Exception;
}
```



##### 7.4.3.2 XmlBeanDefinitionReader类

XmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。

```java
public class XmlBeanDefinitionReader implements BeanDefinitionReader {

    private BeanDefinitionRegistry registry;

    public XmlBeanDefinitionReader() {
        this.registry = new SimpleBeanDefinitionRegistry();
    }

    @Override
    public BeanDefinitionRegistry getRegistry() {
        return registry;
    }

    @Override
    public void loadBeanDefinitions(String configLocation) throws Exception {

        InputStream is = this.getClass().getClassLoader().getResourceAsStream(configLocation);
        SAXReader reader = new SAXReader();
        Document document = reader.read(is);
        Element rootElement = document.getRootElement();
        //解析bean标签
        parseBean(rootElement);
    }

    private void parseBean(Element rootElement) {

        List<Element> elements = rootElement.elements();
        for (Element element : elements) {
            String id = element.attributeValue("id");
            String className = element.attributeValue("class");
            BeanDefinition beanDefinition = new BeanDefinition();
            beanDefinition.setId(id);
            beanDefinition.setClassName(className);
            List<Element> list = element.elements("property");
            MutablePropertyValues mutablePropertyValues = new MutablePropertyValues();
            for (Element element1 : list) {
                String name = element1.attributeValue("name");
                String ref = element1.attributeValue("ref");
                String value = element1.attributeValue("value");
                PropertyValue propertyValue = new PropertyValue(name,ref,value);
                mutablePropertyValues.addPropertyValue(propertyValue);
            }
            beanDefinition.setPropertyValues(mutablePropertyValues);

            registry.registerBeanDefinition(id,beanDefinition);
        }
    }
}
```



#### 7.4.4 IOC容器相关类

##### 7.4.4.1 BeanFactory接口

在该接口中定义IOC容器的统一规范即获取bean对象。

```java
public interface BeanFactory {
	//根据bean对象的名称获取bean对象
    Object getBean(String name) throws Exception;
	//根据bean对象的名称获取bean对象，并进行类型转换
    <T> T getBean(String name, Class<? extends T> clazz) throws Exception;
}
```



##### 7.4.4.2 ApplicationContext接口

该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义 `refresh()` 方法，该方法主要完成以下两个功能：

* 加载配置文件。
* 根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。

```java
public interface ApplicationContext extends BeanFactory {
	//进行配置文件加载并进行对象创建
    void refresh() throws IllegalStateException, Exception;
}
```



##### 7.4.4.3 AbstractApplicationContext类

* 作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。

* 声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。

  BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。

```java
public abstract class AbstractApplicationContext implements ApplicationContext {

    protected BeanDefinitionReader beanDefinitionReader;
    //用来存储bean对象的容器   key存储的是bean的id值，value存储的是bean对象
    protected Map<String, Object> singletonObjects = new HashMap<String, Object>();

    //存储配置文件的路径
    protected String configLocation;

    public void refresh() throws IllegalStateException, Exception {

        //加载BeanDefinition
        beanDefinitionReader.loadBeanDefinitions(configLocation);

        //初始化bean
        finishBeanInitialization();
    }

    //bean的初始化
    private void finishBeanInitialization() throws Exception {
        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();
        String[] beanNames = registry.getBeanDefinitionNames();

        for (String beanName : beanNames) {
            BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);
            getBean(beanName);
        }
    }
}
```

> 注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。



##### 7.4.4.4 ClassPathXmlApplicationContext类

该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：

* 在构造方法中，创建BeanDefinitionReader对象。
* 在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。
* 重写父接口中的getBean()方法，并实现依赖注入操作。

```java
public class ClassPathXmlApplicationContext extends AbstractApplicationContext{

    public ClassPathXmlApplicationContext(String configLocation) {
        this.configLocation = configLocation;
        //构建XmlBeanDefinitionReader对象
        beanDefinitionReader = new XmlBeanDefinitionReader();
        try {
            this.refresh();
        } catch (Exception e) {
        }
    }

    //根据bean的id属性值获取bean对象
    @Override
    public Object getBean(String name) throws Exception {

        //return singletonObjects.get(name);
        Object obj = singletonObjects.get(name);
        if(obj != null) {
            return obj;
        }

        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();
        BeanDefinition beanDefinition = registry.getBeanDefinition(name);
        if(beanDefinition == null) {
            return null;
        }
        String className = beanDefinition.getClassName();
        Class<?> clazz = Class.forName(className);
        Object beanObj = clazz.newInstance();
        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();
        for (PropertyValue propertyValue : propertyValues) {
            String propertyName = propertyValue.getName();
            String value = propertyValue.getValue();
            String ref = propertyValue.getRef();
            if(ref != null && !"".equals(ref)) {

                Object bean = getBean(ref);
                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);
                Method[] methods = clazz.getMethods();
                for (Method method : methods) {
                    if(method.getName().equals(methodName)) {
                        method.invoke(beanObj,bean);
                    }
                }
            }

            if(value != null && !"".equals(value)) {
                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);
                Method method = clazz.getMethod(methodName, String.class);
                method.invoke(beanObj,value);
            }
        }
        singletonObjects.put(name,beanObj);
        return beanObj;
    }

    @Override
    public <T> T getBean(String name, Class<? extends T> clazz) throws Exception {

        Object bean = getBean(name);
        if(bean != null) {
            return clazz.cast(bean);
        }
        return null;
    }
}
```



#### 7.4.5 自定义Spring IOC总结

##### 7.4.5.1 使用到的设计模式

* 工厂模式。这个使用工厂模式 + 配置文件的方式。
* 单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。
* 模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。
* 迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。

spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。

##### 7.4.5.2 符合大部分设计原则

##### 7.4.5.3 整个设计和Spring的设计还是有一定的出入

spring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的：

* 了解Spring底层对对象的大体管理机制。
* 了解设计模式在具体的开发中的使用。
* 以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。









# [MyBatis](https://mybatis.net.cn/index.html)

> 一套简化 JDBC 开发的持久层框架

## JDBC

> 由Java提供操作数据库的规范（接口），数据库公司实现该类接口，供 Java 开发者使用。

```java
// 加载驱动类入内存
Class.forName("com.mysql.jdbc.Driver");
// 获取连接对象
String url = "jdbc:mysql://127.0.0.1:3306/db1?useSSL=false";
String username = "root";
String password = "root";
Connection conn = DriverManager.getConnection(url, username, password);
// 定义SQL
String sql = "update account set money = 2000 where id = 1";
// 获取执行SQL对象
Statement stmt = conn.createStatement();
// 执行SQL
int count = stmt.executeUdate(sql);
// 处理结果
System.out.println(count);
// 释放资源
stmt.close();
conn.close();
```

- DriverManger 的作用

  - 注册驱动：`static registerDriver(Driver driver)`
  - 获得连接：`static getConnection(String url, String username, String password)`

- 问题1：`Class.forName("com.mysql.jdbc.Driver")` 只将类加载入内存，DriverManger是如何注册该驱动的对象的呢？

  ```java
  package com.mysql.cj.jdbc;
  
  public class Driver enxtends NonRegisteringDriver implements java.sql.Driver {
      public Driver() throws SQLException;
      
      // 只要Driver类被加载，就会执行下面静态代码块的代码，从而完成注册。
      static {
          try {
              DriverManger.registerDriver(new Driver());
          }catch(SQLException var1) {
              throw new RuntimeException("Can't register driver!");
          }
      }
  }
  ```

- 问题2：使用MySQL5之后的驱动jar包，为什么不用添加 `Class.forName("com.mysql.jdbc.Driver")` 这一行代码

  - MySQL5 之后的驱动jar包使用了 <font color=red>SPI</font> 机制，暴露了驱动类的位置，并根据位置自动加载驱动类入内存，不需要手动指出位置并加载驱动类

  - 暴露实现类
    - 在ClassPath路径下创建 META-INF/services 的文件夹
    - 该目录下创建文件，以实现类作为文件内容，实现类实现的接口作为文件名（如文件名：java.sql.Driver  文件内容：com.mysql.cj.jdbc.Driver）

- Connection 的作用

  - 获取执行SQL的对象

    - 获得普通执行SQL的对象：`Statement createStatement()`

    - 预编译SQL的执行SQL对象：防止SQL注入：`PreparedStatement prepareStatement(含占位符的sql)`

      ```java
      String sql = "select * from tb_user where username = ? and password = ?";
      PreparedStatement pstmt = conn.prepareStatement(sql);
      pstmt.setString(1, name);
      pstmt.setString(2, pwd);
      ResultSet rs = pstmt.executeQuery();
      ```

      > 开启预编译：jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&<font color=red>useServerPrepStmts=true</font>

      > java 程序在执行到 prepareStatement(sql) 方法后，会将含占位符的SQL发送给数据库，数据库收到后，进行语法检查、<font color=red>编译SQL</font>等操作，但不执行（因为此时内容是占位符）。
      >
      > 1. 后续等java程序传过来值后，再执行SQL，此时传入的值如果存在SQL注入的敏感字符，也不会重新编译
      > 2. 多条sql使用同一个含占位符sql，不会重复编译

    - 执行存储过程的对象：`CallableStatement prepareCall(sql)`

  - 管理事务

    - 开启事务：`setAutoCommit(boolean autoCommit)`
      - true：自动提交事务
      - false：手动提交事务，即开启事务
    - 提交事务：`commit()`
    - 回滚事务：`rollback()`

- Statement 的作用：执行SQL语句

  - 执行DML、DDL语句：`int executeUpdate(sql)`
    - 执行DML语句返回值：DML语句影响的行数
    - 执行DDL语句返回值：不能根据该返回值是否大于0判断是否执行成功，因为DDL执行成功，返回的也可能为0
  - 执行DQL语句：`ResultSet executeQuery(sql)` ，返回值为结果集

- 数据库连接池：分配管理数据库连接（Connection）

  - 标准接口：DataSource
    - 官方（SUN）提供的数据库连接池标准接口，由第三方组织实现
    - 功能：获得连接 `Connection getConnection`
  - 常见数据库连接池：Druid，Hikali，DBCP，C3P0





## 快速入门

- <span id="mybatis-config.xml">mybatis-config.xml</span>（MyBatis核心配置文件）

  > 用于替换连接信息，解决硬编码问题

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration
    PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
      <properties resource="配置文件如：jdbc.properties"/>
      <!-- 用于简化SQL映射文件中resultType属性的全路径类名的书写
      <typeAliases>
          <package name="包扫描路径如：cn.langh.domain"/>
      </typeAliases>
      -->
      <environments default="development">
          <environment id="development">
              <transactionManager type="JDBC"/>
              <dataSource type="POOLED">
                  <property name="driver" value="${driver}"/>
                  <property name="url" value="${url}"/>
                  <property name="username" value="${username}"/>
                  <property name="password" value="${password}"/>
              </dataSource>
          </environment>
      </environments>
      <mappers>
          <mapper resource="SQL映射文件1位置"/>
          <mapper resource="SQL映射文件2位置"/>
          <!-- 满足一定条件可直接用包扫描 
          <package name="包扫描路径如：cn.langh.mappper"/> 
          -->
      </mappers>
  </configuration>
  ```

- XxxMapper.xml（SQL映射文件）

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="命名空间">
      <select id="sql的id" resultType="返回的值的类型(pojo类的全路径限定名)">
          select * from Blog where id = #{id}
      </select>
  </mapper>
  ```

- 使用

  ```java
  public static void main(String[] args) {
      // 构建SqlSessionFactory
      String resource = "mybatis-config.xml在项目目录的位置";
      InputStream inputStream = Resources.getResourceAsStream(resource);
      SqlSessionFactory sqlSessionFactory = 
          new SqlSessionFactoryBuilder().build(inputStream);
  
      // 获取SqlSession对象，以此来执行sql（参数表明是否自动提交事务，不写默认false）
      SqlSession sqlSession = sqlSessionFactory.openSession(布尔值);
  
      // 执行SQL，返回值类型与SQL映射文件的resultType对应
      List<POJO> pojo = sqlSession.selectList("命名空间.sql的id");
  
      // 释放资源
      sqlsession.close();
  }
  ```





## Mapper代理

- 创建SQL映射文件，添加SQL语句

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="命名空间">
      <select id="selectAll" resultType="cn.langh.POJO.User">
          select * from mybatis_01
      </select>
      <select id="selectById" resultType="cn.langh.POJO.User">
          select * from mybatis_01 where id = #{id}
      </select>
  </mapper>
  ```

- 根据SQL映射文件，创建对应的映射接口

  ```java
  public interface UserMapper {
      // 方法名和返回参数 与 sql语句的id和resultType保持一致
      List<User> selectAll();
      User selectById(@Param("id") int id);
  }
  ```

- 将xml映射文件与映射接口放在同一目录中

- 设置SQL映射文件的namespace属性为Mapper接口的全限定名

  ```xml
  <mapper namespace="cn.langh.mapper.UserMapper">
      <select id="selectAll" resultType="cn.langh.POJO.User">
          select * from mybatis_01
      </select>
      <select id="selectById" resultType="cn.langh.POJO.User">
          select * from mybatis_01 where id = #{id}
      </select>
  </mapper>
  ```

- 构建SqlSessionFactory

- 获取SqlSession

- 执行sql

  - 获取UserMapper接口的代理对象

  ```java
  UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
  ```

  - 执行方法

  ```java
  List<User> users = userMapper.selectAll();
  ```

- 释放资源

- 如果Mapper接口的名称和sql映射文件的名称相同，并在同一目录下，则可以使用包扫描的方式**简化sql映射文件的加载**

  ```xml
  <!-- mybatis-config.xml 文件内  -->
  <mappers>
      <!--  <mapper resource="cn/langh/mapper/UserMapper.xml"/>  -->
      <package name="cn.langh.mappper"/>
  </mappers>
  ```

  



## mybatis核心配置文件

- configuration（配置）
  - [properties（属性）](https://mybatis.net.cn/configuration.html#properties)
  - [settings（设置）](https://mybatis.net.cn/configuration.html#settings)
  - [typeAliases（类型别名）](https://mybatis.net.cn/configuration.html#typeAliases)
  - [typeHandlers（类型处理器）](https://mybatis.net.cn/configuration.html#typeHandlers)
  - [objectFactory（对象工厂）](https://mybatis.net.cn/configuration.html#objectFactory)
  - [plugins（插件）](https://mybatis.net.cn/configuration.html#plugins)
  - environments（环境配置）
    - environment（环境变量）
      - transactionManager（事务管理器）
      - dataSource（数据源）
  - [databaseIdProvider（数据库厂商标识）](https://mybatis.net.cn/configuration.html#databaseIdProvider)
  - [mappers（映射器）](https://mybatis.net.cn/configuration.html#mappers)

- **environments**：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment
- **typeAliases**：可指定pojo包，会为包中的实体类自动取类型别名，**别名不区分大小写**，在mapper配置中的resultType中可使用该别名，**用于简化resultType中全路径类名的书写**
- **<font color=blue>配置标签是需要遵循一定的顺序</font>**



## 其他问题

- 数据库的字段名称 和 实体类的属性名称 不一样时，不能自动封装。三种解决方法：

  - 方法1：查询时取别名：对不一样的列名取别名，让别名与实体类属性名一致

    ```xml
    <select id="selectAll" resultTyep="User">
    	select id, user_name(数据库字段名称) as userName(别名) from user(表);
    </select>
    ```

  - 方法2：将sql片段抽取出来

    ```xml
    <sql id="sql_01">id, user_name as userName</sql>
    
    <select id="selectAll" resultTyep="User">
    	select
        	<include regid="sql_01"/>
        from user(表);
    </select>
    ```

  - 方法3：映射
    - id：唯一标识
    - type：放回的值的类型，也支持别名
    - 子标签
      - id：完成主键字段的映射
      - column：完成一般字段的映射
    
    ```xml
    <resultMap id="resultMap_01" type="user">
    	<result column="列名称" property="实体类的属性名"/>
        <result id="列名称" property="实体类的属性名"/>
    </resultMap>
    
    <select id="selectAll" resultType="reusltMap_01">
    	select 字段 from user(表)
    </select>
    ```

- 参数占位符

  - `#{参数}`：会将其替换为" **?** "。为了防止sql注入
  - `${参数}`：拼接sql，会存在sql注入问题

- 参数类型：select标签中的 **parameterType** 可以设置所传递的参数类型，可以省略

- 特殊字符的处理：

  - 转义字符：<：`&lt;`
  - cData区：将字符写在`<![CDATA[ 内容 ]]>`中
  
- 添加语句中的主键返回

  \<insert>标签中useGeneratedKeys属性属性设置为true，keyProperty设置为对象的主键



## 参数传递

> MyBatis 提供了 ParamNameResolver 类来进行参数封装

- 多个参数：当形参为多个参数时，会封装为Map集合

  ```java
  User login(@Param("username") String username,
             @Param("password") String password);
  
  /*  
  如果不添加 @Param 注解
    map.put("arg0", 参数值1); map.put("param1", 参数值1);
    map.put("arg1", 参数值2); map.put("param2", 参数值2);
    ......
  如果添加 @Param 注解
    map.put("param1", 参数值1); map.put("注解1value", 参数值1);
    map.put("param2", 参数值2); map.put("注解2value", 参数值2);
    
  @Param 注解中的value替换的是键名arg
  */
  ```

  ```xml
  <select id="login" resultType="cn.langh.POJO.User">
      select * from users 
      where username = #{}
      and password = #{}
  </select>
  <!--
  如果形参前不添加 @Param 注解
    #{} 中可填 arg0/param1; arg1/param2; ......
  如果形参前添加 @Param 注解
    #{} 中可填 param1/注解1value; param2/注解2value; ......
  -->
  ```

- 单个参数

  ```java
  User selectById(int id);
  User login(Map<String, String> map);
  ```

  - pojo类型：直接使用，方法的形参名 和 参数占位符名 一致（#{}中直接填映射接口中方法中的对应形参名）

  - map集合：直接使用，map中的键名 和 参数占位符名 一致

  - Collection：封装为Map集合，可以使用@Param注解，替换集合中默认的arg键名

    ```java
    map.put("arg0",collection集合坐标);
    map.put("collection",collection集合坐标);
    ```

  - List：封装为Map集合，可以使用@Param注解，替换集合中默认的arg键名

    ```java
    map.put("arg0",collection集合坐标);
    map.put("collection",collection集合坐标);
    map.put("list",collection集合坐标);
    ```

  - Array：封装为Map集合，可以使用@Param注解，替换集合中默认的arg键名

    ```java
    map.put("arg0",数组);
    map.put("array",数组);
    ```

  - 其他类型：如int，double等，直接使用



## 动态sql

- \<if>标签

```xml
<if test="\布尔表达式\"> 内容 </if>
```

```xml
<select id="..." resultMap="...">
    select * form tb_brand
    <where>
        <if test="companyName != null and companyName != ''">
            and company_name like #{companyName}
        </if>
        <if test="status != null">and status = #{status}</if>
    </where>
</select>
```

- \<choose>标签

```xml
<choose>
	<when test=""></when>
    <when test=""></when>
    <otherwise></otherwise>
</choose>
```

- \<where>标签：可自动检测动态sql是否存在由于拼接导致的一部分问题




## 注解开发

> 用注解开发更加方便，但是只适合一些简单的语句，对于稍微复杂的语句，Java注解不仅力不从心，还会让本就复杂的语句更加混乱不堪。

- @Select

```java
@Select("select * from user where id = #{id}")
User selectById(int id);
```

- @Insert
- @Update
- @Delete









# JavaWeb

> JavaWeb三大组件：Servlet、Filter、Listener

- tomcat 依赖导入

  ```xml
  <!-- 打包方式是war包，并通过maven插件中的tomcat7:run启动web项目 -->
  <plugin>
      <groupId>org.apache.tomcat.maven</groupId>
      <artifactId>tomcat7-maven-plugin</artifactId>
      <version>2.2</version>
      <configuration>
          <port>80</port>
          <path>/</path>
      </configuration>
  </plugin>
  ```

- Servlet、Filter、Listener依赖导入

  ```xml
  <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <!-- 编译、测试环境有效，运行环境无效 -->
      <!-- 项目部署在Tomcat上时，Tomcat中已有该jar包，所以运行时排除jar包，防止冲突 -->
      <scope>provided</scope> 
  </dependency>
  ```



## Tomcat

- 项目结构

  - 开发中的项目结构

    ```tree
    ├─项目包
    │  └─src
    │     ├─main
    │     │  ├─java源代码包
    │     │  ├─resources
    │     │  └─webapp
    │     │     ├─html
    │     │     ├─js
    │     │     ├─css
    │     │     └─WEB-INF
    │     │        └─web.xml
    │     └─test
    ```

  - 部署中的项目结构

    ```tree
    ├─项目包
    │  ├─html
    │  ├─js
    │  ├─css
    │  └─WEB-INF
    │     ├─classes（程序字节码文件）
    │     ├─lib
    │     └─web.xml
    ```



## Servlet

### 快速入门

- 使用Tomcat

  - 方法1：idea设置Tomcat位置

  - 方法2：maven的Tomcat内嵌插件

- 创建web项目，导入Servlet依赖坐标

- 创建：定义一个类，实现Servlet接口，重写接口中的方法。并加上`@WebServlet("uri")`指定uri路径的访问路径

  ```java
  @WebServlet("/demo")
  public class ServletDemo implements Servlet {
      @Override
      public void service(ServletRequest servletRequest, ServletResponse servletResponse) 
          throws ServletException, IOException {
          System.out.println("service方法执行了");
      }
      
      // ... ...
  }
  ```



### 生命周期

- Servlet运行在Servlet容器（web服务器）中，其生命周期由容器来管理，分为4个阶段

  1. **加载和实例化**：**默认情况下**，当Servlet第一次被访问时，由容器创建Servlet对象
  2. **初始化**：当Servlet实例化之后，容器将调用Servlet的 `init()` 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化工作。该方法只**调用一次**
  3. **请求处理**：**每次**请求Servlet时，Servlet容器都会调用Servlet的 `service()` 方法对请求进行处理
  4. **服务终止**：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的 `destory()` 方法完成资源的释放。当 `destory()` 方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java垃圾回收器所回收

- 改变创建Servlet对象的时机 `@WebServlet(urlPatterns="/demo", loadOnStartup=1)`

  - 负整数：第一次被访问时创建Servlet对象
  - 0或正整数：服务器启动时创建Servlet对象，**数字越小，优先级越高**

- Servlet 接口

  ```java
  public interface Servlet {
      void init(ServletConfig var1) throws ServletException;
  
      void service(ServletRequest var1, ServletResponse var2) 
          throws ServletException, IOException;
      
      void destroy();
  
      // 可用于返回一些信息，如作者、版本等
      String getServletInfo();
      
      // init方法被调用时，会传入ServletConfig对象
      // 将该对象作用于提升（提升为成员变量），并在init调用时赋值，即可在此方法中返回
      ServletConfig getServletConfig();
  }
  ```

- Servlet 体系结构

  - GenericServlet 抽象类实现了Servlet接口，剩下一个 `service(...)` 方法待实现

    ```java
    public abstract class GenericServlet 
        implements Servlet, ServletConfig, Serializable
    ```

    ```java
    @WebServlet("/demo")
    public class ServletDemo extends GenericServlet {
    
        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) 
            throws ServletException, IOException {
    
        }
    }
    ```

  - HttpServlet 类继承了 GenericServlet 抽象类，实现了 `service(...)` 方法。并将该方法按请求类型分配给 `doGet(...)`、`doPost(...)`、`doPut(...)`、`doDelete(...)`等方法执行，可通过重写这些方法得到相应的功能



### 其他配置

- urlPattern 配置

  - 一个Servlet，可以配置多个访问路径：`@WebServlet(urlPatterns = {"/demo01", "/demo02"})`

  - urlPattern的配置规则（若满足多个servlet路径，只会匹配一个，精确匹配的优先级高）
    - 精确匹配：`@WebServlet("/user/select")`
    - 目录匹配：`@WebServlet("/user/*")`
    - 扩展名匹配：`@WebServlet("*.abc")`（不能以 **/** 开头）
    - 任意匹配：`@WebServlet("/")`

  - 存在一个名叫 `DefaultServlet` 的默认Servlet，当其他所有Servlet都无法匹配上时，会将请求交给 `DefaultServlet`。该Servlet的作用是在静态资源中（html、png等）找同路径的资源
- XML配置方式编写Servlet

  - Servlet从3.0版本开始支持使用注解配置，3.0之前只支持xml配置文件的配置方式
  - 方法：略



### 请求与响应

- Request

  - Request继承体系

    - ServletRequest：java提供的请求接口
    - HttpServletRequest：java提供，继承自ServeltRequest，对Http协议封装的请求对象接口
    - RequestFacade：Tomcat定义的实现类

  - tomcat7 中请求中文乱码

    > tomcat7 中实现的 Request 接口
    >
    > > 在解析Post之类的请求时，会通过字符流读取参数，可通过设置字符流字符集解决
    > >
    > > 在解析Get之类的请求时，直接用ISO-8859-1字符集解码，从而导致乱码

    - Post请求乱码：`request.setCharacterEncoding("UTF-8")`

    - Get请求乱码（以请求路径：`/localhost/request-demo?firstName=张` 为例）

      - 流程：

        `张` --utf-8编码--> `1110 0101   1011 1100   1010 0000` 

        --URL编码--> `%E5%BC%A0` 

        --传输到服务器--> `%E5%BC%A0` 

        --URL解码--> `1110 0101   1011 1100   1010 0000`

        --ISO-8859-1解码--> `???`

      - 解决方法流程：

        `???` --ISO-8859-1编码-->  `1110 0101   1011 1100   1010 0000`

        --utf-8解码--> `张三`

        ```java
        String username = request.getParamter("username"); // 乱码
        
        byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);
        username = new String(bytes, StandardCharsets.UTF-8);
        ```

  - Request请求转发（多servlet共同处理请求，**同一服务器内部的跳转**）

    - 实现方式：`req.getRequestDispatcher("转发资源路径").forward(req, resp);`

    - 请求转发资源间数据共享，使用Request对象

      | 返回值 | 方法名          | 参数                  | 作用                  |
      | ------ | --------------- | --------------------- | --------------------- |
      | void   | setAttribute    | String name, Object o | 存储数据到request域中 |
      | Object | getAttribute    | String name           | 根据key，获得值       |
      | void   | removeAttribute | String name           | 根据key，删除对应键值 |

- Response

  - Response继承体系

    - ServletRequest
    - HttpServletRequest
    - ResponseFacade

  - Response请求重定向（非本servlet处理内容，重定向的正确的处理位置，**服务器内、外部均可跳转**）

    ```java
    // 设置状态码
    response.setStatus(302);
    // 重定向，设置响应头 Location
    response.setHeader("Location", "/虚拟目录（一般是项目名）/重定向资源路径");
    ```

    ```java
    // 简化重定向
    response.sendRedirect("/虚拟目录/资源路径");
    ```

  - 设置返回类型和字符集

    ```java
    // 如果返回的内容包含需要解析的html标签，需要设置解析文件类型为html
    response.setHeader("content-type", "text/html");
    // 简化
    response.setContentType("text/html;charset=utf-8");
    
    // 流不需要关闭，它会随着响应的结束，response对象的销毁而关闭
    PrintWriter writer = resp.getWriter();
    writer.write("<h1>你好，世界！</h1>");
    ```

- 什么时候需要加虚拟目录，什么时候不需要加虚拟目录？
  - 明确路径供谁使用
    - 浏览器使用：需要加虚拟目录（项目访问路径）
    - 服务端使用：不需要加虚拟目录
  - 举例：
    - `<a href="路径">`：需要加
    - `<form action="路径">`：需要加
    - `req.getRequestDispatcher("路径")`：不用加
    - `resp.sendRedirect("路径")`：需要加
  - 动态获取虚拟目录：`request.getContextPath()`





## Filter

> 过滤器一般完成一些**通用**的操作，如：权限控制、统一编码处理、敏感字符处理等

- 快速入门

  - 定义类，实现Filter接口，并重写其所有方法
  - 配置Filter拦截资源的路径：在类上定义`@WebFilter("拦截资源路径")`注解

  ```scala
  @WebFilter(Array("/*"))
  class FilterDemo01 extends Filter{
      override def init(filterConfig: FilterConfig): Unit = {}
  
      override def doFilter(servletRequest: ServletRequest, servletResponse: ServletResponse, filterChain: FilterChain): Unit = {
          val map = servletRequest.getParameterMap
          if (map.containsKey("username")) {
              // 放行
              filterChain.doFilter(servletRequest, servletResponse)
              // 此处代码在servlet执行完后执行
              System.out.println("即将返回资源");
              return
          }
          println("拦截请求")
          val response = servletResponse.asInstanceOf[HttpServletResponse]
          response.setStatus(HttpServletResponse.SC_FORBIDDEN)
          response.getWriter.println("The request has been intercepted")
      }
  
      override def destroy(): Unit = {}
  }
  ```

- 过滤器链：略





## Listener

> 用来监听Application、Session、Request这三个对象的创建、销毁和属性变化情况

- 快速入门

  ```scala
  @WebListener
  class MyListener extends ServletContextListener {
    override def contextInitialized(servletContextEvent: ServletContextEvent): Unit = ???
  
    override def contextDestroyed(servletContextEvent: ServletContextEvent): Unit = ???
  }
  ```

- 监听器接口

  | 监听器分类         | 监听器接口名                    | 监听内容                  |
  | ------------------ | ------------------------------- | ------------------------- |
  | ServletContext监听 | ServletContextListener          | 创建、销毁                |
  |                    | ServletContextAttributeListener | 属性变化                  |
  | Session监听        | HttpSessionListener             | 创建、销毁                |
  |                    | HttpSessionAttributeListener    | 属性变化                  |
  |                    | HttpSessionBindingListener      | 对象与Session的绑定、解除 |
  |                    | HttpSessionActivationListener   | Session数据的钝化和活动   |
  | Request监听        | ServletRequestListener          | 创建、销毁                |
  |                    | ServletRequestAttributeListener | 属性变化                  |









# Spring



## 核心容器

### bean实例化

- **方式一：构造方法实例化bean**

```xml
<bean id="userDao" class="cn.langh.dao.impl.UserDaoImpl"/>
```

```xml
<bean id="userService" class="cn.langh.service.impl.UserServiceImpl">
	<property name="userDao" ref="userDao"/>
</bean>
```



- **方式二：使用工厂实例化bean**

  1. 使用静态工厂实例化bean

     ```xml
     <bean id="userDao" class="cn.langh.factory.UserDaoFactory" factory-method="getUserDao"/>
     ```

  2. 使用实例工厂实例化bean

     - 方式一

     ```xml
     <bean id="userServiceFactory" class="cn.langh.factory.UserServiceFactory"/>
     <bean id="userService" factory-bean="userServiceFactory" factory-method="getUserService"/>
     ```
     
     - 方式二
     
     ```java
     public class UserDaoFactoryBean implements FactoryBean<UserDao> {
        
        @Override
        public UserDao getObject() throws Exception {
            return new UserDaoImpl();
        }
            
        @Override
        public Class<?> getObjectType() {
            return UserDao.class;
        }
        
        @Override
        public boolean isSingleton() {
            return true;
        }
     }
     ```
     
     ```xml
     <bean id="userDao3" class="cn.langh.factory.UserDaoFactoryBean"/>
     ```



### bean的生命周期

- 生命周期
  1. bean对象的创建（调用无参构造）
  2. 给bean对象设置相关属性
  3. bean后置处理器（初始化之前）
  4. bean对象初始化（调用指定初始化方法）
  5. bean后置处理器（初始化之后）
  6. bean对象创建完成，可以使用
  7. bean对象销毁（调用指定销毁方法）
  8. IOC容器关闭

- 初始化、销毁方法的设置

  - 方法一：bean 中指定 **init** 方法和 **destroy** 方法

  ```xml
  <bean id="userDao" class="cn.langh.dao.impl.UserDaoImpl" init-method="init" destroy-method="destroy"/>
  ```

  - 方法二：实现 **InitializingBean** 和 **DisposableBean** 接口,重写方法


  ```java
  @Override
  public void destroy() throws Exception {
      System.out.println("销毁方法");
  }
  
  @Override
  //配置完成后执行
  public void afterPropertiesSet() throws Exception {
      System.out.println("初始化方法");
  }
  ```

- 后置处理器

  - 创建后置处理器，实现后置处理器接口，重写里面两个默认方法

  ```java
  public class MyBeanPostProcessor implements BeanPostProcessor {
      @Override
      public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
          System.out.printf("后置处理器 %s初始化前执行\n", beanName);
          return bean;
      }
  
      @Override
      public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
          System.out.printf("后置处理器 %s初始化后执行\n", beanName);
          return bean;
      }
  }
  ```

  - 配置后置处理器的bean

  ```xml
  <bean id="..." class="cn.eli.bean.MyBeanPostProcessor"/>
  ```

  

  

### 依赖注入

- setter注入

  - 简单注入

  ```java
  @Setter
  public class UserDao implements UserDaoImpl{
      private int connectionNum;
      private String databaseName;
  }
  ```

  ```xml
  <bean id="userDao" class="cn.langh.dao.impl.UserDaoImpl">
      <property name="connectionNum" value="10"/>
      <property name="databaseName" value="mysql"/>
  </bean>
  ```

  - 引用注入

  ```java
  @Setter
  public class BookServiceImpl implements BookService{
      private UserDao userDao;
      private BookDao bookDao;
  }
  ```

  ```xml
  <bean id="userDao" class="cn.langh.dao.impl.UserDaoImpl"/>
  
  <bean id="userService" class="cn.langh.service.impl.UserServiceImpl">
      <!-- 外部bean -->
      <property name="userDao" ref="userDao"/>
      <!-- 内部bean -->
      <property name="bookDao">
          <bean id="bookDao" class="......"/>
      </property>
  </bean>
  ```

- 构造器注入

  - 简单类型

  ```java
  public class BookDaoImpl implements BookDao{
      private int connectionNum;
      private String databaseName;
      
      public BookDaoImpl(int connectionNum,String databaseName){
          this.connectionNum = connectionNum;
          this.databaseName = databaseName;
      }
  }
  ```

  ```xml
  <bean id="bookDao" class="cn.langh.dao.impl.BookDaoImpl">
      <!-- 标准注入方式 -->
      <constructor-arg name="databaseName" value="mysql"/>
      <constructor-arg name="connectionNum" value="10"/>
      
      <!-- 解耦合注入方式 -->
      <!-- 依靠参数类型注入 -->
      <constructor-arg type="int" value="10"/>
      <!-- 依靠参数位置注入 -->
      <constructor-arg index="0" value="10"/>
  </bean>
  
  
  ```
  
- 引用类型

```java
public class BookServiceImpl implements BookService {
    private BookDao bookDao;
    private UserDao userDao;

    public BookServiceImpl(BookDao bookDao,UserDao userDao){
        this.bookDao = bookDao;
        this.userDao = userDao;
    }
}
```

```xml
<bean id="bookService" class="cn.langh.service.impl.BookServiceImpl">
    <constructor-arg name="bookDao" ref="bookDao"/>
    <constructor-arg name="userDao" ref="userDao"/>
</bean>
```

- 自动装配（优先级低于setter注入 与 构造器注入）

```xml
<bean id="userService" class="cn.langh.service.impl.UserServiceImpl" autowire="byType"/>
```

```xml
<bean id="userService" class="cn.langh.service.impl.UserServiceImpl" autowire="byName"/>
```

- 集合注入（setter注入）

  - array

  ```xml
  <property name="hobbies">
      <array>
          <value>抽烟</value>
          <value>喝酒</value>
          <value>烫头</value>
      </array>
  </property>
  ```

  - List

  ```xml
  <property name="list">
      <list>
          <value>zhangsan</value>
          <value>lisi</value>
          <value>wangwu</value>
      </list>
  </property>
  ```

  - Set

  ```xml
  <property name="set">
      <set>
          <value>zhangsan</value>
          <value>lisi</value>
          <value>wangwu</value>
          <value>wangwu</value>
      </set>
  </property>
  ```

  - Map

  ```xml
  <property name="map">
      <map>
          <entry key="zhangsan" value="18"/>
          <entry key="lisi" value="19"/>
          <entry key="wangwu" value="20"/>
      </map>
  </property>
  ```

  - Properties

  ```xml
  <property name="properties">
      <props>
          <prop key="zhangsan">18</prop>
          <prop key="lisi">19</prop>
          <prop key="wangwu">20</prop>
      </props>
  </property>
  ```

- 特殊值的注入

  ```xml
  <bean id="..." class="......">
      <!-- null值的注入 -->
      <property name="..."><null/></property>
      <!-- 特殊字符的注入，如“ <> ”（xml实体） -->
      <property name="..." value="&lt;&gt;"></property>
      <!-- CDATA区 -->
      <property name="...">
          <value><![CDATA[ 特殊符号 ]]></value>
      </property>
  </bean>
  ```

- 级联赋值

  ```java
  @Setter
  @Getter // 级联赋值的getter是必要的
  public class A {
      public String name;
  }
  ```

  ```java
  @Setter
  public class B {
      public A a;
  }
  ```

  ```xml
  <bean id="a" class=".....">
      <property name="name" value="aaa"/>
  </bean>
  
  <bean id="b" class="......">
      <property name="a" ref="a"/>
      <!-- 级联赋值 -->
      <property name="a.name" value="bbb"/>
  </bean>
  ```

- [p命名空间注入](https://www.bilibili.com/video/BV1kR4y1b7Qc?p=30&vd_source=25ad2de4838bd28372a4956bac63c618)：略
- [引用集合类型的bean](https://www.bilibili.com/video/BV1kR4y1b7Qc?p=29&vd_source=25ad2de4838bd28372a4956bac63c618)：略

### 数据源对象管理

```xml
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/test"/>
    <property name="username" value="root"/>
    <property name="password" value="root"/>
</bean>
```

- 加载外部properties

  - 引入context命名空间（添加约束）

    ```xml
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd">
    ```

  - 使用context空间加载properties文件

    ```xml
    <context:property-placeholder location="jdbc.properties"/>
    
    <bean id="dataSource2" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driver}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
    ```

- 注：

  1. 命名空间默认为优先加载系统属性，可在context标签中设置 `system-properties-mode="NEVER"`

  2. context标签中 location 属性设置为 `*.properties` 表示加载所有后缀为properties的文件

  3. 加载properties的标准格式为 `location="classpath:*.properties"`

  4. 从类路径或jar包中搜索并加载properties文件格式为 `location="classpath*:*.properties"`



### 容器

- 获取容器 

  ```java
  new ClassPathXmlApplicationContext("applicationContext.xml");
  ```

  ```java
  new FileSystemXmlApplicationContext("绝对路径");
  ```

- 获取bean

  ```java
  UserDao userDao = (UserDao) app.getBean("userDao");
  UserDao userDao = app.getBean(UserDao.class);
  UserDao userDao = app.getBean("userDao",userDao.class);
  ```
  
- 注：

  - BeanFactory 是 IoC 容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载
  - ApplicationContext 接口是 spring 容器的核心接口，初始化时bean立即加载，可用 `lazy-init` 属性控制

  - ApplicationContext 接口提供的 bean 操作相关方法，通过替他接口拓展其功能

  - ApplicationContext 接口常用的初始化类
    - ClassPathXmlApplicationContext
    - FileSystemXmlApplicationContext




### 总结

```xml
<bean
	id="bookDao"
	name="dao bookDaoImpl daoImpl"
	class="cn.langh.dao.impl.bookDaoImpl"
	scope="singleton/prototype"
	init-method="init"
	destroy-method="destroy"
	autowire="byType/byName"
	factory-method="getInstance"
	factory-bean="cn.langh.factory.BookDaoFactory"
	lazy-init="true"
/>
```





## 注解开发

> Spring从2.5开始提供了对注解技术的全面支持

### 定义bean

- 定义bean

  - `@Component("名称")`（注解在类上）
    - 业务层：`@Service`
    - 数据层：`@Repository`
    - 表现层：`@Controller`

- bean的管理

  - `@Scope("singleton/prototype")`（注解在类上）

  - 生命周期（注解在方法上）
    - 初始化方法：`@PostConstruct`（构造后运行）
    - 销毁方法：`@PreDestory`（销毁前运行）

- 组件扫描

  - xml

    ```xml
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd">
        
    <context:component-scan base-package="cn.langh"/>
    ```

  - 注解
    - `@ComponentScan("cn.langh")`
    - `@ComponentScan({"cn.langh.dao","cn.langh.service})`

- 配置类
  - 注解：`@Configuration`
  - 添加外部配置：`@ImportResource("applicationContext.xml")`
  - 组件扫描：`@ComponentScan`
  - 导入其他配置类：`@Import({jdbcConfig.class,...})`（其他配置类上不用加`@Configuration`）
  - 获取容器：`new AnnotationConfigApplicationContext(SpringConfig.class)`



### 依赖注入

- 配置文件
  - 加载：
    - `@propertySource({"文件名1", "文件名2", ...})`
    - `@PropertySources({@PropertySource("文件1"), @PropertySource("文件2"), ...})`
  - 使用：`${键}`
  
- 简单类型注入
  - `@Value("值")`

- 自动装配

  - `@Autowired`（可注解在构造方法上、方法上、成员变量上、形参上、注解上）

    - **先按类型注入，若容器中含相同类型的bean，则使用属性名作为名称查找**
    - 该注解加在属性上，并不依赖于setter，而是通过反射直接对属性赋值
  
  - `@Qualifier("名称")`：依赖于@Autowired，只注入指定名称的bean
  
  - `@Resource("名称")`（可注解在属性上、setter方法上）
  
    - **先根据名称装配**，未指定名称时，使用属性名作为名称查找。通过名称无法找到bean时，会自动**启用类型装配**
  
    - 是JakartaEE的规范之一，在JDK拓展包中【仅jdk8不需要引入依赖】
  
      ```xml
      <dependency>
          <groupId>jakarta.annotation</groupId>
          <artifactId>jakarta.annotation-api</artifactId>
          <version>2.1.1</version>
      </dependency>
      ```
  





## Spring整合Mybaits

- 位置坐标

  ```xml
  <dependencies>
      <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-context</artifactId>
          <version>5.2.10.RELEASE</version>
      </dependency>
      <dependency>
          <groupId>org.mybatis</groupId>
          <artifactId>mybatis</artifactId>
          <version>3.5.10</version>
      </dependency>
      <dependency>
          <groupId>com.alibaba</groupId>
          <artifactId>druid</artifactId>
          <version>1.0.9</version>
      </dependency>
      <dependency>
          <groupId>mysql</groupId>
          <artifactId>mysql-connector-java</artifactId>
          <version>5.1.46</version>
      </dependency>
      <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-jdbc</artifactId>
          <version>5.2.10.RELEASE</version>
      </dependency>
      <!--spring整合mybatis的包，由spring提供接口，mybatis实现-->
      <dependency>
          <groupId>org.mybatis</groupId>
          <artifactId>mybatis-spring</artifactId>
          <version>1.3.1</version>
      </dependency>
  </dependencies>
  ```

- 需要加载哪些bean？[可对应查看mybatis的核心配置文件](#mybatis-config.xml)

- 配置druidbean

  - xml配置

    ```xml
    <!-- 添加约束 -->
    <context:property-placeholder location="classpath:jdbc.properties"/>
    
    <bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
    ```

  - 注解配置

    ```java
    //@PropertySource("jdbc.properties")
    @PropertySource("classpath:jdbc.properties")
    public class JdbcConfig {
    
        @Value("${jdbc.driver}")
        private String driver;
        @Value("${jdbc.url}")
        private String url;
        @Value("${jdbc.username}")
        private String username;
        @Value("${jdbc.password}")
        private String password;
    
        @Bean
        public DataSource dataSource(){
            DruidDataSource ds = new DruidDataSource();
            ds.setDriverClassName(driver);
            ds.setUrl(url);
            ds.setUsername(username);
            ds.setPassword(url);
            return ds;
        }
    }
    ```


- MybaitsConfig

  ```java
  public class MybatisConfig {
      @Bean
      SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){
          SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
          // 设置类型别名的包，用于简化SQL映射文件中resultType属性的全路径类名的书写
          ssfb.setTypeAliasesPackage("cn.langh.domain");
          ssfb.setDataSource(dataSource);
          return ssfb;
      }
  
      @Bean
      // 设置SQL映射文件包扫描的位置
      MapperScannerConfigurer mapperScannerConfigurer(){
          MapperScannerConfigurer msc = new MapperScannerConfigurer();
          msc.setBasePackage("cn.langh.dao");
          return msc;
      }
  }
  ```





## Spring整合Junit

- spring整合junit5

  - 坐标

    ```xml
    <!-- 此处以spring6为例 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <version>6.0.11</version>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>5.9.0</version>
        <scope>test</scope>
    </dependency>
    ```

  - 使用

    ```java
    import org.junit.jupiter.api.Test;
    
    // @SpringJUnitConfig(locations="classpath:配置文件.xml")
    @SpringJUnitConfig(classes = 配置类.class)
    public class SpringTestJunit4 {
        @Autowired
        private UserService userService;
    
        @Test
        public void testGetById(){
            System.out.println(userService.getById(1));
        }
    }
    ```

- spring整合junit4

  - 坐标

    ```xml
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
    ```

  - 使用

    ```java
    import org.junit.Test;
    
    @RunWith(SpringJUnit4ClassRunner.class)//设置类运行器
    @ContextConfiguration(classes = 配置类.class)//指定spring容器
    // @ContextConfiguration("classpath:配置文件.xml")
    public class SpringTestJunit4 {
        @Autowired
        private UserService userService;
    
        @Test
        public void testGetById(){
            System.out.println(userService.getById(1));
        }
    }
    ```





## AOP面向切面编程

> AOP可以通过注解和[XML](https://www.bilibili.com/video/BV1kR4y1b7Qc?p=60&vd_source=25ad2de4838bd28372a4956bac63c618)配置，本篇主要记录基于注解配置AOP的方式

### 快速入门

- 引入aop相关依赖

  ```xml
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aop</artifactId>
      <version>5.2.10.RELEASE</version>
  </dependency>
  <!--
  AspectJ：是AOP思想的一种实现。本质是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。
  Spring 只是借用了AspectJ中的注解
  -->
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aspects</artifactId>
      <version>5.2.10.RELEASE</version>
  </dependency>
  ```

- 开启自动代理

  - 配置文件

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:aop="http://www.springframework.org/schema/aop"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop.xsd">
    
    <aop:aspectj-autoproxy/>
    ```

  - 配置类：`@EnableAspectJAutoProxy`

- 创建目标资源（接口和实现类，jdk代理依赖于接口）

- 创建切面类（切入点和通知类型）

  - 定义切入点：`@Pointcut("execution(切入点表达式)")`

  - 绑定切入点与通知关系（切面）


- 举例：

  ```java
  @Configuration
  @ComponentScan
  @EnableAspectJAutoProxy
  public class SpringConfig{
      
  }
  ```

  ```java
  @Component
  @Aspect
  public class LogAspect {
      @Pointcut("execution(void cn.langh.dao.UserDao.save())")
      private void pt(){}
  
      // @After("execution(void cn.langh.dao.UserDao.save())")
      // @After("cn.eli.LogAspect.pt()") // 这样写，一个切入点表达式可用供多个方法使用
      @After("pt()") // 同一个类中可以直接写方法
      public void method(){
          System.out.println("日志...");
      }
  }
  ```

  



### 切入点表达式

- 横切关注点

  - 分散在各个模块中同样的问题，如日志记录、用户验证、事务处理、数据缓存等，都属于**横切关注点**
  - 可以使用多个横切关注点，对相关方法进行多个方面不同的增强

- 语法

  ```java
  @Pointcut("execution(权限修饰符 方法返回值类型 方法所在接口全路径.方法名(方法参数))")
  ```

  - 动作关键字：描述切入点的行为动作，例如`execution`表示执行到指定切入点


  - 访问修饰符：`public`，`private`等，可以省略
  - **必须是接口的全路径**，因为jdk动态代理依赖于接口


- 可以使用通配符描述切入点，快速描述

  - `*` ：**单个独立**的任意符号，可以独立出现，也可以作为前缀或后缀的匹配符出现（参数中填一个*表示只有一个参数）

  ```java
  execution(public * cn.langh.*.*Service.find*(*))
  ```

  - `..`  ：**多个连续**的任意符号，可以独立出现，常用于简化包名与参数的书写

  ```java
  execution(public User com..UserService.findById(..))
  ```

  - `+` ：专用于匹配子类类型

  ```java
  execution(* *..*Service+.*(..))
  ```



### 通知类型

- `@Before`：前置通知，在被代理的目标方法**前**执行

- `@After`：后置通知，在被代理的目标方法**最终结束后**执行（盖棺定论）

- `@Around`：环绕通知
  
  - 需要依赖形参
  - 方法的返回值为Object，方法执行完后要有返回值
  
  ```java
  @Around("切入点方法")
  public Object around(ProceedingJoinPoint pjp) throws Throwable{
      System.out.println("原始方法前");
      // 对原始方法进行调用
      Object o = pjp.proceed();
      // pjp.getSignature() = int cn.eli.bean.Calculator.div(int,int)
      System.out.println("原始方法后");
      return o;
  }
  ```

- `@AfterReturning`：返回通知，原始方法**成功执行完后**执行此方法
- `@AfterThrowing`：异常通知，原始方法**异常结束后**执行此方法



### 通知获取数据

- 获取参数
  - 通知方法中加形参 JoinPoint，调用 JoinPoint 中的方法Object[ ] getArgs()，获得参数
  - proceedingJoinPoint 是 JoinPoint 的实现类
  - JoinPoint 必须是形参的第一个

- 获取返回值

  - `@Around` 获取返回值

  ```java
  Object o = pjp.proceed();
  ```

  - `@AfterReturning` 获取返回值

  ```java
  // 将原始方法的返回值注入到形参ret中
  @AfterReturning(value="切入点方法", returning="ret")
  public void afterReturning(Object ret){
      方法体;
  }
  ```

- 获取异常

  - `@Around` 获取异常

  ```java
  try{
  	pjp.proceed();
  }catch(Throwable e){}
  ```

  - `@AfterThrowing` 获取异常

  ```java
  @AfterReturning(value="切入点方法", throwing="thr")//将原始方法抛出的异常注入到形参thr中
  public void afterThrowing(Throwable thr){
      方法体;
  }
  ```





## Spring事务

> 本篇主要记录基于**注解**实现**声明式**事务

### 快速入门

- 依赖

  ```xml
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>略</version>
  </dependency>
  ```

- 一般在业务层接口（Service接口）的方法上添加标注 `@Transactional`
  - `@Transactional` 可标注在类或接口上，表示该类或接口中所有方法都添加事务

- 配置DataSource（以xml为例）

  ```xml
  <context:property-placeholder location="classpath:jdbc.properties"/>
  
  <bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
      <property name="url" value="${jdbc.url}"/>
      <property name="driverClassName" value="${jdbc.driverClassName}"/>
      <property name="username" value="${jdbc.username}"/>
      <property name="password" value="${jdbc.password}"/>
  </bean>
  ```

- 配置JdbcTemplate（以注解为例）

  ```java
  @Bean
  public JdbcTemplate jdbcTemplate(DataSource datasource){
      JdbcTemplate jdbcTemplate = new JdbcTemplate();
      jdbcTemplate.setDataSource(dataSource);
      return jdbcTemplate;
  }
  ```

- 添加事务管理器

  - XML配置事务管理器

    ```xml
    <!-- 添加 tx 约束 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="druidDataSource"/>
    </bean>
    ```

  - 注解配置事务管理器

    ```java
    @Bean
    public DataSourceTransactionManager transactionManager(DataSource dataSource){
        DataSourceTransactionManager transactionManager = 
            new DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
    }
    ```

- 开启事务管理器

  - 方法一：SpringConfig 上添加标注 `@EnableTransactionManagement`

  - 方法二：xml配置

    ```xml
    <tx:annotation-driven transaction-manager="transactionManager"/>
    ```




### 事务传播行为

- 事务角色

  - 事务管理者：发起事务方，在Spring中通常指代业务层开启事务的方法
  - 事务协调者：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法

  ```java
  // 事务管理者
  @Transactional
  public void 转账(变动金额数, 转账方, 收账方) {
      扣钱(变动金额数, 转账方);
      加钱(变动金额数, 收账方);
  }
  
  // 事务协调者
  @Transactional(态度)
  public void 扣钱(变动金额数, 变动金额方) {
      调用SQL语句扣除指定对象指定金额;
  }
  
  // 事务协调者
  @Transactional(态度)
  public void 加钱(变动金额数, 变动金额方) {
      调用SQL语句增加指定对象指定金额;
  }
  ```

- 事务传播行为

  - **事务协调员对管理员的态度**：是加入管理员的事务，还是新开个事务，...？
  - 通过 `@Transactional` 中的 `propagation` 属性设置（`Propagation.属性`）

  <table>
      <tr>
          <th><font color="red">协调者</font>的传播属性</th>
          <th>管理者<font color="red">状态</font></th>
          <th>协调者<font color="red">态度</font></th>
      </tr>
      <tr>
          <td rowspan="2">REQUIRED(默认)</td>
          <td>已开启事务</td>
          <td>加入该事务</td>
      </tr>
      <tr>
          <td>无</td>
          <td>新建事务</td>
      </tr>
      <tr>
          <td rowspan="2">REQUIRES_NEW</td>
          <td>已开启事务</td>
          <td>新建事务</td>
      </tr>
      <tr>
          <td>无</td>
          <td>新建事务</td>
      </tr>
      <tr>
          <td rowspan="2">SUPPORTS</td>
          <td>已开启事务</td>
          <td>加入该事务</td>
      </tr>
      <tr>
          <td>无</td>
          <td>无</td>
      </tr>
      <tr>
          <td rowspan="2">NOT_SUPPORTED</td>
          <td>已开启事务</td>
          <td>无</td>
      </tr>
      <tr>
          <td>无</td>
          <td>无</td>
      </tr>
      <tr>
          <td rowspan="2">MANDATORY</td>
          <td>已开启事务</td>
          <td>加入该事务</td>
      </tr>
      <tr>
          <td>无</td>
          <td>error</td>
      </tr>
      <tr>
          <td rowspan="2">NEVER</td>
          <td>已开启事务</td>
          <td>error</td>
      </tr>
      <tr>
          <td>无</td>
          <td>无</td>
      </tr>
      <tr>
          <td>NESTED</td>
          <td colspan="2">设置savePoint，一旦事务回滚，事务将回滚到savePoint处，交由客户响应提交/回滚</td>
      </tr>
  </table>



### 事务隔离级别

- 各种隔离级别解决并发问题的能力

  | 隔离级别         | 脏读 | 不可重复读 | 幻读 |
  | ---------------- | ---- | ---------- | ---- |
  | READ UNCOMMITTED | ×    | ×          | ×    |
  | READ COMMITTED   | √    | ×          | ×    |
  | REPEATABLE READ  | √    | √          | ×    |
  | SERIALIZABLE     | √    | √          | √    |

- 各种数据库对事务隔离级别的支持程度

  | 隔离级别         | Oracle  | MySQL   |
  | ---------------- | ------- | ------- |
  | READ UNCOMMITTED | ×       | √       |
  | READ COMMITTED   | √(默认) | √       |
  | REPEATABLE READ  | ×       | √(默认) |
  | SERIALIZABLE     | √       | √       |

- 设置隔离级别`@Transactional(isolation = Isolation.隔离级别)`
  - `DEFAULT`：使用数据库各自的默认隔离级别
  - `READ_UNCOMMITTED`：读未提交
  - `READ COMMITTED`：读已提交
  - `REPEATABLE READ`：可重复读
  - `SERIALIZABLE`：串行化



### Spring事务的其他配置

- 一些属性
  - `readOnly`：默认false，true表示只能做查询操作
  - `timeout`：设置一个事务的超时时间，在该时间内未完成，抛出异常并回滚。默认-1表示永不超时
  - `rollbackFor`：设置哪些异常回滚（默认Error和RuntimeException回滚）
  - `noRollbackFor`：设置哪些异常不回滚（默认Error和RuntimeException回滚）
  - `propagation`：事务传播行为
  - `isolation`：事务隔离级别

- `@Transactional`注解中的源码

  ```java
  public @interface Transactional {
      @AliasFor("transactionManager")
      String value() default "";
  
      @AliasFor("value")
      String transactionManager() default "";
  
      String[] label() default {};
  
      Propagation propagation() default Propagation.REQUIRED;
  
      Isolation isolation() default Isolation.DEFAULT;
  
      int timeout() default -1;
  
      String timeoutString() default "";
  
      boolean readOnly() default false;
  
      Class<? extends Throwable>[] rollbackFor() default {};
  
      String[] rollbackForClassName() default {};
  
      Class<? extends Throwable>[] noRollbackFor() default {};
  
      String[] noRollbackForClassName() default {};
  }
  ```

  









# SpringMVC



## 入门案例

### maven坐标

```xml
<dependencies>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
</dependencies>

<!--插件-->
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.tomcat.maven</groupId>
            <artifactId>tomcat7-maven-plugin</artifactId>
            <version>2.2</version>
            <configuration>
                <port>80</port>
                <path>/</path>
            </configuration>
        </plugin>
    </plugins>
</build>
```



### Config

- 创建spring的配置文件

```java
@Configuration
@ComponentScan("cn.langh.controller")
public class SpringmvcConfig {
}
```

- 初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求

  ```java
  public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer{
      //用来加载SpringMVC容器配置
      protected WebApplicationContext createServletApplicationContext(){
          AnnotationConfigWebApplication ctx = new AnnotationConfigWebApplicationContext();
          ctx.register(SpringmvcConfig.class);
          return ctx;
      }
      
      //设置哪些请求归属springMVC处理
      protected String[] getServletMappings(){
          return new String[]{"/"};
      }
      
      //加载spring容器配置
      protected WebApplicationContext createRootApplicationContext(){
          return null;
      }
  }
  ```

  ```java
  public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
      @Override
      protected Class<?>[] getRootConfigClasses() {
          return new Class[]{SpringConfig.class};
      }
  
      @Override
      protected Class<?>[] getServletConfigClasses() {
          return new Class[]{SpringmvcConfig.class};
      }
  
      @Override
      protected String[] getServletMappings() {
          return new String[]{"/"};
      }
  }
  ```

  



### Controller

- 使用 @Controller 定义Bean
- @RequestMapping 设置当前操作的访问路径
- @ResponseBody 设置当前操作的返回值类型

```java
@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("user save...");
        return "{'module':'springmvc'}";
    }
}
```



### 入门案例的工作流程

- 启动服务器初始化过程
  - 服务器启动，执行ServletContainersInitConfig类，初始化web容器
  - 执行createServletApplicationContext方法，创建WebApplicationContext对象
  - 加载SpringmvcConfig
  - 执行@ComponentScan加载对应的bean
  - 加载UserController，每个@RequestMapping的名称对应一个具体的方法
  - 执行getServletMappings方法，定义所有的请求都通过SpringMVC
- 单次请求过程
  - 发送请求localhost/save
  - web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理
  - 解析请求路径/save
  - 执行save()
  - 检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求放





## 参数接收

### 普通参数接收

- 通过设置形参来接收相同名称的请求参数

- 可通过在形参前加上@RequestParam("请求参数")来匹配形参和请求参数

```java
@RequestMapping("/getParam1")
@ResponseBody
public String getParam1(@RequestParam("name") String username,Integer age){
    System.out.println(username);
    return username;
}
```



### 实体类接收

- 请求参数与实体类属性名相同则可以直接接收
- 如果实体类中包含引用属性，则在传递该属性参数时应，请求参数应遵循格式：引用类名.引用类属性

```java
@RequestMapping("/getParam2")
@ResponseBody
public String getParam2(User user){
    System.out.println(user);
    return user.toString();
}
```

```java
public class User{
	private String name;
	private Integer age;
	private Address address;
}
```

```java
public class Address{
    private String province;
    private String city;
}
```

- json:

| Key              | VALUE    |
| ---------------- | -------- |
| name             | zhangsan |
| age              | 20       |
| address.province | Anhui    |
| address.city     | Hefei    |



### 数组与集合接收

- 名称相同，可以用数组直接接收
- 名称相同，且需要加@RequestParam，才能用集合接收



### json数据的接收

- 位置坐标

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.0</version>
</dependency>
```

- springmvcConfig上加注解@EnableWebMvc

- 形参前添加@RequestBody来接收参数


注：json格式

```json
//List<User> users
//[User{name='zhangsan', age=15, address=Address{province='beijing', city='beijing'}}, User{name='lisi', age=15, address=Address{province='beijing', city='beijing'}}]
[
    {
        "name":"zhangsan",
        "age":15,
        "address":{
        	"province":"beijing",
    	    "city":"beijing"
        }
    },
    {
        "name":"lisi",
        "age":15,
        "address":{
        	"province":"beijing",
    	    "city":"beijing"
        }
    }
]
```



### 中文乱码问题

在ServletContainersInitConfig中覆盖重写getServletFilters()

```java
@Override
protected Filter[] getServletFilters(){
    CharacterEncodingFilter filter = new CharacterEncodingFilter();
    filter.setEncoding("utf-8");
    return new Filter[]{filter};
}
```



### 日期时间型接收

```java
@RequestMapping("/date2")
@ResponseBody
public String date2(@DateTimeFormat(pattern = "yyyy-MM-dd") Date date){
    System.out.println(date);
    return date.toString();
}
```



### 文件接收

- 前端

  - 表单提交

    ```html
    <form action="http://localhost/file/upload" method="post" enctype="multipart/form-data">
        <input id="file" name="oneFile" type="file"/><br/>
        <input id="btn" value="submit" type="submit"/>
    </form>
    ```

  - ajax + FormData

    ```html
    <script>
    let btn = document.querySelector("#btn")
    btn.addEventListener("click", function(){
        // 1. 检验是否选择了文件
        let files = document.querySelector("#file").files
        if(files.length <= 0){
            return alert("请选择要上传的文件")
        }
    
        // 2. 向FormData中追加文件
        let fd = new FormData()
        fd.append("oneFile", files[0])
    
        // 3. 发送ajax请求
        const xhr = new XMLHtttpRequest();
        xhr.open("POST","http://www.test.com");
        xhr.send(fd)
        
        // 细节：用formdata提交文件时不需要设置请求头
    })
    </script>
    ```

- 后端

  - 接收

    ```java
    @PostMapping("/upload")
    public String upload(@RequestParam("oneFile") MultipartFile file) {
        if (file == null) return "null";
        return "success";
    }
    ```

  - 大小设置

    - 修改 yml 文件

      ```yaml
      spring:
        servlet:
          multipart:
            max-file-size: 100MB
            max-request-size: 300MB
      ```

    - 添加文件配置类

      ```java
      @Configuration
      public class FileConfig {
          @Bean
          public MultipartConfigElement multipartConfigElement() {
              MultipartConfigFactory factory = new MultipartConfigFactory();
              //允许上传的文件最大值
              factory.setMaxFileSize(DataSize.parse("50MB")); //KB,MB
              /// 设置总上传数据总大小
              factory.setMaxRequestSize(DataSize.parse("50MB"));
              return factory.createMultipartConfig();
          }
      }
      ```






## 会话技术

### Cookie

- 客户端会话技术，将数据保存到客户端

- 使用步骤

  ```java
  // 发送Cookie
  Cookie cookie = new Cookie(String name, String value);
  response.addCookie(cookie);
  ```

  ```java
  // 获取Cookie
  Cookie[] cookies = request.getCookies();
  ```

- 补充

  - cookie的保存时间

    - 默认情况下，cookie数据存在浏览器的内存中，浏览器关闭后，数据销毁
    - 持久化存储
      - setMaxAge(int seconds)
        - 正数：Cookie数据写到硬盘的文件中，持久化存储。cookie的存活时间
        - 负数：默认值
        - 零：删除cookie信息

  - cookie存储中文

    - 在tomcat 8之前 cookie不能直接存储中文数据，需要转码，一般用URL编码

    - 在tomcat 8及之后，cookie可以直接存储中文，但仍不支持特殊字符

      ```java
      // 对应的类在java.net包下
      // url编码
      URLEncoder.encode(String str, String charset);
      // url解码
      URLDecoder.decode(String str, String charset);
      ```

  - cookie的获取范围

    - 在一个服务器中，部署了多个web项目，cookie信息默认不能共享
    - setPath(String path)：设置cookie的获取范围，默认情况下，为当前web项目目录，将path设置为“/”，当前域名（ip）下的所有项目



### Session

- 服务器端会话技术，将数据保存到服务器中

- 原理

  - 调用request.getSession()后，服务器会检查请求中有没有 JSESSIONID 的cookie
  - 若没有，则创建Session对象，并为其定义一个id，再在cookie中存储这个id，并发送
  - 若有，则通过 JSESSIONID 这个id找到服务器中的Session对象
  - 因此，在一次会话范围内，Session对象是同一个

- 使用步骤

  - HttpSession session = request.getSession();
  - session.getAttribute(string name, Object value)
  - session.removeAttribute(String name)

- session什么时候被销毁

  - 服务器关闭
  - session对象调用invalidate()
  - session默认失效时间为30分钟

  

  



## REST风格

### 简介

- REST（Repretational State Transfer），表现形式状态转换
  - 传统风格资源描述形式
    - http://localhost/user/getById?id=1
    - http://localhost/user/saveUser
  - REST风格描述形式
    - http://localhost/user/1
    - http://localhost/user
- 优点
  - 隐藏资源的访问行为，无法通过地址得知对资源的何种操作
  - 书写简化
- 按照REST风格访问资源时使用行为动作区分对资源进行了何种操作

| http://localhost/users   | 查询全部用户信息 | GET（查询）       |
| ------------------------ | ---------------- | ----------------- |
| http://localhost/users/1 | 查询指定用户信息 | GET（查询）       |
| http://localhost/users   | 添加用户信息     | POST（新增/保存） |
| http://localhost/users   | 修改用户信息     | PUT（修改/更新）  |
| http://localhost/users/1 | 删除用户信息     | DELETE（删除）    |



### 快速入门

```java
@Controller
@RequestMapping("/rest")
public class TestController {

    @RequestMapping(value = "/users",method = RequestMethod.POST)
    @ResponseBody
    public String save(){
        System.out.println("user save...");
        return "user save";
    }

    //路径上的{id}表示占位，与形参名称一致
    //形参前的 @PathVariable 表示从路径中获取变量
    @RequestMapping(value = "/users/{id}",method = RequestMethod.PUT)
    @ResponseBody
    public String delete(@PathVariable Integer id){
        System.out.println("user NO."+id+" delete ...");
        return "user NO."+id+" delete ...";
    }
    
    // ......
}
```



### 快速开发

```java
//@Controller
//@ResponseBody
@RestController
@RequestMapping("/rest")
public class TestController {

    //@RequestMapping(value = "/users",method = RequestMethod.POST)
    @PostMapping
    public String save(){
        System.out.println("user save...");
        return "user save";
    }

    //@RequestMapping(value = "/users/{id}",method = RequestMethod.DELETE)
    @DelMapping("/{id}")
    public String delete(@PathVariable Integer id){
        System.out.println("user NO."+id+" delete ...");
        return "user NO."+id+" delete ...";
    }
    
    // ......
}
```





## 响应

- 基础

  - 响应页面
    - 方法返回值设定位要跳转的页面


  - 响应json
    - 方法返回值设置为pojo类型，并返回pojo对象


- 响应的完善

  - 构造响应结果Result，统一响应内容

  ```java
  public class Result{
      private Object data;
      private Code code;
      private String msg;
  }
  ```

  ```java
  public class Code {
      public static final Integer SAVE_OK = 20011;
      public static final Integer DELETE_OK = 20021;
      public static final Integer UPDATE_OK = 20031;
      public static final Integer GET_OK = 20041;
  
      public static final Integer SAVE_ERR = 20010;
      public static final Integer DELETE_ERR = 20020;
      public static final Integer UPDATE_ERR = 20030;
      public static final Integer GET_ERR = 20040;
  }
  ```

  ```java
  @GetMapping("/{id}")
  public Result getUserById(@PathVariable int id){
      User user = userService.findUserById(id);
      Integer code = user==null ? Code.GET_ERR : Code.GET_OK;
      String msg = user==null ? "数据查询失败，请重试":"";
      return new Result(code,user,msg);
  }
  ```

  



## 异常处理器

### 异常的处理方案

- 异常的分类
  - 业务异常（BusinessException）
    - 规范的用户行为产生的异常
    - 不规范的用户行为产生的异常
  - 系统异常（SystemException）
    - 项目运行过程中可预计且无法避免的异常
  - 其他异常
    - 编程人员未预期到的异常
- 异常处理方案
  - 业务异常
    - 发送对应的消息传递给用户，提醒规范操作
  - 系统异常
    - 发送固定消息传递给用户，安抚用户
    - 发送特定消息给运维人员，提醒维护
    - 记录日志
  - 其他异常
    - 发送固定消息传递给用户，安抚用户
    - 发送特定消息给编程人员，提醒维护（纳入预期范围内）
    - 记录日志



### 异常处理器的定义

- 出现异常后，将异常全部抛到表现层进行处理

  - 表现层中定义异常（如：BusinessException、SystemException等）

    ```java
    public class SystemException extends RuntimeException{
        Integer code; // 自定义异常类型对应的code
        
        public SystemException(Integer code, String msg){
            super(msg);
            this.code = code;
        }
        
        public System.Exception(Integer code, String msg, Throwable cause){
            super(msg, cause);
            this.code = code;
        }
        
        public Integer getCode(){return code;}
    }
    ```

  - 业务层的异常抛出

    ```java
    public User getById(int id){
        try{
            int i = 1/0; // 模拟异常
        }catch(Exception e){
            throw new SystemException(Code.SYSTEM_TIMEOUT_ERR, "出异常啦");
        }
    }
    ```

    

- 在表现层定义异常处理器，异常处理器会自动拦截异常

```java
// 定义异常处理器
// @ControllerAdvice
@RestControllerAdvice
public class ProjectExceptionAdvice {
    // 定义拦截哪一种异常
    @ExceptionHandler(Exception.class)
    // 形参是异常对象
    public Result doException(Exception e){
        System.out.println(e.getMessage());
        return new Result(500,null,"出异常了");
    }
}
```







## 拦截器

### 快速入门

- 拦截器的定义

```java
@Component
public class ProjectInterceptor implements HandlerInterceptor {
    // 此方法会在进入controller之前执行，返回Boolean值决定是否执行后续操作。
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle...");
        // 是否放行
        return true;
    }

    // 在controller执行之后执行，但是视图还没有解析，可向ModelAndView中添加数据(前后端不分离的)。
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle...");
    }
    
	// 该方法会在整个请求结束（请求结束，但是并未返回结果给客户端）之后执行， 可获取响应数据及异常信息。
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion...");
    }
}
```

- 拦截器的加载

```java
@Configuration
public class SpringmvcSupport extends WebMvcConfigurationSupport {
    // 过滤访问的静态资源
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 访问 /page/** 时让他定位到 /page/ 目录
        registry.addResourceHandler("/page/**").addResourceLocations("/page/");
    }

    @Autowired
    private ProjectInterceptor projectInterceptor;

    // 添加拦截的url
    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(projectInterceptor).addPathPatterns("/user","/user/*");
    }
}
```

- SpringmvcSupport 也要在SpringmvcConfig中扫描到

-  简化配置

```java
@Configuration
@ComponentScan("cn.langh.controller")
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer{
    @Autowired
    private ProjectInterceptor projectInterceptor;
    
    @Override
    public void addInterceptors (InterceptorRegistry registry){
       registry.addInterceptor(projectInterceptor).addPathPatterns("/user","/user/*");
    }
}
```



### 拦截器参数

- Request
  - 原始request
  - request.getHeader(String name);

- Response
  - 原始response

- handler
  - 封装了 controller 中对应的方法
  - 可将 handler（Object）强转为HandMethod，便可调用反射中的方法

- ModeAndView
  - 封装了页面跳转的相关信息

- Exception
  - 原始程序执行过程中的异常




### 拦截器链

- 配置

```java
@Configuration
public class SpringmvcSupport extends WebMvcConfigurationSupport {
    
    @Autowired
    private ProjectInterceptor projectInterceptor;
    @Autowired
    private ProjectInterceptor2 projectInterceptor2;

    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
      registry.addInterceptor(projectInterceptor).addPathPatterns("/user","/user/*");
      registry.addInterceptor(projectInterceptor2).addPathPatterns("/user","/user/*");
    }
}
```

- 执行顺序

```
preHandle...
preHandle222...
[INFO] {dataSource-1} inited
postHandle222...
postHandle...
afterCompletion222...
afterCompletion...
```









# Maven拓展



## 分模块开发

- 独立模块

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.langh</groupId>
    <artifactId>模块1XXX</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging>
</project>
```

- 原始模块

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.langh</groupId>
    <artifactId>模块2XXX</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>war</packaging>

    <dependencies>
        <dependency>
            <groupId>cn.langh</groupId>
            <artifactId>模块1XXX</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>
</project>
```

- 将独立模块打包进仓库
  - 使用独立模块的生命周期中的install命令



## 依赖传递

- 依赖具有传递性
  - 直接依赖
  - 间接依赖
- 依赖冲突所执行的顺序
  - 路径优先：当依赖中出现相同的资源时，层级越深，优先级越低
  - 声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的
  - 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的

- 可选依赖：隐藏当前工程所依赖的资源，隐藏后，对应资源将不具备依赖的传递性

```xml
<dependency>
    <groupId>XXX</groupId>
    <artifactId>XXX</artifactId>
    <version>XXX</version>
    <optional>true</optional>
</dependency>
```

- 排除依赖：隐藏当前依赖所对应的部分依赖关系

```xml
<dependency>
    <groupId>XXX</groupId>
    <artifactId>XXX</artifactId>
    <version>XXX</version>
    <exclusions>
        <exclusion>
            <groupId>地址</groupId>
            <artifactId>需要排除的项目</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```



## 聚合

- 聚合：将多个模块组成一个整体，同时进行项目构建的过程

- 聚合工程：通常是一个不具有业务功能的“空”工程（有且仅有一个pom文件）

- 作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对包含的模块进行同步构建

  - 当工程中某个模块发生更新（变更）时，必须保证工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。

- 步骤

  - 创建新的模块，并设置打包方式为pom
  - 设置管理的模块名称

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
  
      <groupId>cn.langh</groupId>
      <artifactId>springmvc_10_interceptor</artifactId>
      <version>1.0-SNAPSHOT</version>
      <packaging>pom</packaging>
  
      <modules>
          <module>../模块1</module>
          <module>../模块2</module>
      </modules>
  </project>
  ```

  

## 继承

- 创建新的模块，并设置打包方式为pom

- 配置工程的parent

```xml
<parent>
    <grouId></grouId>
    <argifactId></argifactId>
    <version></version>
    <relativePath>相对路径：定位到pom.xml文件，使用它可准确定位父类的位置</relativePath>
</parent>
```

- 依赖的继承

  - 定义在父工程的坐标，在子工程中自动继承

- 依赖管理

  - 在父工程中定义依赖管理，子工程添加依赖坐标时，不用加版本，自动与管理中的依赖版本一致

  ```xml
  <dependencyManagement>
      <dependencies>
          <dependency>
              <groupId>cn.langh</groupId>
              <artifactId>模块XXX</artifactId>
              <version>指定版本</version>
          </dependency>
      </dependencies>
  </dependencyManagement>
  ```

  

## 属性

- 定义与使用

```xml
<properties>
    <spring.version>5.2.10.RELEASE</spring.version>
    <junit.version>4.12</junit.version>
</properties>
```

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>${spring.version}</version>
</dependency>
```

- 配置文件加载maven的属性

  - 扩大maven的作用范围到配置文件

  ```xml
  <build>
      <resources>
          <resource>
              <!--指定加载属性的配置文件的位置-->
              <!--<directory>../maven_01/src/main/resources</directory>-->
              <directory>${project.basedir}/src/main/resources</directory>
              <!--表示识别配置文件中的${}符号-->
              <filtering>true</filtering>
          </resource>
      </resources>
  </build>
  ```

  - directory可设置为 \<directory>${project.basedir}/src/main/resources\</directory>
    - ${project.basedir}maven内置系统属性，表示当前项目
    - 如果该配置设置在父类，子类配置继承该设置，子类不用再设置

- maven在打war包时，默认必须存在web.xml文件，但注解开发时，不需要该文件。可以创建该文件，也可以添加插件设置打包方式


```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <version>3.2.3</version>
            <configuration>
                <!--表示未找到web.xml时不声明-->
                <failOnMissingWebXml>false</failOnMissingWebXml>
            </configuration>
        </plugin>
    </plugins>
</build>
```



## 多环境开发

- 配置多环境

```xml
<profiles>
    <profile>
        <id>env_dep</id>
        <properties>
            <jdbc.url>jdbc:mysql://127.0.0.1:3306/ssm（开发环境地址）</jdbc.url>
        </properties>
        <activation>
            <activeByDefault>true（是否为默认环境）</activeByDefault>
        </activation>
    </profile>
    <profile>
        <id>env_pro</id>
        <properties>
            <jdbc.url>生产环境地址</jdbc.url>
        </properties>
    </profile>
    <profile>
        <id>env_test</id>
        <properties>
            <jdbc.url>测试环境地址</jdbc.url>
        </properties>
    </profile>
</profiles>
```



## 跳过测试

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.12.4</version>
            <configuration>
                <!--全部跳过-->
                <skipTests>true</skipTests>
                <!--挑过部分-->
                <skipTests>false</skipTests>
                <exclude>类名（如 **/UserServiceTest.java）</exclude>
            </configuration>
        </plugin>
    </plugins>
</build>
```



## 私服

- 私服的下载与安装
- maven文件配置私服
- 工程pom配置私服

```xml
<distributionManagement>
    <repository>
        <id></id>
        <url></url>
    </repository>
    <snapshotRepository>
        <id></id>
        <url></url>
    </snapshotRepository>
</distributionManagement>
```



## 常用插件

- scala 编译打包插件

  ```xml
  <!-- This plugin compiles Scala files，需要 scala-library 依赖 -->
  <plugin>
      <groupId>net.alchim31.maven</groupId>
      <artifactId>scala-maven-plugin</artifactId>
      <version>3.2.2</version>
      <executions>
          <execution>
              <id>scala-compile-first</id>
              <phase>process-resources</phase>
              <goals>
                  <goal>add-source</goal>
                  <goal>compile</goal>
              </goals>
          </execution>
          <execution>
              <id>scala-test-compile</id>
              <phase>process-test-resources</phase>
              <goals>
                  <goal>testCompile</goal>
              </goals>
          </execution>
      </executions>
  </plugin>
  ```

  - scala 依赖

    ```xml
    <!-- scala依赖 -->
    <dependency>
        <groupId>org.scala-lang</groupId>
        <artifactId>scala-library</artifactId>
        <version>2.13.10</version>
    </dependency>
    ```

- jdk版本插件

  ```xml
  <!-- 设置jdk版本 -->
  <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.10.1</version>
      <configuration>
          <source>17</source>
          <target>11</target>
      </configuration>
  </plugin>
  ```

- springboot依赖打包插件

  ```xml
  <!-- springboot项目的常用插件，在项目打包时，把需要的各种依赖包都打到jar包中 -->
  <plugin>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-maven-plugin</artifactId>
      <configuration>
          <excludes>
              <exclude>
                  <groupId>org.projectlombok</groupId>
                  <artifactId>lombok</artifactId>
              </exclude>
          </excludes>
      </configuration>
  </plugin>
  ```

- tomcat内嵌插件

  ```xml
  <!-- 将tomcat服务器嵌入项目中 -->
  <!-- 打包方式是war包，并通过maven插件中的tomcat7:run启动web项目 -->
  <plugin>
      <groupId>org.apache.tomcat.maven</groupId>
      <artifactId>tomcat7-maven-plugin</artifactId>
      <version>2.2</version>
      <configuration>
          <port>80</port>
          <path>/</path>
      </configuration>
  </plugin>
  ```
  
  









# MyBatisPlus

https://baomidou.com/

## 快速入门

- 坐标

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>

<!--MybatisPlus的起步坐标-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.1</version>
</dependency>
```

- dao接口继承BaseMapper<?>,泛型为domian实体类
- service接口继承IService<?>
- domain类上用@TableName("表名")来标识实体类对应的表





## 标准数据层开发

### 主要功能

| 主要功能   | 自定义接口                             | MybatisPlus接口                                |
| ---------- | -------------------------------------- | ---------------------------------------------- |
| 新增       | boolean save(T t)                      | int insert(T t)                                |
| 删除       | boolean delete(int id)                 | int deleteById(Serializable id)                |
| 修改       | boolean update(T t)                    | int updateById(T t)                            |
| 根据id查询 | T getById(int id)                      | T selectById(Serilizable id)                   |
| 查询全部   | List\<T> getAll()                      | List\<T> selectList()                          |
| 分页查询   | PageInfo\<T> getAll(int page,int size) | IPage\<T> selectPage(IPage\<T> page)           |
| 按条件查询 | List\<T> getAll(Condition condition)   | IPage\<T> selectPage(Wrapper\<T> queryWrapper) |

```java
@Test
void testUpdate(){
    User user = new User();
    user.setId(1L);
    user.setPassword(333);
    userdao.updateById(user);
}
```



### lombok

- 一个java类库，提供了一组注解，简化POJO实体类开发

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <scope>provided</scope>
</dependency>
```

- @Setter

- @Getter

- @ToString

- @NoArgsConstructor：无参构造

- @AllArgsConstructor：全参构造

- @EqualsAndHashCode

- @Data：

  

### 分页查询

```java
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor(){
    //1.定义MybatisPlus的拦截器
    MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
    //2.添加分页的拦截器
    mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
    return mybatisPlusInterceptor;
}
```

```java
@Test
void testGetByPage(){
    //current 表示所查的页码，size 表示每页的条数
	IPage page = new Page(int current,int size);
    userdao.selectPage(page,null);
    System.out.println("当前页码值："+page.getCurrent());
    System.out.println("每页条数值："+page.getSize());
    System.out.println("总共的页数："+page.getPages());
    System.out.println("总共的条数："+page.getTotal());
    System.out.println("数据："+page.getRecords());
}
```





## 条件查询

### 快速入门

```java
@Test
public void testQueryWrapper(){
    //方式一：按条件查询
    QueryWrapper queryWrapper1 = new QueryWrapper();
    queryWrapper1.lt("money",12000);

    //方式二：lambda格式按条件查询
    QueryWrapper<User> queryWrapper2 = new QueryWrapper<>();
    queryWrapper2.lambda().lt(User::getMoney,12000);

    //方式三：lambda格式按条件查询
    LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper();
    lqw.lt(User::getMoney,12000);
    
    List list = userDao.selectList(lqw);
    for (Object o : list) {
        System.out.println(o);
    }
}
```

- 常用条件
  - eq：等于
  - lt：小于
  - le：小于等于
  - gt：大于
  - ge：大于等于
  - between：介于
  - 并且关系：`lqw.lt(User::getMoney,20000).gt(User::getMoney,12000);`
  - 或者关系：`lqw.lt(User::getMoney,12000).or().gt(User::getMoney,20000);`

- null值判定
  - `lqw.lt(null != user.getMoney(),User::getMoney,user.getMoney());`



### 查询投影

- 查询指定列的数据

```java
//lambda
@Test
public void testSelect(){
    LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper();
    lqw.select(User::getUsername,User::getMoney);
    List<User> users = userDao.selectList(lqw);
}

//普通格式
@Test
public void testSelect(){
    QueryWrapper qw = new QueryWrapper();
    lqw.select("username","money");
    List<User> users = userDao.selectList(lqw);
}
```

- 查询总条数

```java
@Test
public void testSelectCount(){
    QueryWrapper qw = new QueryWrapper();
    qw.select("count(*) as count");
    List<Map<String,Object>> list = userDao.selectMaps(qw);
    System.out.println(list);
}
```

- 分组统计

```java
@Test
public void testSelectCount(){
    QueryWrapper qw = new QueryWrapper();
    //1. 将 总数 和 性别 字段查出来
    qw.select("count(*) as count , gender");
    //2. 按性别分组
    qw.groupBy("gender");
    List<Map<String,Object>> list = userDao.selectMaps(qw);
    System.out.println(list);
}
```



### 其他查询

- 等匹配

```java
@Test
public void testEqual(){
    LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper();
    lqw.eq(User::getUsername,"张三").eq(User::getPassword,"123");
    User user = userDao.selectOne(lqw);
    System.out.println(user);
}
```

- 近似查询

  - lqw.like(User::getName,"J")

  - lqw.likeLeft(User::getName,"J") 相当于 %J

  - lqw.likeRight(User::getName,"J") 相当于 J%

- 其他
  - https://baomidou.com/





## 注解

https://baomidou.com/pages/223848/

- @TableName：实体类上，标识实体类对应的表
  - 属性
    - value：String，实体类对应的表
- @TableField：非主键
  - 属性
    - value：String，数据库字段名
    - exist：boolean，是否为数据库表字段，默认为true
    - select：boolean，是否进行select查询，默认为true
- @TableId：主键注解
  - 属性
    - value：String，主键字段名
    - type：Enum，指定主键类型（IdType.枚举)
      - AUTO：数据库ID自增
      - NONE：无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）
      - INPUT：insert 前自行 set 主键值
      - ASSIGN_ID：雪花算法
      - ASSIGN_UUID：以UUID生成算法作为id生成策略
- @TableLogic：逻辑删除
  - 属性
    - value：String，逻辑未删除值
    - delval：String，逻辑删除值
- @Version





## 全局配置

```yaml
mybatis-plus:
 global-config:
  db-config:
   # 配置全局id设置类型
   id-type: auto
   # 配置全局表前缀
   table-prefix: tb_
   # 表中的哪个字段需要作为通用的逻辑删除字段
   logic-delete-field: deleted
   # 逻辑未删除值
   logic-not-delete-value: 0
   # 逻辑删除值
   logic-delete-value: 1
```





## 乐观锁

### 定义

- 乐观锁：在操作数据时十分乐观，认为别的线程不会同时修改数据，所以不会上锁，但是在更新数据时会判断在此期间别的线程是否更新过这个数据
- 悲观锁：在操作数据时比较悲观，认为每次拿数据时都可能有别的线程同时修改数据，所以每次拿数据时都会上锁，执行完操作后才会释放锁，这样别的线程想拿这个数据会阻塞直到他拿到锁



### 实现

- 一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数。当数据被修改是，version值会 +1 。当线程A要更新数据时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值于数据库中的version值相等时才会更新
- `update user set name = "zhangsan",version = oldVersion +1 where id = id version = oldVersion`



### 应用

```java
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor(){
    //1.定义MybatisPlus的拦截器
    MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
    //2.添加分页的拦截器
    mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
    //2.添加乐观锁的拦截器
    mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockInnerInterceptor());
    return mybatisPlusInterceptor;
}
```

```java
@Test
public void testUpdate(){
    //1. 通过id获取要修改的完整数据，所以这条数据中包含原始的 version 值
    User user = userDao.selectById(3L);
    //2. 设置值到需要更改的地方
    user.setName("zhangsan");
    //3. 更改
    userdao.updateById(user);
}
```





## 代码生成器

### 坐标

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>

<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>

<!--lombok-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <scope>provided</scope>
</dependency>

<!--mybatisPlus的起步坐标-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.1</version>
</dependency>

<!--代码生成器-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-generator</artifactId>
    <version>3.4.1</version>
</dependency>

<!--velocity模板引擎-->
<dependency>
    <groupId>org.apache.velocity</groupId>
    <artifactId>velocity-engine-core</artifactId>
    <version>2.3</version>
</dependency>
```



### 模板

```java
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;

public class CodeGenerator {
    public static void main(String[] args) {
        //1.获取代码生成器的对象
        AutoGenerator autoGenerator = new AutoGenerator();

        //设置数据库相关配置
        DataSourceConfig dataSource = new DataSourceConfig();
        dataSource.setDriverName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/"+这里"数据库名?serverTimezone=UTC");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        autoGenerator.setDataSource(dataSource);

        //设置全局配置
        GlobalConfig globalConfig = new GlobalConfig();
        globalConfig.setOutputDir(System.getProperty("user.dir")/*项目根位置*/+这里"/模块名/src/main/java");    //设置代码生成位置
        globalConfig.setOpen(false);    //设置生成完毕后是否打开生成代码所在的目录
        globalConfig.setAuthor("Eli");    //设置作者
        globalConfig.setFileOverride(true);     //设置是否覆盖原始生成的文件
        globalConfig.setMapperName("%sDao");    //设置数据层接口名，%s为占位符，指代模块名称
        globalConfig.setIdType(IdType.ASSIGN_ID这里);   //设置Id生成策略
        autoGenerator.setGlobalConfig(globalConfig);

        //设置包名相关配置
        PackageConfig packageInfo = new PackageConfig();
        packageInfo.setParent("com.aaa"这里);   //设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径
        packageInfo.setEntity("domain");    //设置实体类包名
        packageInfo.setMapper("dao");   //设置数据层包名
        autoGenerator.setPackageInfo(packageInfo);

        //策略设置
        StrategyConfig strategyConfig = new StrategyConfig();
        strategyConfig.setInclude("表名"这里);  //设置当前参与生成的表名，参数为可变参数，可添加多个表名
        strategyConfig.setTablePrefix("tb1_");  //设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名  例如： User = tbl_user - tbl_
        strategyConfig.setRestControllerStyle(true);    //设置是否启用Rest风格
        strategyConfig.setVersionFieldName("version");  //设置乐观锁字段名
        strategyConfig.setLogicDeleteFieldName("deleted");  //设置逻辑删除字段名
        strategyConfig.setEntityLombokModel(true);  //设置是否启用lombok
        autoGenerator.setStrategy(strategyConfig);
        //2.执行生成操作
        autoGenerator.execute();
    }
}
```

- 注意事项：
  - UserDao接口上要加@Mapper注解
  - 在配置文件中配置数据库连接池，端口号等信息









# 日志



## JUL

![屏幕截图 2022-09-02 145446](D:\picture\typora\java\屏幕截图 2022-09-02 145446.jpg)

### 快速入门

```java
Logger logger = Logger.getLogger("cn.Eli.test.JulTest");
logger.info("info");
logger.log(Level.INFO, "info");

String name = "zhangsan";
int age = 18;
logger.log(Level.INFO, "姓名：{0} 年龄：{1}", new Object[]{name, age});
```



### 日志级别

- 日志级别

  - SEVERE：错误
  - WARNING：警告
  - INFO：消息（默认）
  - CONFIG：配置
  - FINE：详细信息
  - FINER：详细信息
  - FINEST：详细信息

- 特殊日志级别

  - OFF：可用来关闭所有日志记录
  - ALL：可用来开启所有日志记录

- 设置日志级别

  ```java
  // 是否使用父处理器
  logger.setUseParentHandlers(false);
  // 定义处理器
  ConsoleHandler handler = new ConsoleHandler();
  //FileHandler handler = new FileHandler("C:\\Users\\123\\Desktop\\test.log");
  // 创建日志格式化对象
  SimpleFormatter formatter = new SimpleFormatter();
  // 在处理器中设置输出格式
  handler.setFormatter(formatter);
  // 在记录器中添加处理器
  logger.addHandler(handler);
  // 设置日志的打印级别
  // 日志记录器和处理器的级别进行设置
  logger.setLevel(Level.ALL);
  handler.setLevel(Level.ALL);
  ```



### 父子关系

- 父子关系

  ```java
  Logger logger1 = Logger.getLogger("cn.Eli.test");
  Logger logger2 = Logger.getLogger("cn.Eli.test.JulTest");
  
  logger2.getParent() == logger1; // true
  ```

- logger2的父logger是logger1

- logger1的父logger是 LogManager$RootLogger（内部类）的对象



### 配置文件

- 默认配置文件

  ```properties
  # 文件命名为 logging.properties
  # 配置RootLogger使用的处理器
  handlers = java.util.logging.ConsoleHandler
  # RootLogger的日志记录级别
  .level = INFO
  
  # 文件处理器属性的设置
  # 输出日志文件的路径
  # %h：用户文件夹，%u：文件索引值
  java.util.logging.FileHandler.pattern = %h/java%u.log
  # 输出日志文件的限制（50000字节）
  java.util.logging.FileHandler.limit = 50000
  # 输出日志文件的最大数量
  java.util.logging.FileHandler.count = 1
  # 输出日志的格式
  java.util.logging.FileHandler.formatter = java.util.logging.XMLFormatter
  # 处理器的级别
  java.util.logging.FileHandler.level = SEVERE
  
  # 控制台处理器属性的设置
  # 输出日志的级别
  java.util.logging.ConsoleHandler.level = INFO
  # 输出日志的格式
  java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter
  
  # 可以在指定包下设置特定的日志级别
  com.xyz.foo.level = SEVERE
  ```

- 自定义配置文件

  - 读取配置文件

    ```java
    InputStream is = JulTest.class.getClassLoader().getResourceAsStream("logging.properties");
    // 获取日志管理器对象
    LogManager logManager = LogManager.getLogManager();
    // 读取自定义配置文件
    logManager.readConfiguration(is);
    ```

  - 相关配置

    ```properties
    # 自定义记录qi
    cn.Eli.handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler
    cn.Eli.level = CONFIG
    cn.Eli.userParentHandlers = false
    # 输出日志文件是否追加
    java.util.logging.FileHandler.append = true
    # 指定handler的字符集
    java.util.logging.ConsoleHandler.encoding = UTF-8
    ```





## Log4j

### 组件介绍

#### Loggers

- 具有继承机制
- 日志级别
  -  OFF > FATAL > ERROR > WARN > INFO > DEBUG（默认） > TRACE > ALL

#### Appendars

- 类别
  - ConsoleAppender
  - FileAppender
  - DailyRollingAppender
  - RollingFileAppender
  - JDBCAppender

#### Layouts

- 类别
  - HTMLLayout
  - SimpleLayout
  - PattenLayout
- PattenLayout日志输出格式
  - %m：输出代码中指定的日志信息
  - %p：输出优先级，及 DEBUG、INFO等
  - %n：换行符（Windows平台的换行符为“\n”，Unix平台为“\n”
  - %r：输出自应用启动到输出该 log 信息耗费的毫秒值
  - %c：输出打印语句所属的类的全名
  - %t：输出产生该日志的线程全名
  - %d：输出服务器当前时间，默认为ISO8601，也可以指定格式，如：%d{yyyy年MM月dd日 HH:mm:ss:SSS}
  - %l：输出日志时间发生的位置，包括类名、线程、及在代码中的行数。如：Test.main(Test.java:10)
  - %F：输出日志消息产生时所在的文件名称
  - %L：输出代码中的行号
  - %%：输出一个“%”字符 
  - 可以在 % 与字符之间加入修饰符来控制最小宽度、最大宽度和文本的对其方式。如：
    - %5c：输出category名称，最小宽度是5，category<5，默认的情况下右对齐
    - %-5c：输出category名称，最小宽度是5，category<5，”-“号指定左对齐，会有空格
    - %.5c：输出category名称，最大宽度是5，category>5，就会将左边多出的字符截掉，<5不会有空格
    - %20.30c：输出category名称<20补空格，并且右对齐，>30字符，就会左边交多出的字符截掉



### 快速入门

- 依赖导入

  ```xml
  <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>1.2.12</version>
  </dependency>
  ```

- 记录日志

  ```java
  // 加载初始化信息
  BasicConfigurator.configure();
  /*
  	源码
  	public static void configure(){
  		Logger root = Logger.getRootLogger();
  		root.addAppender(new ConsoleAppender(new PatternLayout("%r [%t] %p %c %x - %m%n")));
  	}
  */
  Logger logger = Logger.getLogger(Log4jTest.class);
  logger.info("info信息")
  ```

  



### 配置文件

```properties
# 文件命名为 log4j.properties
# 以下为根节点rootLogger的配置

#log4j.rootLogger = 日志级别,appenderName1,appenderName2,appenderName3...
log4j.rootLogger = trace,console


#log4j.appender.自定义appender的名字
# 输出到控制台中
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.conversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss:SSS} %m%n

# 输出到文件中
log4j.appender.file = org.apache.log4j.FileAppender
log4j.appender.file.layout = org.apache.log4j.PatternLayout
log4j.appender.file.layout.conversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss:SSS} %m%n
log4j.appender.file.file = C://Users//123//Desktop//log4j.log
log4j.appender.file.encoding = utf-8
# FileAppender中的其他属性
	# boolean fileAppend：是否追加，默认true开启追加
	# int bufferSize：缓冲字节数，默认8192

# 按文件大小进行拆分
log4j.appender.rollingFile = org.apache.log4j.RollingFileAppender
log4j.appender.rollingFile.layout = org.apache.log4j.PatternLayout
log4j.appender.rollingFile.layout.conversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss:SSS} %m%n
log4j.appender.rollingFile.file = C://Users//123//Desktop//log4j.log
log4j.appender.rollingFile.encoding = utf-8
# 指定单个文件的最大字节
log4j.appender.rollingFile.maxFileSize = 1MB
# 指定文件的最大索引值
log4j.appender.rollingFile.maxBackupIndex = 5

# 按时间对文件进行拆分
log4j.appender.dailyRollingFile = org.apache.log4j.DailyRollingFileAppender
log4j.appender.dailyRollingFile.layout = org.apache.log4j.PatternLayout
log4j.appender.dailyRollingFile.layout.conversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss:SSS} %m%n
log4j.appender.dailyRollingFile.file = C://Users//123//Desktop//log4j.log
log4j.appender.dailyRollingFile.encoding = utf-8
# '.'yyyy-MM-dd：默认，按天划分；'.'yyyy-MM-dd HH:mm:ss：按秒划分
log4j.appender.dailyRollingFile.datePattern = '.'yyyy-MM-dd

# 持久化日志
log4j.appender.logDB = org.apache.log4j.jdbc.JDBCAppender
log4j.appender.logDB.layout = org.apache.log4j.PatternLayout
log4j.appender.logDB.Driver = com.mysql.jdbc.Driver
log4j.appender.logDB.URL = jdbc.mysql://localhost:3306/数据库
log4j.appender.logDB.username = root
log4j.appender.logDB.password = root
log4j.appender.logDB.sql = INSERT INTO tbl_log(id,name,createTime,level,category,message) values('project_log','%d{yyyy-MM-dd HH:mm:ss}','%p','%c','%F','%m')
```



### 补充

- LogLog：记录log4j日志输出的日志

  - 控制日志开关的代码 if(debugEnabled && !quietMode){}
  - !quietMode 已经处于 true
  - LogLog.setInternalDebugging(true); 开启日志

- 持久化日志的表

  ```sql
  # 持久化日志的表
  CREATE TABLE tbl_log{
  	id int(11) NOT NULL AUTO_INCREMENT,
  	name varchar(255) DEFAULT NULL COMMENT '项目名称',
  	createTIme varchar(255) DEFAULT NULL COMMENT '创建时间',
  	level varchar(255) DEFAULT NULL COMMENT '日志级别',
  	category varchar(255) DEFAULT NULL COMMENT '所在类的全路径',
  	fileName varchar(255) DEFAULT NULL COMMENT '文件名称',
  	message varchar(255) DEFAULT NULL COMMENT '日志消息',
  	PRIMARY KEY(id)
  }
  ```

- log4j的自定义logger

  ```properties
  # 格式：log4j.logger.目录
  log4j.logger.cn.Eli = info,console
  ```

  - 自定义logger和根节点logger
    - 配置中输出位置不同的，取两者的并集
    - 配置中输出等级不同的，取自定义logger的等级
    - 配置中输出位置相同的，删去自定义logger中的相同位置，以免多次打印





## JCL

### 快速入门

- 依赖导入

  ```xml
  <dependency>
      <groupId>commons-logging</groupId>
      <artifactId>commons-logging</artifactId>
      <version>1.2</version>
  </dependency>
  ```

- 日志记录

  ```java
  // 未导入其他日志框架，默认使用的是jul
  Log log = LogFactory.getLog(LogTest.class);
  log.fatal("fatal信息");
  ```





## SLF4J

### 快速入门

- 依赖导入

  ```xml
  <!--slf4j 核心依赖-->
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.36</version>
  </dependency>
  
  <!--slf4j 自带的简单日志实现-->
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-simple</artifactId>
      <version>1.7.36</version>
  </dependency>
  ```

- 使用自带的日志记录框架记录日志

  ```java
  Logger logger = LoggerFactory.getLogger(LogTest.class);
  // 五个日志记录等级
  logger.error("error信息");
  logger.warn("warn信息");
  logger.info("info信息"); // 默认
  logger.debug("debug信息");
  logger.trace("trace信息");
  ```

- 使用占位符记录日志

  ```java
  Logger logger = LoggerFactory.getLogger(LogTest.class);
  String name = "zhangsan";
  int age = 18;
  logger.info("学生信息-姓名：{}，年龄：{}",name,age);
  ```



### 绑定模式

![slf4j-concrete-bindings](D:\picture\typora\java\slf4j-concrete-bindings.png)

- 三种绑定模式

  - 在没有绑定任何日志实现的基础上，日志是不能绑定实现任何功能的
  - logback和simple（包括nop），都是门面时间线后面提供的日志实现，所以API完全遵循slf4j进行设计的，只需要导入想要是日志框架，即可使用。但是nop是不实现日志记录
  - log4j和JUL是slf4j前面的日志框架，所以API不遵循slf4j进行设计，
    - 对于需要使用该类日志实现技术的项目，可用适配器绑定该日志实现技术
    - 对于已经使用该类日志实现技术的项目，可使用桥接技术，与日志门面进行衔接

- 补充

  - 先导入哪个日志实现依赖就用哪个依赖记录日志

  - 若想用nop关闭所有日志记录功能，则需要首先导入nop的依赖

    ```xml
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-nop</artifactId>
        <version>1.7.36</version>
    </dependency>
    ```

  - SLF4J: Class path contains multiple SLF4J bindings.：表示存在多个日志记录实现



### 绑定

- 绑定log4j

  ```xml
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.36</version>
  </dependency>
  <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>1.2.12</version>
  </dependency>
  
  <!--导入 log4j 适配器的依赖-->
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.36</version>
  </dependency>
  ```

- 绑定JUL

  ```xml
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.36</version>
  </dependency>
  
  <!--导入 jdk14（JUL） 的日志适配器-->
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-jdk14</artifactId>
      <version>1.7.36</version>
  </dependency>
  ```

  

### 桥接

![slf4j-legacy](D:\picture\typora\java\slf4j-legacy.png)

- 删除原先的日志实现技术的依赖

- 导入相应的桥接器依赖

  ```xml
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>log4j-over-slf4j</artifactId>
      <version>1.7.36</version>
  </dependency>
  ```

- 使用的是 log4j 包下的日志组件资源，但真正实现的是 slf4j + logback

- 导入依赖时

  - 如果 桥接器 在 适配器  的上方，则报错
  - 如果 桥接器 在 适配器 的下方，则不会施行桥接器





## logback

### 快速入门

- 依赖

  ```xml
  <!--slf4j 日志门面技术-->
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.36</version>
  </dependency>
  <!--logback 基础模块（包含logback-core核心依赖）-->
  <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
      <version>1.2.11</version>
  </dependency>
  ```

- 记录日志

  ```java
  // 使用的是日志门面技术
  //import org.slf4j.Logger;
  //import org.slf4j.LoggerFactory;
  
  Logger logger = LoggerFactory.getLogger(LogbackTest.class);
  logger.info("hello");
  ```



### 配置文件

- 日志输出格式

  - %-5level：级别，案例为设置5个字节，左对齐
  - %d{yyyy-MM-dd HH:mm:ss:SSS}：日期
  - %c：当前类的全限定名
  - %M：当前执行日志的方法
  - %L：行号
  - %thread：线程名称
  - %m或者%msg：信息
  - %n：换行

- 配置文件logback.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <configuration>
      <property name="pattern" value="[%-5level] %d{yyyy-MM-dd HH:mm:ss:SSS}   %-10thread --->    %msg    %c %M%n"></property>
      <property name="logDir" value="C://Users//123//Desktop"></property>
  
      <appender name="consoleAppender" class="ch.qos.logback.core.ConsoleAppender">
          <!--
              对于日志输出目标的配置
                  System.out：表示以黑色字体输出日志（默认）
                  System.err：表示以红色字体输出日志
          -->
          <target>System.err</target>
          <!--
              配置日志输出格式（引入上面的property）
          -->
          <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
              <pattern>${pattern}</pattern>
          </encoder>
      </appender>
  
      <!-- 默认以追加形式记录日志 -->
      <appender name="fileAppender" class="ch.qos.logback.core.FileAppender">
          <!-- 引入文件位置 -->
          <file>${logDir}/logback.log</file>
  
          <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
              <pattern>${pattern}</pattern>
          </encoder>
      </appender>
      
      <!--<logger name="cn.eli.nio.aaa" level="INFO">
          <appender-ref ref="consoleAppender"/>
      </logger>-->
  
      <!-- 配置rootLogger -->
      <root level="ALL">
          <appender-ref ref="consoleAppender"/>
          <appender-ref ref="fileAppender"/>
      </root>
  </configuration>
  ```

- 配置html格式的日志文件

  ```xml
  <property name="htmlPattern" value="%level%d{yyyy-MM-dd HH:mm:ss:SSS}%msg%c%M%thread"></property>
  <property name="logDir" value="C://Users//123//Desktop"></property>
  
  <appender name="fileAppender" class="ch.qos.logback.core.FileAppender">
      <file>${logDir}/logback.html</file>
      <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
          <layout class="ch.qos.logback.classic.html.HTMLLayout">
              <pattern>${htmlPattern}</pattern>
          </layout>
      </encoder>
  </appender>
  ```

- 拆分文件

  ```xml
  <appender name="roll" class="ch.qos.logback.core.rolling.RollingFileAppender">
      <file>${logDir}/roll_logback.log</file>
      <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">${pattern}</encoder>
      <!-- 指定拆分规则 -->
      <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
          <!-- 按时间和压缩格式命名文件 压缩格式gz -->
          <fileNamePattern>${logDir}/roll.%d{yyyy-MM-dd}.log%i.gz</fileNamePattern>
          <!-- 按文件大小进行拆分 -->
          <maxFileSize>1MB</maxFileSize>
      </rollingPolicy>
  </appender>
  ```

- 使用过滤器

  ```xml
  <appender name="consoleFilterAppender" class="ch.qos.logback.core.ConsoleAppender">
      <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
          <pattern>${pattern}</pattern>
      </encoder>
      <!-- 配置过滤器，匹配等级 -->
      <filter class="ch.qos.logback.classic.filter.LevelFilter">
          <level>ERROR</level>
          <!-- 高于level中设置的级别，则打印日志 -->
          <onMatch>ACCEPT</onMatch>
          <!-- 低于level中设置的级别，则屏蔽日志 -->
          <onMismatch>DENY</onMismatch>
      </filter>
  </appender>
  ```

- 自定义logger

  ```xml
  <!-- additivity="false"表示不继承rootLogger -->
  <logger name="cn.Eli" level="info" additivity="false">
  	<appender-ref ref="consoleAppender"/>
  </logger>
  ```



### 异步日志

- 同步日志：打印日志时，会暂停程序的执行（单线程）

- 异步日志：多线程

  ```xml
  <appender name="consoleAppender" class="ch.qos.logback.core.ConsoleAppender"></appender>
  
  <appender name="asyncAppender" class="ch.qos.logback.classic.AsyncAppender">
      <appender-ref ref="consoleAppender"/>
  </appender>
  
  <root level="ALL">
      <appender-ref ref="asyncAppender"/>
  </root>
  ```





## log4j2

### 快速入门

- 依赖

  ```xml
  <!-- slf4j 日志门面 -->
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>1.7.36</version>
  </dependency>
  <!-- 适配器 -->
  <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-slf4j-impl</artifactId>
      <version>2.17.2</version>
  </dependency>
  <!-- log4j2 日志门面 -->
  <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-api</artifactId>
      <version>2.17.2</version>
  </dependency>
  <!-- log4j2 日志实现 -->
  <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-core</artifactId>
      <version>2.17.2</version>
  </dependency>
  ```

- 日志记录

  ```java
  // log4j2 日志记录
  //import org.apache.logging.log4j.LogManager;
  //import org.apache.logging.log4j.Logger;
  
  // 六种记录等级
  Logger logger = LogManager.getLogger(Log4j2Test.class);
  logger.fatal("fatal");
  logger.error("error"); // 默认
  logger.warn("warn");
  logger.info("info");
  logger.debug("debug");
  logger.trace("trace");
  ```

  ```java
  // slf4j+log4j2 日志记录
  //import org.slf4j.Logger;
  //import org.slf4j.LoggerFactory;
  
  // 执行原理：slf4j门面调用的是log4j2的门面，再由log4j2门面调用log4j2的日志实现
  Logger logger = LoggerFactory.getLogger(Log4j2Test.class);
  logger.error("error");
  logger.warn("warn");
  logger.info("info");
  logger.debug("debug");
  logger.trace("trace");
  ```

- 配置文件

  ```xml
  <!-- 配置文件名 log4j2.xml -->
  
  <?xml version="1.0" encoding="UTF-8" ?>
  <!-- 此处的error是配置记录日记记录器的日志级别（LogLog） -->
  <Configuration status="error">
      <Appenders>
          <Console name="consoleAppender" target="SYSTEM_ERR"></Console>
      </Appenders>
  
      <Loggers>
          <Root level="trace">
              <AppenderRef ref="consoleAppender"/>
          </Root>
      </Loggers>
  </Configuration>
  ```



### 其他配置

- 输出到文件中

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <Configuration>
      <properties>
          <property name="logDir" value="C://Users//123//Desktop"></property>
          <property name="pattern" value="[%-5level] %d{yyyy-MM-dd HH:mm:ss:SSS} %msg -> %c %M %thread%n"></property>
      </properties>
  
      <Appenders>
          <File name="fileAppender" fileName="${logDir}/log4j2.log">
              <PatternLayout pattern="${pattern}"/>
          </File>
      </Appenders>
  
      <Loggers>
          <Root level="trace">
              <AppenderRef ref="fileAppender"/>
          </Root>
      </Loggers>
  </Configuration>
  ```

- 拆分日志文件

  ```xml
  <!-- 日志文件的名字，filePattern表示日志文件拆分后的命名规则，可分文件夹-->
  <!-- 文件的命名不支持特殊符号 -->
  <RollingFile name="rollingFileAppender" fileName="${logDir}/rollog.log"
               filePattern="${logDir}/%d{yyyy-MM-dd}/rollog-%d{HH}hours-%i.log">
      <PatternLayout pattern="${pattern}"/>
  
      <Policies>
          <!-- 在系统启动时，触发拆分规则，产生一个日志文件 -->
          <OnStartupTriggeringPolicy/>
          <!-- 按文件的大小进行拆分-->
          <SizeBasedTriggeringPolicy size="1MB"/>
          <!-- 按时间节点进行拆分 拆分规则是filePattern-->
          <TimeBasedTriggeringPolicy/>
      </Policies>
  
      <!-- 在同一目录下，文件的个数限制，如果超出，则根据时间进行覆盖 -->
      <DefaultRolloverStrategy max="30"></DefaultRolloverStrategy>
  </RollingFile>
  ```




### 异步日志

- AsyncAppender

  - 异步日志依赖

    ```xml
    <dependency>
        <groupId>com.lmax</groupId>
        <artifactId>disruptor</artifactId>
        <version>3.3.7</version>
    </dependency>
    ```

  - 引入异步日志

    ```xml
    <Appenders>
        <Console name="consoleAppender" target="SYSTEM_ERR"></Console>
        
        <Async name="myAsync">
            <AppenderRef ref="consoleAppender"/>
        </Async>
    </Appenders>
    
    <Loggers>
        <Root level="trace">
            <AppenderRef ref="myAsync"/>
        </Root>
    </Loggers>
    ```

- AsyncLogger

  - 全局异步

    - 创建 log4j2.component.properties 文件
    - 配置：Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector

  - 混合异步

    ```xml
    <Loggers>
        <Root level="trace">
            <AppenderRef ref="myAsync"/>
        </Root>
        
        <!--
    	includeLocation="false"：去除日志中行号信息，行号信息非常影响效率
    	addactivity="false"：不继承rootLogger
    	-->
        <AsyncLogger name="cn.Eli" level="trace" includeLocation="false" additivity=
    "false">
        	<AppenderRef ref="consoleAppender"/>
        </AsyncLogger>
    </Loggers>
    ```









# SpringBoot



## 基础篇

### 配置文件

- 类型
  - application.properties
  - application.yml
  - application.yaml
  - 优先级：application.properties > application.yml > application.yaml

- yaml数据的读取

  - yaml数据

  ```yaml
  server:
   prot: 80
   servlet:
    context-path: /
   
  logging:
   level:
    root: info
    
  OnePerson:
   basketball: true
   music: true
   likes:
    - sing
    - dance
    - rap
  ```

  - 三种读取方式
  
    ```java
    @Value("${server.port}")
    private Integer port;
    ```
  
    ```java
    @Autowired
    private Environment environment;
    
    private String port = environment.getProperty("server.prot");
    private String like = environment.getProperty("OnePerson.likes[0]");
    ```
  
    ```java
    @Component
    @ConfigurationProperties(prefix = "OnePerson")
    @Date
    public class OnePerson{
        // prefix与属性名的拼接，即为yaml文件中的
        private boolean basketball;
        private boolean music;
        private String[] likes;
    }
    
    public class Test{
        @Autowired
        private OnePerson onePerson;
    }
    ```
  
  - yaml文件的变量
  
  ```yaml
  location:
   baseDir: C:\windows
   
  tempDir: ${location.baseDir}\temp
  # \t是转义字符，使用引号包裹转义可生效
  tempDir: "${location.baseDir}\temp" # 此处的 \t hui
  ```
  
  - 自定义对象封装的警告解决方案
  
  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-configuration-processor</artifactId>
      <optional>true</optional>
  </dependency>
  ```
  



### 整合junit

- 因为maven在打包时默认会测试，所以springboot默认整合了junit
- 测试 @SpringBootTest

```java
@SpringBootTest
class Springboot03JunitApplicationTests {
    @Autowired
    private UserService userService;
    
    public void test(){
        userService.save();
    }

    @Test
    void contextLoads() {
    }
}
```

- 问题
  - spring在整合junit时，需要加注解@RunWith（设置类运行器）和@SpringContext（指定spring容器）。
  - springboot会在测试类所在的包中找SpringBootConfiguration
  - 如果测试类和引导类在同一包下，则不需要指定spring容器位置。
  - 如果不在同一包下，则需用@SpringBootTest(classes = 引导类的class) 或 @ContextConfiguration(classes = 引导类的class)



### 整合mybatis

- 勾选MyBatis技术和数据库连接技术，也就是导入MyBatis对应的starter和数据库连接

- 配置连接

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ssm
    username: root
    password: root
```

- 数据库SQL映射需要添加@Mapper被容器识别到


- 常见问题
  - MySQL-8驱动强制要求设置时区
    - 配置时区：jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
    - 修改mysql数据库配置
  - 驱动类过时：driver-class-name: com.mysql.cj.jdbc.Driver





## 运维篇

### 服务器启动

#### windows

- 对springboot项目打包

```maven
mvn package
```

- 运行项目

```cmd
java -jar springboot.jar
```

- 注：jar支持命令行启动需要依赖maven插件

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

- 常用指令

```cmd
# 查询端口
netstat -ano
# 查询指定端口
netstat -ano | findstr "端口"
# 根据进程PID查询进程名称
tasklist | findstr "进程PID号"
# 根据PID杀死任务
taskkill /F /PID "进程PID号"
# 根据进程名称杀死任务
taskkill -f -t -im "进程名称"
```

#### linux

- 创建目录 /usr/local/java_project
- 将jar包移到该目录下
- 运行项目





### 配置高级

#### 配置

- 携带临时属性启动springboot

```cmd
java -jar springboot.jar --server.port=8080
```

- 携带多个属性启动springboot，属性间使用空格分隔

- 引导类设置

```java
public class Application{
    public static void main(String[] args){
        //args 中的数据是临时参数，不传递到run方法中可断开联系
        SpringApplication.run(Application.class,args);
    }
}
```

- springboot中的4级配置文件（复制叠加）

  - 1级：file：application.yml
  - 2级：file：config/application.yml
  - 3级：classpath：application.yml
  - 4级：classpath：config/application.yml
  - 注：文件优先级：properties > yml > yaml

- spring配置文件的设置

  - 添加临时属性

  ```cmd
  --spring.config.name=newApplication
  --spring.config.location=classpath:/newApplication1.yml/newApplication2.yml
  ```


#### 属性层级

1. 默认属性（由设置指定`SpringApplication.setDefaultProperties`）。
2. [`@PropertySource`](https://docs.spring.io/spring-framework/docs/5.3.22/javadoc-api/org/springframework/context/annotation/PropertySource.html)`@Configuration`您的课程上的注释。请注意，`Environment`在刷新应用程序上下文之前，不会将此类属性源添加到 中。配置某些属性（例如在刷新开始之前读取的`logging.*`和）为时已晚。`spring.main.*`
3. 配置数据（例如`application.properties`文件）。
4. 仅在中`RandomValuePropertySource`具有属性的 A。`random.*`
5. 操作系统环境变量。
6. Java 系统属性 ( `System.getProperties()`)。
7. JNDI 属性来自`java:comp/env`.
8. `ServletContext`初始化参数。
9. `ServletConfig`初始化参数。
10. 来自`SPRING_APPLICATION_JSON`（嵌入在环境变量或系统属性中的内联 JSON）的属性。
11. 命令行参数。
12. `properties`属性在你的测试。可[用于测试应用程序的特定部分](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.autoconfigured-tests)[`@SpringBootTest`](https://docs.spring.io/spring-boot/docs/2.7.2/api/org/springframework/boot/test/context/SpringBootTest.html)的测试注释。
13. [`@TestPropertySource`](https://docs.spring.io/spring-framework/docs/5.3.22/javadoc-api/org/springframework/test/context/TestPropertySource.html)测试上的注释。
14. `$HOME/.config/spring-boot`当 devtools 处于活动状态时，目录中的[Devtools 全局设置属性。](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.globalsettings)



### 多环境开发

#### 使用

- yaml，yml

  - 格式

  ```yaml
  # 应用环境
  # 启动指定环境
  spring:
   profiles:
    active: pro
  # 在此环境中添加公共配置
  ---
  # 环境设置
  # 生产环境
  spring:
   profiles: pro
  server:
   port: 80
  ---
  # 开发环境
  spring:
   profiles: dev
  server:
   port: 81
  ---
  # 测试环境
  spring:
   config:
    activate:
     on-profile: test
  server:
   port: 82
  ```

  - 拆分：

    - application-dev.yml
    - application-pro.yml：

    ```yaml
    server:
     port: 80
    ```

    - 主配置：

    ```yaml
    spring:
     profiles:
      active: pro
    ```

- properties：只能拆分成多文件

#### 独立配置文件

- 命名规则：
  - application-devDB.yml
  - application-devRedis.yml
  - application-devMVC.yml
- 使用include属性加载

```yaml
# 相同属性，后加载的覆盖先加载的，dev的优先级在最后
spring:
 profiles:
  active: dev
   include: devDB,devRedis,devMVC
```

- group（Spring2.4）

```yaml
# 选择dev后，会加载dev配置文件和dev组中的group，dev的优先级在最前
spring:
 profiles:
  active: dev
  group:
   "dev": devDB,devMVC
   "pro": proDB,proMVC
```

- 读取maven中的配置

```xml
<profiles>
    <profile>
        <id>env_dep</id>
        <properties>
            <profile.active>dev</profile.active>
        </properties>
        <activation>
            <activeByDefault>true（是否为默认环境）</activeByDefault>
        </activation>
    </profile>
    <profile>
        <id>env_pro</id>
        <properties>
            <profile.active>pro</profile.active>
        </properties>
    </profile>
    <profile>
        <id>env_test</id>
        <properties>
            <profile.active>test</profile.active>
        </properties>
    </profile>
</profiles>
```

```yaml
spring:
 profiles:
  active: @profile.active@
  group:
   "dev": devDB,devMVC
   "pro": devDB,devMVC
```

注：基于springboot读取maven配置的前提下，如果在idea下测试工程时pom.xml每次更新需要手动compile方可生效



### 日志

#### 基础操作

- 日志的作用
  - 编程期调试代码
  - 运营期记录信息
    - 记录日常运营的重要信息（峰值流量、平均响应时长……）
    - 记录应用报错信息（错误堆栈）
    - 记录运维过程数据（扩容、宕机、报警……）

- 日志文件：

  - 配置springboot日志

    ```properties
    # springboot默认使用的是logback日志
    
    logging.level.cn.Eli = trace
    logging.pattern.console = %d{yyyy-MM-dd HH:mm:ss} [%-5level] %m%n
    logging.file.path = C:/Users/123/Desktop
    ```

  - 配置logback日志文件

- 使用log4j2日志

  ```xml
  <dependency>
      <groutId>org.springframework.boot</groutId>
      <artifactId>spring-boot-stater-web</artifactId>
      <!-- 排除掉原始依赖（包括logback） -->
      <exclusions>
          <exclusion>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-stater-logging</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
  
  <!-- 添加log4j2的依赖 -->
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-stater-logging</artifactId>
  </dependency>
  ```

  


### 热部署

- 坐标

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
</dependency>
```

- 激活热部署：Build Project

- 补充：

  - 重启：自定义开发代码，包含类、页面、配置文件等，加载位置restart类加载器（热部署）

  - 重载：jar包，加载位置base类加载器

- 热部署范围设置

  - 默认不触发重启的目录列表

    - /META-INF/maven、/META-INF/resouces、/resources、/static、/public、/templates

    - 设置

      ```yml
      devtools:
       restart:
        exclude: static/**,public/**
        enabled: true(默认)/flase
      ```

      



## 开发篇

### MongoDB

- docker部署

  ```shell
  # docker run --name mongo -v /mongo_local_data:/data/db -d -p 27017:27017 mongo
  docker run --name mongo -itd --auth -d -p 27017:27017 mongo
  ```

  - -itd 交互后台运行容器
  - --auth 需要密码才能访问容器服务

- 创建MongoDB账号

  ```shell
  docker exec -it mongo bash
  ```

  ```shell
  mongo admin
  db.createUser({ user:'admin',pwd:'mongo',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},"readWriteAnyDatabase"]});
  ```

  ```shell
  db.auth('admin', 'mongo')
  ```

- 常用指令

  - 数据库操作

    - use DB_NAME：如果数据库不存在，则创建数据库，否则切换到指定数据库。
    - db：查看当前数据库
    - show dbs：查看所有数据库
    - db.DB_NAME.insert({"name":"张三"})：插入数据
    - db.DB_NAME.drop()：删除当前库

    - 注意: 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。

  - 集合操作

    - db.createCollection("name",  {options: val, ...})
      - name：集合名
      - options：可选参数
        - capped：布尔，如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。
        - size：数值，集合最大字节数
        - max：数值，指定固定集合中包含文档的最大数量。
    - db.COL_NAME.drop()
    - show collections

  - 文档操作

    - db.COL_NAME.insert(document)：插入文档
    - db.COL_NAME.insertOne(document)：_id存在则更新数据，不存在则插入文档

- 客户端

  - 依赖

    ```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-mongodb</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
    </dependency>
    ```

  - 配置

    ```yaml
    spring:
      data:
        mongodb:
          uri: mongodb://192.168.36.132/test
    ```

  - java客户端

    ```java
    @Autowired
    MongoTemplate mongoTemplate;
    ```

    



### task

- 坐标

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
  </dependency>
  ```

- 启动类添加==@EnableScheduling==注解

- 编写组件

  ```java
  @Component
  public class MyTask {
      @Scheduled(cron = "0/1 * * * * ?")
      public void print() {
          System.out.println("hello, world!");
      }
  }
  ```

  - cron生成器：https://www.bejson.com/othertools/cron/

  可选配置

  ```yaml
  spring:
    task:
      scheduling:
        pool:
          # 任务调度线程池大小，默认 1
          size: 1
        # 调度线程名的前缀，默认 scheduling-
        thread-name-prefix: timer_
        shutdown:
          # 线程关闭时等待所有任务完成
          await-termination: false
          # 设置调度线程关闭前最大等待时间，确保最后一次一定关闭
          await-termination-period: 10s
  ```

  

### Mail

- 坐标

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
  </dependency>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-mail</artifactId>
  </dependency>
  ```

- 配置

  ```yaml
  spring:
    mail:
      host: smtp.qq.com
      username: 2837995218@qq.com
      password: ratppigfwfugdgcj
  ```

- 发送业务

  ```java
  @Service("mail")
  public class MailServiceImpl implements MailService {
      @Autowired
      private JavaMailSender javaMailSender;
  
      @Override
      public void sendMail() {
          /* 发送简单邮件
          SimpleMailMessage message = new SimpleMailMessage();
          message.setFrom("2837995218@qq.com"+"(eli)");
          message.setTo("axdceep31@163.com");
          message.setSubject("respect");
          message.setText("hello, long time no see.");
          //message.setSentDate(); // 设置邮件发送的时间
          javaMailSender.send(message);*/
          
          try {
              MimeMessage message = javaMailSender.createMimeMessage();
              // 是否添加附件
              MimeMessageHelper helper = new MimeMessageHelper(message, true);
              helper.setFrom("2837995218@qq.com"+"(eli)");
              helper.setTo("axdceep31@163.com");
              helper.setSubject("respect");
              // 是否解析文本中的标签
              helper.setText("hello, long time no see. welcome to "+
                             "<a href='https://www.baidu.com'>百度</a>", true);
              // 添加附件
              File file1 = new File("file1");
              File file2 = new File("file2");
              helper.addAttachment(file1.getName(), file1);
              helper.addAttachment(file2.getName(), file2);
              javaMailSender.send(message);
          }catch (Exception e){
              e.printStackTrace();
          }
      }
  }
  ```

  



### admin

- 基于spring-boot-starter-actuator监控模块的图形化管理界面

#### actuator

- 依赖

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
  </dependency>
  ```

- 配置

  ```yaml
  management:
    endpoint:
      health:
        # 显示 health 的详细信息，默认never
        show-details: always
      info:
        # 是否提供该数据
        enable: true
    endpoints:
      enabled-by-default: true # 默认true，表示能暴露所有数据，jconsole可以查看
      web:
        exposure:
          # 配置在web端可以暴露的数据，* 可以查看所有信息，默认health
          include: "*"
  ```

- 使用：访问 http://localhost/actuator



#### monitor

- 坐标

  ```xml
  <!-- spring未集成admin，可使用第三方依赖管理 -->
  <dependencyManagement>
      <dependencies>
          <dependency>
              <groupId>de.codecentric</groupId>
              <artifactId>spring-boot-admin-dependencies</artifactId>
              <version>2.5.4</version> <!-- 与springboot版本一致 -->
              <type>pom</type>
              <scope>import</scope>
          </dependency>
      </dependencies>
  </dependencyManagement>
  
  <dependencies>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
      </dependency>
      <dependency>
          <groupId>de.codecentric</groupId>
          <artifactId>spring-boot-admin-starter-server</artifactId>
      </dependency>
  </dependencies>
  ```

- 启动类加注解==@EnableAdminServer==

#### server

- 依赖

  ```xml
  <dependency>
      <groupId>de.codecentric</groupId>
      <artifactId>spring-boot-admin-starter-client</artifactId>
  </dependency>
  ```

- 配置

  ```yaml
  spring:
    boot:
      admin:
        client:
          url: http://localhost:80 # 监控服务地址
  
  # actuator的配置
  ```

- 信息展示

  - yaml配置

    ```yaml
    info:
      author: eli
      appName: @project.artifactId@
    ```

  - bean

    ```java
    @Component
    public class InfoConfig implements InfoContributor {
        @Override
        public void contribute(Info.Builder builder) {
            builder.withDetail("now：", new Date());
        }
    }
    ```

- health展示：health下有一个组件down，该服务状态为down

  ```java
  @Component
  public class HealthConfig extends AbstractHealthIndicator {
      @Override
      protected void doHealthCheck(Health.Builder builder) throws Exception {
          builder.withDetail("myHealth", "value");
          builder.withException(new RuntimeException("hello"));
          builder.status(Status.UP); // builder.up();
      }
  }
  ```

- metrics展示：可在业务层执行注入MeterRegistry，来统计该业务调用的次数

  ```java
  @Service
  public class UserServiceImpl implements UserService {
      private Counter counter;
      public BookServiceImpl(MeterRegistry registry){
          counter = registry.counter("该业务执行次数");
          // counter.increment(); // 业务中调用该方法
      }
  }
  ```

  

#### 自定义端点

```java
@Component
@Endpoint(id = "pay", enableByDefault = true)
public class PayEndpoint {
    @ReadOperation // 读取端点时，调用该方法
    public String getPay() {
        return "你支付，我快乐";
    }
}
```









## 原理篇



### spring补充

#### bean 的加载方式

##### 第一种

- xml + \<bean/>



##### 第二种

- xml:context + 注解（@Component+4个@Bean）



##### 第三种

- 配置类+扫描+注解（@Component+4个@Bean）
  - @Bean定义FactoryBean接口
  - @ImportResource
  - @Configuration 注解的 proxyBeanMethod 属性
    - ProxyBeanMethods = true（默认），表示使用配置类的代理对象
    - 使用代理对象时，通过配置类调用方法方法时创建对象时，先检查容器中有没有相同实体的对象，若有，则使用容器内的对象



##### 第四种

- @ImportResource(String[] files)：可导入外部配置

- @Import(Class<?>[] classes)
  - 可导入实体类从而创建bean
  - 可导入配置类

```java
@Configuration
@ImportResource({"applicationContext1.xml","applicationContext2.xml"})
@Import({SpringConfig2.class,SpringConfig3.class})
public class SpringConfig1 {
    @Bean
    public DogFactroyBean dog(){
        return new DogFactroyBean();
    }
}
// 所有配置文件 都配置了名为dog的bean
// 顺序：	2.xml -> 1.xml -> SpringConfig1 -> SpringConfig3 -> SpringConfig2
```



##### 第五种

- 可以在上下文对象初始化完毕后，手动添加bean

```java
AnnotationConfigApplication ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
// registerBean(String beanName,Class<?> class,construtorArgs:......)
// 后添加的覆盖先添加的
ctx.registerBean("cat",Cat.class);
ctx.registerBean("cat",Cat.class);
// register(Class<?> class)
ctx.register(Dog.class);
```



##### 第六种

- 实现ImportSelector接口

```java
public class MyImportSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata metadata) {
        return new String[]{"cn.langh.bean.Dog"};
    }
}
```

```java
@Import(MyImportSelector.class)
```

- AnnotationMetadata：通过条件选择可用来控制加载bean


```
// @Import(MyImportSelector.class)注解所在的类的信息
metadata.getClassName(); // 类名
metadata.hasAnnotation("注解的全类名") // 是否有该注解
metadata.getAnnotationAttributes("注解的全类名") // 注解中的属性值
// ...
```



##### 第七种

- 实现ImportBeanDefinitionRegister


```java
public class MyRegister implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        
    }
}
```

```java
@Import(MyRegister)
```

- AnnotationMetadata：通过条件选择可用来控制加载bean
- BeanDefinitionRegistry：用来构建bean

```java
BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Dog.class).getBeanDefinition();
beanDefinition.setScope();
// ...
        registry.registerBeanDefinition("name",beanDefinition);
```



##### 第八种

- 实现BeanDefinitionRegistryPostProcessor

```java
public class MyPostProcessor implements BeanDefinitionRegistryPostProcessor {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {
        
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {

    }
}
```

```
@Import(MyPostProcessor.class)
```

- 等到系统的bean全部定义完，再定义此处的bean，若与之前的bean重复，便可覆盖





#### bean 的加载控制

##### 编程式

```java
public class MyImportSelector implements ImportSelector{
    @Override
    public String[] selectImport(AnnotationMetadata metadata){
        try{
            Class<?> class = Class.forname("cn.langh.bean.Mouse");
            if(class != null){
                return new String[]{"cn.langh.bean.Cat"};
            }
        }catch(ClassNotFoundException e){
            return new String[0];
        }
        return null;
    }
}
```

##### 注解式

- springboot提供的注解，定义在bean上或bean对应的类上

- @ConditionalOnClass(name = "全类名")：存在这个类时
- @ConditionalMissingClass(“全类名”)：不存在这个类时
- @ConditionalOnBean(......)：存在这个bean时
- @ConditionalMissingBean(......)：不存在这个bean时
- @ConditionalOnNotWebApplication：不是web项目时
-  。。。。。。





#### bean 依赖的属性配置

- 将业务功能bean运行需要的资源抽取成独立的属性类（***Properties），设置读取配置文件的信息

```java
@Data
@ConfigurationProperties(prefix = "cartoon") // 读取yml配置文件
public class CartoonProperties{
    private Cat cat;
    private Mouse mouse;
}
```

```java
@Component // 最好在spring容器上用@Import导入
@EnableConfigurationProperties(CartoonProperties.class)
public class CartoonCatAndMouse{
    private CartoonProperties = properties;
    
    public CartoonAndMouse(CartoonProperties properties){
        this.properties = properties;
        Cat cat = new Cat();
        Cat catp = properties.getCat();
        cat.setName(catp!=null && StringUtils.hasText(catp.getName()) ? catp.getName() , "tom");
    }
}
```





### 自动配置原理























# Crawler

## 快速入门

- 坐标导入

```xml
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
    <version>4.5.13</version>
</dependency>
```

- 基础案例

```java
public class CrawlerFirst {
    public static void main(String[] args) throws IOException {
        // 1. 打开浏览器 => 创建 HttpClient 对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 2. 输入网址 => 发起 Get 请求创建 HttpGet 对象
        HttpGet httpGet = new HttpGet("https://www.baidu.com");

        // 3. 发起请求，返回响应 => 使用 HttpClient 对象发起请求
        CloseableHttpResponse response = httpClient.execute(httpGet);

        // 4. 解析响应，获取数据
        HttpEntity entity = response.getEntity();
        String html = EntityUtils.toString(entity,"utf-8");
    }
}
```



## HttpClient

### 请求参数

- 参数在url中

```java
URIBuilder uriBuilder = new URIBuilder("http://www.baidu.com/s");
uriBuilder.setParameter("wd","crawler");
URI uri = uriBuilder.build();
HttpGet httpGet = new HttpGe(uri);
```

- 参数在请求体中

```java
HttpPost httpPost = new HttpPost("http://www.baidu.com/s");
//声明List集合，封装表单中的数据
List<NameValuePair> params = new ArrayList<nameValuePair>();
params.add(new BasicNameValuePair("wd","crawler"));
//创建表单的Entity对象
UrlEncodeFormEntity formEntity = new UrlEncodeFormEntity(params,"utf-8");
```



### 连接池

```java
public class HttpClientPoolTest {
    public static void main(String[] args) throws IOException {
        // 创建连接池管理器
        PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();
        // 设置最大连接数
        cm.setMaxTotal(10);
        // 设置每个主机的最大连接数
        cm.setDefaultMaxPerRoute(5);

        doGet(cm);
        doGet(cm);
    }

    private static void doGet(PoolingHttpClientConnectionManager cm) throws IOException {
        // 从连接池中获取 HttpClient 对象
        CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();
        HttpGet httpGet = new HttpGet("https://www.baidu.com");
        CloseableHttpResponse response = httpClient.execute(httpGet);
        response.close();
    }
}
```



### 配置参数

```java
RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(1000)    //设置创建连接的最长时间
    .setConnectionRequestTimeout(500)   //设置获取连接的最长时间
    .setSocketTimeout(10 * 1000)  //设置数据传输的最长时间
    .build();

HttpGet httpGet = new HttpGet("http://www.baidu.com/s");
httpGet.setConfig(requestConfig);
```





## Jsoup

### 坐标

```xml
<dependency>
    <groupId>org.jsoup</groupId>
    <artifactId>jsoup</artifactId>
    <version>1.14.3</version>
</dependency>

<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.6</version>
</dependency>

<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.8.1</version>
</dependency>
```



### 基础案例

- 解析 url

```java
// 解析url地址
Document document = Jsoup.parse(new URL("http://www.baidu.com"), 1000);
// 使用标签选择器，获取 title 标签中的内容
String title = document.getElementsByTag("title").first().text();
```

- 解析字符串


```java
// 使用工具类读取文件，获取字符串
String html = FileUtils.readFileToString(new File("文件位置"), "编码格式");
Document doc = Jsoup.parse(html);
```

- 文件的解析

```java
Document doc = Jsoup.parse(new File("文件位置"), "编码格式");
```



### Dom

- 获取元素

  - 根据 id 查询元素：getElementById()

  - 根据 标签 获取元素：getElementByTag()

  - 根据 class 获取元素：getElementByClass()

  - 根据 属性 获取元素：
    - getElementByAttribute()
    - getElementByAttributeValue()

- 元素中获取数据

  - 获取 id ：element.id()
  - 获取 className ：
    - element.className()
    - element.classNames()：将className中的内容按空格做拆分
  - 获取 属性 ：
    - element.attr("attributeKey")
    - element.attributes()



### 选择器

#### 获取元素

- tagname：通过标签查找元素，例如：span
- #id：通过 id 查找元素，例如：#city_bj
- .class：通过 class 名称查找数据，例如：.class_a
- [attribute]：通过 属性 查找元素，例如：[abc]
- [attr=value]：通过 属性值 查找元素，例如：[class=s_name]

```java
doc.select("[class=s_name]");
```

#### 组合选择器

- el#id：元素+id，例如：h3#city_bj
- el.class：元素+class，例如：li.class_a
- el[attr]：元素+属性名，例如：span[abc]
- ancestor child：查找某个元素下子元素，例如：.city_con li 查找"city_con"下的所有 "li"
- parent > child：查找某个父元素下的直接子元素，例如：.city > ul > li
- parent > *：查找某个父元素下所有的直接子元素





## WebMagic

![webmagic](D:\picture\typora\java\image-20220717091809167.png)

### 入门程序

```xml
<dependency>
    <groupId>us.codecraft</groupId>
    <artifactId>webmagic-core</artifactId>
    <version>0.7.5</version>
</dependency>
<dependency>
    <groupId>us.codecraft</groupId>
    <artifactId>webmagic-extension</artifactId>
    <version>0.7.5</version>
</dependency>
```

```java
public class JobProcessor implements PageProcessor {
    // 解析页面
    public void process(Page page) {
        // 解析返回的数据 page 。并且把解析的结果放到 ResultItems 中
        page.putField("div",page.getHtml().css("div.mt h2").all());
    }

    private Site site = Site.me()
        .setCharset(String charset);
    public Site getSite() {
        return site;
    }

    // 主函数，执行爬虫
    public static void main(String[] args) {
        Spider.create(new JobProcessor())
                .addUrl("地址") // 设置获取数据的页面
                .run(); // 执行爬虫
    }
}
```



### PageProcessor

- 抽取元素（链式）
  - XPath
    - //title[@lang] ： 获取所有拥有名为 lang 的属性的 title 元素
    - //div[@id=div_01]/ul/li/a
  - 正则表达式
  - css 选择器

- 获取连接
  - `page.addTargetRequests(page.getHtml().css("").links().all());`

- Site

| 方法                     | 说明                              |
| ------------------------ | --------------------------------- |
| setCharset(String)       | 设置编码                          |
| setUserAgent(String)     | 设置UserAgent                     |
| setTimeOut(int)          | 设置超时时间                      |
| setRetryTime(int)        | 设置重试时间                      |
| setCycleRetryTimes(int)  | 设置重试次数                      |
| addCookie(String,String) | 添加一条cookie                    |
| setDomain(String)        | 设置域名，设置后，setCookie才生效 |
| addHeader(String,String) | 添加一条Header                    |
| setHttpProxy(HttpHost)   | 设置代理                          |



### Spider

- 是爬虫启动的入口。

  ```java
  Spider.create(new JobProcessor())
      .addUrl("地址") // 设置获取数据的页面
      .run(); // 执行爬虫
  ```

- Spider的其他组件（Downloader、Scheduler、Pipeline）都可以通过set方法来进行设置

  | 方法                        | 说明                                             |
  | --------------------------- | ------------------------------------------------ |
  | create（PageProcessor）     | 创建Spider                                       |
  | addUrl（String ...）        | 添加初始化的URL                                  |
  | 添加初始化的URL             | 开启的线程数                                     |
  | run（）                     | 启动，会阻塞当前线程执行                         |
  | start（）/runAsync（）      | 异步启动，当前线程继续执行                       |
  | addPipeline（Pipeline）     | 添加一个Pipeline，一个Spider可设置多个Pipeline   |
  | setSchedule（Schedule）     | 设置Schedule，一个Spider只能设置一个Schedule     |
  | setDownloader（Downloader） | 设置Downloader，一个Spider只能设置一个Downloader |
  | get（String）               | 同步调用，并直接取得结果                         |
  | getAll（String ...）        | 同步调用，并直接取得一堆结果                     |



### 定时任务

- spring内置的Spring Task，Spring3.0加入

- @EnableSchedule
- 使用@Scheduled注解，属性如下
  - cron：cron表达式，指定任务在特定时间执行
  - fixedDelay/fixedDelayString：上一次任务执行完成后多久再执行，单位ms
  - fixedRate/fixedRateString：按一定的频率执行任务，单位ms
  - initialDelay/initialDelayString：延迟多久再第一次执行任务，单位ms
  - zone：时区，默认当前时区
- cron表达式
  - 由七个子表达式组成，描述个别细节的时间段
    - Second：0-59
    - Minutes：0-59
    - Hours：0-23
    - Day-of-Month：1-31
    - Month：0-11（或JAN、FEB、MAR......）
    - Day-of-Week：1-7（或SUN、MON、TUE......）（1是周日）
    - Year（可选字段）
  - 例如 "0 0 12 ? * WED "：在每个星期三下午 12:00 执行
    - /：表示每，如在Minutes字段上的 "3/20"，表示从3分开始，每20分钟
    - \*：代表所有
    - ?：表示每月（或每周）的某一天
    - L：用于每月，或每周，表示未每月的最后一天，或每个月的最后星期几



### 网页去重

- simhash算法



### 代理

```java
// 创建下载器Downloader
HttpClientDownloader downloader = new HttpClientDownloader();
// 给下载器设置代理服务信息
downloader.setProxyProvider(SimpleProxProvider.from(new Proxy("代理ip",端口)));
// 设置下载器
Spider.create(new P())
    .addUrl("")
    .setDownloader(downloader)
    .run();
```





## 正则

### 基础

#### 转义符

- 元字符-转义符 

  - 需要用到转义符号的字符有：

    ```java
    . * ( ) $ / \ ? [ ] ^ { }
    ```



#### 字符匹配符

| 符号 | 含义                     | 示例       | 解释                                                |
| ---- | ------------------------ | ---------- | --------------------------------------------------- |
| [ ]  | 可接收的字符列表         | [efgh]     | 表示e、f、g、h中的任意1个字符                       |
| [^ ] | 不可接收的字符列表       | [^abc\]    | 除a、b、c之外的任意1个字符，<br/>包括数字和特殊字符 |
| -    | 连字符                   | A-Z        | 任意单个大写字母                                    |
| .    | 匹配除\n以为的任何字符   | a..b       | 以a开头，b结尾，<br/>中间包括2个任意字符的字符串    |
| \d   | 匹配单个数字字符         | \d{3}(\d)? | 包含3或4个数字的字符串                              |
| \w   | 匹配单个数字或字母的字符 | \d{3}\w{4} | 3个数字开头长度为7的数字字母字符串                  |
| \D   | 匹配单个非数字字符       |            |                                                     |
| \W   | 匹配单个非数字非字母字符 |            |                                                     |
| \s   | 空白字符：空格、制表符等 |            |                                                     |
| \S   | 非空白字符               |            |                                                     |



#### 选择匹配符

- | ：(H|h)ello：匹配 Hello、hello



#### 限定符

| 符号  | 指定字符串重复n次 | 示例    | 说明                    |
| ----- | ----------------- | ------- | ----------------------- |
| *     | n无要求           | (abc)*  | 仅包含任意个abc的字符串 |
| +     | n>=1              | m+abc   | 以至少1个m开头，后接abc |
| ?     | n=0或1            | colou?r | 匹配color和colour       |
| {i}   | n=i               | 23{3}   | 匹配2333                |
| {i,j} | i<n<j             |         |                         |



#### 定位符

| 符号 | 含义                   | 示例          | 说明                                        |
| ---- | ---------------------- | ------------- | ------------------------------------------- |
| ^    | 指定起始字符           | ^[0-9]+[a-z]* | 以至少一个数字开头，<br/>后接任意个小写字母 |
| $    | 指定结束字符           |               |                                             |
| \b   | 匹配目标字符串的边界   | 233\b         | 233233：匹配后一个233<br/>23323：匹配不到   |
| \B   | 匹配目标字符串的非边界 | 233\B         | 2333233233：匹配前两个233                   |





### 拓展

#### 分组

- (pattern)：如 (/d{2}){2}（前面括号里的是一组，一共就一组）
- (?\<name> pattern)：为组命名，可在mather.group(String name)时使用
- (?:pattern)：非捕获分组组
- (?=pattern)：非捕获分组，（ win(?=10|11) 会匹配win10和win11中的win，不会匹配win8中的win）
- (?!pattern)：非捕获分组，（ win(?!10|11) 不会匹配win10和win11中的win，会匹配win8中的win）
- (?<=pattern)：非捕获分组，（ (?<=10|11)win 会匹配10win和11win中的win，不会匹配8win中的win）
- (?<!pattern)：非捕获分组，（ (?<!10|11)win 不会匹配10win和11win中的win，会匹配8win中的win）



#### 非贪婪匹配

- 默认使用贪婪匹配
  - {非常}+："这里非常非常非常好看" -> "非常非常非常"
  - 23+："23333" -> "23333"
- 使用非贪婪匹配
  - {非常}+?："这里非常非常非常好看" -> "非常"、"非常"、"非常"
  - 23+?："23333" -> "23"



#### 反向引用

- 格式：(pattern)\组号
  - 匹配多个连续相同的字：(\w+)\1
  - 回文：(\w+)(\w+)\2\1







# SpringCloud

![springcloud](D:\picture\typora\java\springcloud.png)



## 实用篇

### 注册中心

#### 引入

- 注册 RestTemplate

  ```java
  // RestTemplete可以发送http请求
  @Bean
  public RestTemplate restTemplate(){
      return new RestTemplate();
  }
  ```

- 微服务的服务器远程调用其他服务器的接口

  ```java
  // 这是一个订单的业务接口
  @Service
  public class OrderService {
  	@Autowired
      private OrderMapper orderMapper;
      // 基于RestTemplete发送http请求
      @Autowired
      private RestTemplete restTemplete;
      
      public Order queryOrderById(Long orderId){
          Order order = orderMapper.selectById(orderId);
          String url = "http://localhost:8081/user/"+order.getUserId();
          // 发送http的GET请求，实现远程调用
          User user = restTemplate.getForObject(url, User.class);
          
          order.setUser(user);
          return order;
      }
  }
  ```

  

#### Eureka

- 在Eureka架构中，微服务角色有两类：

  - EurekaServer：服务端、注册中心
    - 记录服务信息
    - 心跳监控
  - EurekaClient：客户端
    - provider：服务提供者
      - 注册自己的信息到EurekaService
      - 每隔30秒向EurekaService发送心跳
    - consumer：服务消费者
      - 根据服务名称从EurekaService中拉去服务列表
      - 基于服务列表做负载均衡，选中一个微服务发起远程调用

- 搭建Eureka服务

  - 父工程设置依赖管理

    ```xml
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.SR10</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    ```
    
  - 子Eureka服务引依赖
  
    ```xml
    <dependency>
    	<groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>
    ```
  
  - 编写启动类，添加==@EnableEurekaServer==注解
  
  - 添加application.yml文件，编写注册配置
  
    ```yml
    server:
      port: 10086
    # 微服务的名称
    spring:
     application:
      name: eurekaserver
    # 服务地址
    eureka:
     client:
      service-url:
       defaultZone: http://127.0.0.1:10086/eureka/
    ```
  


- 服务注册

  - 依赖

    ```xml
    <dependency>
    	<groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    ```

  - 配置地址

    ```yml
    spring:
     application:
      name: userservice
    eureka:
     client:
      service-url:
       defaultZone: http://127.0.0.1:10086/eureka/
    ```

- 服务发现

  - 修改OrderService的代码，修改访问的url路径，用服务器代替ip、端口

    ```java
    String url = "http://userservice/user/"+order.getUserId();
    ```

  - 在order-service项目的RestTemplate的注册bean方法上添加负载均衡注解==@LoadBalanced==

    ```java
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
    ```

- 自我保护机制

  - 自我保护模式中，eureka会保存服务注册表中的信息，不再注销任何服务实例（当服务不再向eureka发送心跳时，eureka注册中心默认会保留信息90秒）

  - 禁止自我保护、设置保留时间

    ```yml
    eureka:
     server:
      enable-self-preservation: false
      eviction-interval-timer-in-ms: 2000
    ```

  - 心跳

    ```yaml
    eureka:
     instance:
      instance-id: customer
      # 访问路径时可以显示ip
      prefer-ip-address: true
      # Eureka客户端向服务端发送心跳的时间间隔，单位为秒（默认30秒）
      lease-renewal-interval-in-seconds: 1
      # Eureka服务端在收到最后一次心跳后等待时间上线，单位为秒（默认90秒），超时将提出
      lease-expiration-duration-in-seconds: 2
    ```



#### zookeeper



#### Nacos

##### 服务治理

- 使用步骤

  - 启动nacos的注册中心

    ```cmd
    startup.cmd -m standalone
    ```

  - 在父工程中添加spring-cloud-alibaba的管理依赖

    ```xml
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2.2.5.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    ```

  - 添加nacos的客户端依赖

    ```xml
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        <version>2.2.5.RELEASE</version>
    </dependency>
    ```

  - 配置application.yml中的nacos地址

    ```yml
    spring:
     application:
      name: customerService
     cloud:
      nacos:
       server-addr: localhost:8848
    ```

  - 注：eureka对注册的服务的名称大小写不敏感，nacos对大小写敏感

- 服务分级存储模型

  - 一级是服务，例如customerService

  - 二级是集群，例如合肥或上海

    ```yml
    spring:
     cloud:
      nacos:
       server-addr: localhost:8848
       discovery:
        cluster-name: HF # 集群名称
    ```

  - 三级是实例

- 根据集群负载均衡（在本地集群中采用随机策略）

  - 服务的提供者和消费者都设置集群

  - 在服务消费者的application.yml中配置

    ```yml
    userService:
     ribbon:
      NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule
    ```

- 环境隔离

  - 创建命名空间

  - 添加服务到该命名空间

    ```yml
    spring:
     cloud:
      nacos:
       server-addr: localhost:8848
       discovery:
        cluster-name: HF # 集群名称
        namespace: 123 # 此处填写id名
    ```

- 配置非临时实例

  - 临时实例每个一段时间会向nacos发送一次心跳，心跳停止时，nacos会直接移出该服务

  - 非临时实例是由nacos主动询问，服务停止时，会标记健康状态为false，不会移出该服务

  - application.yml

    ```yml
    spring:
     cloud:
      nacos:
       server-addr: localhost:8848
       discovery:
        cluster-name: HF # 集群名称
        namespace: 123 # 此处填写id名
        ephemeral: false # 是否是临时实例
    ```


- 与Eureka的区别
  - 共同点
    - 都支持服务注册和服务拉取
    - 都支持服务提供者心跳方式做健康检测
  - 区别
    - Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
    - 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
    - Nacos支持服务列表变更的消息推送模式，服务列表更新更及时
    - Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式



##### 配置中心

- 统一配置管理

  - 新建配置

    - Data Id：【服务器名】-【profile】.【后缀名】
    - Group：分组
    - 配置格式

  - 读取nacos配置文件

    - 项目启动后会先读取nacos中的配置文件，再读取application.yml中的配置，因此需要在bootstrap.yml中配置nacos的地址信息，才能拿到nacos的配置文件信息

    - 引入Nacos的配置管理客户端依赖

      ```xml
      <dependency>
          <groupId>com.alibaba.cloud</groupId>
          <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
      </dependency>
      ```

    - 在customerService中的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml

      ```yml
      # 微服务启动时，会读取[spring.application.name]-[spring.profiles.active].yaml，作为文件名，向Nacos查找文件
      spring:
       application:
        name: customerService # 服务名称
       profiles:
        active: dev # 开发环境
       cloud:
        nacos:
         server-addr: localhost:8848 # Nacos地址
         config:
          file-extension: yaml # 文件后缀名
      ```

- 配置热更新

  - 方式一：在用@Value读取nacos配置文件的类上加上@RefreshScope

    ```java
    @RefreshScope
    public class Test {
        @Value("${pattern.dateformat}")
        private String dateformat;
    }
    ```

  - 方式二：使用ConfigurationProperties自动刷新

    ```java
    @Component
    @Data
    @ConfigurationProperties(prefix="pattern")
    public class PatternProperties{
        private String dateformat;
    }
    ```

- 多环境的配置共享

  - 原理：微服务启动时，会读取[spring.application.name]-[spring.profiles.active].yaml，作为文件名

  - 步骤：

    - 新建配置，命名为[spring.application.name].yaml如customeService.yaml

    - 读取nacos文件

      ```yml
      spring:
       application:
        name: customerService # 服务名称
       cloud:
        nacos:
         server-addr: localhost:8848 # Nacos地址
         config:
          file-extension: yaml # 文件后缀名
      ```

  - 配置文件优先级：customer-dev.yaml > customer.yaml > 本地配置

- Nacos集群





### 负载均衡

#### Ribbon

- 负载均衡原理

  ![Ribbon](D:\picture\typora\java\Ribbon.png)

  - 服务器发送 http://customerService/customer/1
  - Ribbon负载均衡拦截此次请求
  - Ribbon负载均衡向eureka-server拉去customerService服务列表
  - 获得服务列表后，进行负载均衡，并取得服务器

- 负载均衡策略

  - 原理：负载均衡的规则是一个叫做IRule的接口来定义的，每个子接口都是一种规则

    ![IRule](D:\picture\typora\java\IRule.png)

  - 负载均衡策略

    - RandomRule：随机选择一个可用的服务器
    - RoundRobinRule：简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则
    - WeightedResponseTimeRule：为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，权重值会影响服务器的选择
    - ZoneAvoidanceRule：在指定区域中以可用的服务器为基础进行服务器的选择，而后再对Zone内的多个服务做轮询。

  - 选择策略

    - 方式一：注册一个IRule接口的bean，放在@SpringBootApplication扫描的的地方，返回对应的实现类

      ```java
      @Bean
      public IRule randomRule(){
          return new RandomRule();
      }
      ```

    - 方式二：bean放在@SpringBootApplication扫描不到的地方，用@RibbonClient注解

      ```java
      @SpringBootApplication
      @RibbonClient(name="customerService", configuration=MyselfRule.class)
      public class App {
          public static void main(String[] args) {
              SpringApplication.run(App.class, args);
          }
      }
      ```
      
    - 方式二：在order-service（服务消费者）的application.yml文件中，添加新的配置
    
      ```yml
      userservice:
       ribbon:
        NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
      ```

- 加载策略

  - Ribbon默认是采用懒加载，即第一次访问时才去创建LoadBalanceClient，第一次请求时间很长

  - 而饥饿加载则会在项目启动时创建，降低第一次访问的耗时

    ```yml
    ribbon:
     eager-load: # 饥饿加载
      enabled: true # 开启
      clients: customerService # 指定对customerService这个服务器饥饿加载
    ```

    

#### openFeign

- 基本使用

  - 引入依赖

    ```xml
    <!-- openfeign依赖携带ribbon依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
        <version>2.2.7.RELEASE</version>
    </dependency>
    ```
    
  - 启动类加==@EnableFeignClients(clients = CustomerClient.class)==
  
  - 定义和使用Feign客户端
  
    ```java
    @FeignClient("customerService(服务器名)")
    public interface CustomerClient {
        @GetMapping("/customer/{id}")
        Customer findById(@PathVariable("id") Long id);
    }
    ```
  
    ```java
    Customer customer = customerClient.findById({id});
    ```
  
- 配置

  | 类型                | 作用             | 说明                                             |
  | ------------------- | ---------------- | ------------------------------------------------ |
  | feign.Logger.Level  | 修改日志级别     | 四种级别：NONE、BASIC、HEADERS、FULL             |
  | feign.codec.Decoder | 响应结果的解析器 | 解析http远程调用结果，如解析json字符串为java对象 |
  | feign.coder.Encoder | 请求参数编码     | 将请求参数编码，便于通过http发送请求             |
  | feign.Contract      | 支出的注解格式   | 默认是SpringMVC的注解                            |
  | feign.Retryer       | 失败重试机制     | 请求失败的重试机制，默认无，但会使用Ribbon的重试 |

  - 日志配置
  
    - 配置文件，feign.client.config.xxx.loggerLevel: FULL
  
      - xxx是default，表示全局配置
      - xxx是某个服务，表示某个服务上
  
    - java代码（配置bean）
  
      ```java
      public class FeignClientConfiguration{
          @Bean
          public Logger.Level FeignLogLevel(){
              return Logger.Level.BASIC;
          }
      }
      ```
  
      - 全局：@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)
      - 局部：@FeignClient(value="customerService",configuration = FeignClientConfiguration.class)

- 性能优化

  - 原理：feign默认使用URLConnection发起请求，URLConnection不支持连接池。可改用支持链接池的HttpClient或OKHttp

  - 步骤

    - 引入HttpClient依赖

      ```xml
      <dependency>
      	<groupId>io.github.openfeign</groupId>
          <artifactId>feign-httpclient</artifactId>
      </dependency>
      ```

    - 配置连接池

      ```yaml
      feign:
       client:
        config:
         default:
          loggerLevel: BASIC # 关闭日志或使用BASIC级别可优化性能
       httpclient:
        enabled: true # 开启feign对HttpClient的支持
        max-connections: 200 # 最大连接数
        max-connection-per-route: 50 # 每个路径的最大连接数
      ```

- 超时控制

  ```yaml
  ribbon:
   # 建立连接所用的时间，使用与网络状况正常的情况下，两端连接所用的时间
   ConnectTimeout: 5000
   # 建立连接后从服务器读取到可用资源所用的时间
   ReadTimeout: 5000
  ```
  
- 最佳实践

  - 方法一

    - 原理：FeignClient("customerService")接口与CustomerController接口中的方法重复，可将其抽出成一个接口，并由上述两个接口继承这个接口
    - 问题：耦合；CustomerController接口需要覆盖重写接口中的方法

  - 方法二

    - 将Feign抽出成一个模块，供所需要的模块使用

    - 步骤

      - 首先创建一个module，命名为feign-api，然后引入feign所需的依赖
      - 将order-service中编写的CustomerClient、Customer、DefaultFeignConfiguration都复制到feign-api中
      - 在order-service中引入feign-api的依赖
      - 修改order-service中各类的import导入部分

    - 问题：当FeignClient不在SpringBootApplication的扫描范围内时，这些FeignClient无法使用。有两种解决方法

      - 指定FeignClient所在包

        ```java
        @EnableFeignClients(BasePackages="cn.Eli.feign.clients")
        ```

      - 指定FeignClient字节码

        ```java
        @EnableFeignClients(clients={CustomerClient.class})
        ```



### 服务监控与保护

#### Hystrix

##### 使用步骤

- 依赖

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
      <version>2.2.10.RELEASE</version>
  </dependency>
  ```

- 开启Hystrix：启动类加==@EnableCircuitBreaker/@EnableHystrix==

- 设置超时时间



##### 服务降级

- 服务超时或出错时的回馈

- @HystrixCommand

  ```java
  @Override
  @HystrixCommand(fallbackMethod = "customer_timeoutHandler", commandProperties = {
      @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000")
  })
  public String customer_timeout() {
      //int a = 10/0;
      int millis = 5000;
      try {
          Thread.sleep(millis);
      } catch (InterruptedException e) {
          throw new RuntimeException(e);
      }
      return "成功，延时："+millis;
  }
  
  public String customer_timeoutHandler(){
      return "失败";
  }
  ```

- orderService（消费端）也可以使用服务降级，以免请求超时

  - 打开feign的hystrix设置：在application.yml中配置

    ```yaml
    # 若在feignClient中配置服务降级，须开启以下配置
    feign:
     hystrix:
      enabled: true
      
    # 上面配置开启后，hystrix也会有一个默认超时时间，类似于ribbon
    # 区别于之前配置的ribbon超时时间，两者都要配置
    hystrix:
      command:
        default:
          execution:
            isolation:
              thread:
                timeoutInMilliseconds: 5000
    # ribbon 超时报错：Read timed out
    # hystrix 超时报错：java.util.concurrent.TimeoutException: null
    ```

  - 服务降级：orderController中使用服务降级

    - @HystrixCommand

      ```java
      @HystrixCommand(fallbackMethod = "timeoutHandler", commandProperties = {
          @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000")
      })
      @GetMapping("/timeout")
      public String timeout(){
          // 调用feignclient方法
          String str = customerClient.customer_timeout();
          return str;
      }
      
      public String timeoutHandler(){
          return "失败";
      }
      ```

  - 消费端统一配置

    - FeignClient端

      ```java
      @FeignClient("customerService", fallback = CustomerFallbackClient.class)
      public interface CustomerClient {
          @GetMapping("/customer/{id}")
          Customer findById(@PathVariable int id);
      
          @GetMapping("/customer/timeout")
          String customer_timeout();
      }
      ```

    - 统一配置降级类

      ```java
      @Component
      public class CustomerFallbackClient implements CustomerClient{
          @Override
          public Customer findById(int id){
              return null;
          }
          
          @Override
          public String customer_timeout(){
              return "失败";
          }
      }
      ```

- 另外，统一配置降级还可以使用：@DefaultProperties(defaultFallback = "defaultMethod")，加在类上，用于向该类中加了@HystrixCommand但未指定处理方法的方法指定默认处理方法



##### 服务熔断

- 熔断

  ```java
  @Override
  @HystrixCommand(fallbackMethod = "customer_breakHandler", commandProperties = {
      @HystrixProperty(name = "circuitBreaker.enabled", value = "true"), // 是否开启断路器
      @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "10"), // 请求次数默认20
      @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "5000"), // 拒绝请求时间，默认5000
      @HystrixProperty(name = "circuitBreaker.timeInMilliseconds", value = "10000"), // 时间窗口（内部时钟），默认10000
      @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "60") // 失败率达到60%后跳闸，默认50
  })
  public String customer_break(int id) {
      if (id < 0){
          throw new RuntimeException("id不能为负数");
      }
      String uuid = UUID.randomUUID().toString();
      return "成功，流水号："+uuid;
  }
  
  public String customer_breakHandler(int id){
      return "失败";
  }
  ```

- 熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间），当打开时长达到所设置时钟则进入半熔断状态
- 熔断关闭：
- 熔断半开：部分请求根据规则调用当前服务，如果请求成功且复合规则默认认为当前服务恢复正常，关闭熔断



##### 服务监控

- 新建一个springboot模块

- 引入依赖

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
      <version>2.2.10.RELEASE</version>
  </dependency>
  <!-- 监控依赖 -->
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
  </dependency>
  ```

- 配置端口

- 主启动类添加==@EnableHystrixDashboard==

- 所有微服务提供类需要添加监控依赖配置






#### Sentinel

##### 使用步骤

- 下载启动 sentinel-dashboard-1.8.6.jar

  - docker pull bladex/sentinel-dashboard
  - docker run --name sentinel -p 8858:8858 -td bladex/sentinel-dashboard

- 导入依赖

  ```xml
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
  </dependency>
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
  </dependency>
  ```
  
- application.yml

  ```yaml
  server:
    port: 8401
  
  spring:
    application:
      name: sentinel-customerService
    cloud:
      nacos:
        discovery:
          server-addr: 192.168.36.131:8848
      sentinel:
        transport:
          dashboard: 192.168.336.131:8858
          # 默认端口8719，假如被占用会自动从8719开始依次+1扫描未被占用端口
          port: 8719
  
  management:
    endpoints:
      web:
        exposure:
          include: '*'
  
  # 若使用openFeign的fallback类须开启以下配置
  feign:
    sentinel:
      enabled: true
  ```
  
  

##### 流控规则

- 资源名：唯一名称，默认请求路径
- 针对来源：Sentinel可以针对调用者进行限流
- 阈值类型/单机阈值
  - QPS（每秒的请求数量）：当调用该api的QPS达到阈值时进行限流
  - 线程数：当调用该api的线程数达到阈值时，进行限流
- 是否集群
- 流控模式：
  - 直接：api达到限流条件时，直接限流
  - 关联：当关联的资源达到阈值时，限流自己
  - 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）
- 流控效果：
  - 快速失败：直接失败，抛异常
  - Warm Up：根据codeFactory（冷加载因子，默认3）的值，经过预热时长，才达到QPS阈值
  - 排队等待：



##### 流控降级

- 资源名
- 熔断策略
  - RT（慢调用比例）
  - 异常比例
  - 异常数
- 比例阈值
- 熔断时间
- 最小请求数



##### 热点规则

- java

  - ```java
    @GetMapping("/hotKey")
    @SentinelResource(value = "hotKey", blockHandler = "deal_testHotKey")
    public String getForHotKey(
        @RequestParam(value = "p1", required = false) String p1,
        @RequestParam(value = "p2", required = false) String p2
    ) {
        return "------testHotKey:   p1->"+p1+"  p2->"+p2;
    }
    public String deal_testHotKey(String p1, String p2, BlockException blockException) {
        return "-------deal_hotkey";
    }
    ```
  
- 图形化配置

  - 资源名
  - 参数索引：java代码中的索引号参数
  - 单机阈值
  - 统计窗口期
  - 参数例外项：指定参数值为某个特定值时，可单独指定该值的限流阈值



##### 系统规则

- 阈值类型
  - Load
  - RT
  - 线程数
  - 入口QPS
  - cpu使用率



##### 授权规则

若请求从gateway转发来的，则可以访问，否则，不能访问

- 请求通过网关时，添加origin的请求头，可设置其值为gateway

  ```yml
  spring:
    cloud:
      gateway:
        default-filters:
          - AddRequestHeader=origin,gateway
  ```

- 重写解析方法，判断是否带有origin的请求头

  - Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的

    ```java
    public interface RequestOriginParser {
        String parseOrigin(HttpServletRequest request);
    }
    ```

  - 例如，尝试从request中获取一个名为origin的请求头，并返回授权规则

    ```java
    @Component
    public class HeaderOriginParser implements RequestOriginParser {
        @Override
        public String parseOrigin(HttpServletRequest request) {
            String origin = request.getHeader("origin");
            if(StringUtils.isEmpty(origin)) {
                return "blank";
            }
            return origin;
        }
    }
    ```

- 填写白名单：流控应用填写 gateway



##### @SentinelResource

- value：资源名

- blockHandlerClass：指定规则处理类

- blockHandler：指定规则处理方法，该方法只会 在控制台上配置的问题产生时 调用

- fallbackClass：指定异常处理类

- fallback：指定异常处理方法，该方法会 在java代码出现异常时 调用

  - ```java
    @GetMapping("/fallback/{number1}/{number2}")
    @SentinelResource(value = "fallback", fallback = "deal_fallback")
    public String getForFallback(@PathVariable("number2") int number2,
                                 @PathVariable("number1") int number1) {
        if (number2 == -1) {
            throw new RuntimeException("请求非法");
        }
        return "number 值为："+number1;
    }
    public String deal_fallback(int number2, int number1, Throwable throwable) {
        return "number2的值为 "+number2+"  ->  "+throwable.getMessage();
    }
    ```

- fallback和blockHandler两者都配置：规则归blockHandler处理，异常归fallback处理

- exceptionToIgnore：忽略指定异常的处理



##### 配置持久化

- 依赖

  - ```xml
    <dependency>
        <groupId>com.alibaba.csp</groupId>
        <artifactId>sentinel-datasource-nacos</artifactId>
    </dependency>
    ```

- yaml配置

  - ```yaml
    spring:
      application:
        name: customerServer-sentinel
      cloud:
        nacos:
          server-addr: 192.168.36.132:8848
        sentinel:
          transport:
            port: 8720
            dashboard: 192.168.36.132:8858
          # 用于配置持久化到nacos上
          datasource:
            ds1:
              nacos:
                server-addr: 192.168.36.132:8848
                data-id: ${spring.application.name}
                group-id: DEFAULT_GROUP
                data-type: json
                rule-type: flow
    ```

- nacos新建配置

  - Data ID：customerServer-sentinel

  - 格式配置：json

  - 配置内容

    - 配置

      - resource：资源名
      - limitApp：来源应用
      - grade：阈值类型，0表示线程数，1表示QPS
      - count：单机阈值
      - strategy：流控模式，0表示直接，1表示关联，2表示链路
      - controlBehavior：流控效果，0表示快速失败，1表示Warm up，2表示排队等待
      - clusterMode：是否集群

    - ```json
      [
          {
              "resource": "/customer/{id}",
              "limitApp": "default",
              "grade": 1,
              "count": 1,
              "strategy": 0,
              "controlBehavior": 0,
              "clusterMode": false
          }
      ]
      ```

      





### 服务网关

#### Gateway

- 基础使用

  - 引入依赖

    ```xml
    <!-- springboot版本用2.3.9.RELEASE -->
    <!-- jdk用8 -->
    
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <!-- gateway也是一项微服务，需要nacos服务发现依赖 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    ```
  
    注：spring-boot-starter-web依赖与gateway中的spring-boot-starter-webflux依赖冲突
  
  - 启动类
  
  - 配置
  
    ```yaml
    server:
      port: 80
    spring:
      application:
        name: gateway
      cloud:
        nacos:
          server-addr: 192.168.36.131:8848
        gateway:
          discovery:
            locator:
            # 开启注册中心动态创建路由的功能，利用微服务名进行路由
            enabled: true
            # eureka 自动大写服务名时，可开启
            #lowerCaseServiceId: true
          routes:
            - id: customer-service # 路由id，自定义，唯一
              # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址
              uri: lb://customerService # lb是loadBalance，后面跟服务名
              predicates: # 路由断言，是否符合下面规则
                - Path=/customer/** # 按路径匹配
            - id: order-service
              uri: lb://orderService
              predicates:
                - Path=/order/**
              #filters:
                #- StripPrefix=1
    ```
  
- 断言工厂

  - Path

    - ```yml
      predicates:
        - Path=/order/**
      ```

  - 其他断言

    - ```yml
      predicates:
        - Path=/order/**
        # 时间格式：2022-01-01T00:00:00.000+08:00[Asia/Shanghai]
        - After=时间
        - Before=时间
        - Between=时间A,时间B
        
        # 前一个为键名，后一个为正则表达式
        # 携带键值对为 username=zzyy 的cookie
        - Cookie=username, zzyy
        # 携带一个键为 X-Request-Id, 值为整数的Header
        - Header=X-Request-Id, \d+
        - Host=**.baidu.com
        - Method=Get
        # 携带userId=整数的参数 http://localhost/order/userId=3
        - Query=userId, \d+
      ```

- 过滤器

  - 全局过滤器

  - 自定义过滤器

    - ```java
      @Component
      public class MyGatewayFilter implements GlobalFilter, Ordered {
          @Override
          public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
              System.out.println("filter执行了。。。");
              if (!exchange.getRequest().getPath().toString().contains("order")) {
                  exchange.getResponse().setStatusCode(HttpStatus.NOT_FOUND);
                  return exchange.getResponse().setComplete();
              }
              return chain.filter(exchange);
          }
      
          /**
           * 加载过滤器的顺序
           * @return 数字越小优先级越高
           */
          @Override
          public int getOrder() {
              return 0;
          }
      }
      ```

      








### Docker

#### 安装

- 卸载docker

  ```shell
  yum remove docker \
                    docker-client \
                    docker-client-latest \
                    docker-common \
                    docker-latest \
                    docker-latest-logrotate \
                    docker-logrotate \
                    docker-selinux \
                    docker-engine-selinux \
                    docker-engine \
                    docker-ce
  ```

- 安装

  - 安装yum工具

    ```shell
    yum install -y yum-utils \
               device-mapper-persistent-data \
               lvm2 --skip-broken
    ```

  - 配置docker的yum源：告诉linux去哪下载

    ```shell
    yum-config-manager \
        --add-repo \
        https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
        
    sed -i 's/download.docker.com/mirrors.aliyun.com\/docker-ce/g' /etc/yum.repos.d/docker-ce.repo
    
    yum makecache fast
    ```

  - 安装docker-ce（社区版）

    ```shell
    yum install -y docker-ce
    ```

- 启动docker

  - 关闭防火墙

    ```shell
    # 关闭
    systemctl stop firewalld
    # 禁止开机启动防火墙
    systemctl disable firewalld
    ```

  - 启动docker

    ```shell
    systemctl start docker  # 启动docker服务
    
    systemctl stop docker  # 停止docker服务
    
    systemctl restart docker  # 重启docker服务
    ```

- 镜像加速

  - 参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors

    ```shell
    sudo mkdir -p /etc/docker
    sudo tee /etc/docker/daemon.json <<-'EOF'
    {
      "registry-mirrors": ["https://18madm2u.mirror.aliyuncs.com"]
    }
    EOF
    sudo systemctl daemon-reload
    sudo systemctl restart docker
    ```

    

#### 使用

- 镜像操作

  - 镜像拉取：docker pull
  - 查看镜像：docker images
  - 删除镜像：docker rmi
  - 构建镜像：docker build
  - 保存镜像：docker save
  - 加载镜像：docker load

- 容器状态

  - 运行镜像：docker run
    - -d：后台运行
    - -p：端口映射
    - -e：添加配置信息
    - --name：容器名
    - docker run --name mysql_5.7 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7
  - 暂停容器：docker pause
  - 恢复容器：docker unpause
  - 停止容器：docker stop
  - 开启容器：docker start

- 容器操作

  - 进入容器：docker exec
    - docker exec -it mysql_5.7 bash
  - 查看容器运行日志：docker [container] logs 容器名
  - 默认查看所有运行容器及状态：docker ps
  - 删除容器：docker rm

- 数据卷 docker volume [COMMAND]

  - create：创建一个volume
  - inspect：显示一个或多个volume的信息
  - ls：列出所有的volume
  - prune：删除未使用的volume

- 挂载

  - 数据卷挂载

    ```shell
    docker run --name myNginx \
    	-v html:/root/html \ # 把html数据卷挂载到容器内的/root/html这个目录中
    	-p 8080:80 \ # 把宿主机的8080端口映射到容器内的80端口上
        nginx 
    ```

  - 目录挂载（宿主机目录、文件未提前创建会自动创建目录，不会创建文件）

    - -v [宿主机目录]:[容器内目录]
    - -v [宿主机文件]:[容器内文件]

    ```shell
    docker run --name mysql_5.7 \
    	-e MYSQL_ROOT_PASSWORD=root \
    	-p 3306:3306 \
    	-v /var/docker-volume/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf \
    	-v /var/docker-volume/mysql/data:/var/lib/mysql \
    	-d mysql:5.7
    ```

    

#### 自定义镜像

- 指令

  - FROM：指定基础镜像
  - ENV：设置环境变量，可在后面指令使用
  - COPY：拷贝本地文件到镜像的指定目录
  - RUN：执行Linux的shell命令，一般是安装过程的命令
  - EXPOSE：指定容器运行时监听的端口，供镜像使用者查看
  - ENTRYPOINT：镜像中应用的启动命令，容器运行时调用

- 基于Ubuntu构建Dockerfile文件

  ```dockerfile
  # 指定基础镜像
  FROM ubuntu:16.04
  
  # 配置环境变量，JDK的安装目录
  ENV JAVA_DIR=/usr/local
  
  # 拷贝jdk和java的项目包
  COPY ./jdk-17.0.4.1_linux-x64_bin.tar.gz $JAVA_DIR/
  COPY ./java-demo-1.0-SNAPSHOT.jar /tmp/app.jar
  
  # 安装JDK
  RUN cd $JAVA_DIR && tar -xf ./jdk-17.0.4.1_linux-x64_bin.tar.gz && mv ./jdk-17.0.4.1 ./java17
  
  # 配置环境变量
  ENV JAVA_HOME=$JAVA_DIR/java17
  ENV PATH=$PATH:$JAVA_HOME/bin
  
  # 暴露端口
  EXPOSE 80
  
  # 入口，java项目的启动命令
  ENTRYPOINT java -jar /tmp/app.jar
  ```

- 基于java:8-alpine镜像

  ```dockerfile
  FROM java:8-alpine
  COPY ./docker-demo.jar /tmp/app.jar
  EXPOSE 8080
  ENTRYPOINT java -jar /tmp/app.jar
  ```

- 构建镜像

  ```shell
  docker build -t javaweb:1.0 .
  # -t t是tag（javaweb:1.0是一个tag）
  # . 表示dockerfile所在的目录
  ```



#### 运行镜像

- ubuntu：docker run -itd --name ubuntu ubuntu

- redis
  
  - 创建文件夹
  
    ```shell
    mkdir -p /var/docker-volume/redis/conf
    touch /var/docker-volume/redis/conf/redis.conf
    mkdir -p /var/docker-volume/redis/data
    ```
  
  - 运行镜像
  
    ```shell
    docker run -p 6379:6379 --name redis \
    -v /var/docker-volume/redis/data:/data \
    -v /var/docker-volume/redis/conf/redis.conf:/etc/redis/redis.conf \
    -d redis \
    redis-server /etc/redis/redis.conf \
    appendonly yes
    ```
  
  - redis-server /etc/redis/redis.conf  以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/docker/redis.conf
  
  - appendonly yes 开启redis 持久化
  
- mysql:5.7

  - 创建文件夹

    ```shell
    mkdir -p /var/docker-volume/mysql/log
    mkdir -p /var/docker-volume/mysql/data
    mkdir -p /var/docker-volume/mysql/conf
    ```

  - 运行镜像

    ```shell
    docker run -p 3306:3306 --name mysql \
    	-v /var/docker-volume/mysql/log:/var/log/mysql \
    	-v /var/docker-volume/mysql/data:/var/lib/mysql \
    	-v /var/docker-volume/mysql/conf:/etc/mysql \
    	-e MYSQL_ROOT_PASSWORD=root \
    	-d mysql:5.7
    ```
    
  - 添加配置文件conf目录下添加my.cnf文件

    ```ini
    [mysqld]
    # 跳过域名解析
    skip-name-resolve
    character_set_server=utf8
    datadir=/var/lib/mysql
    server-id=1000
    ```

- nginx

  - 创建挂载目录

    ```shell
    mkdir -p /var/docker-volume/nginx/conf
    mkdir -p /var/docker-volume/nginx/log
    mkdir -p /var/docker-volume/nginx/html
    ```

  - 复制文件到挂载目录

    ```shell
    # 先生成容器
    docker run --name nginx -p 9999:80 -d nginx
    
    # 复制容器中的文件到挂载目录
    docker cp nginx:/etc/nginx/nginx.conf /var/docker-volume/nginx/conf/nginx.conf
    docker cp nginx:/etc/nginx/conf.d /var/docker-volume/nginx/conf/conf.d
    docker cp nginx:/usr/share/nginx/html /var/docker-volume/nginx/
    ```

  - 移除nginx容器后重新运行

    ```shell
    docker run --name nginx ...
    ```

    







### RabbitMQ

#### 安装

- 拉去镜像

  ```shell
  docker pull rabbitmq
  ```

- 启动

  ```shell
  docker run \
   -e RABBITMQ_DEFAULT_USER=eli \
   -e RABBITMQ_DEFAULT_PASS=root \
   --name mq \
   --hostname mql \
   -p 15672:15672 \
   -p 5672:5672 \
   -d rabbitmq
  ```

- 进入容器，开启web管理

  ```shell
  docker exec -it mq bash
  ```

  ```shell
  rabbitmq-plugins enable rabbitmq_management
  ```




#### 快速入门

- 导入依赖

  ```xml
  <!--AMQP依赖，包含RabbitMQ-->
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
  </dependency>
  ```

- 发布者

  ```java
  // 引入com.rabbitmq.client的类
  @Test
  public void testSendMessage() throws IOException, TimeoutException {
      // 1.建立连接
      ConnectionFactory factory = new ConnectionFactory();
      // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码
      factory.setHost("192.168.36.131");
      factory.setPort(5672);
      factory.setVirtualHost("/");
      factory.setUsername("eli");
      factory.setPassword("root");
      // 1.2.建立连接
      Connection connection = factory.newConnection();
  
      // 2.创建通道Channel
      Channel channel = connection.createChannel();
  
      // 3.创建队列
      String queueName = "simple.queue";
      channel.queueDeclare(queueName, false, false, false, null);
  
      // 4.发送消息
      String message = "hello, rabbitmq!";
      channel.basicPublish("", queueName, null, message.getBytes());
      System.out.println("发送消息成功：【" + message + "】");
  
      // 5.关闭通道和连接
      channel.close();
      connection.close();
  }
  ```

- 接收者

  ```java
  // 引入com.rabbitmq.client的类
  public class ConsumerTest {
      public static void main(String[] args) throws IOException, TimeoutException {
          // 1.建立连接
          ConnectionFactory factory = new ConnectionFactory();
          // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码
          factory.setHost("192.168.36.131");
          factory.setPort(5672);
          factory.setVirtualHost("/");
          factory.setUsername("eli");
          factory.setPassword("root");
          // 1.2.建立连接
          Connection connection = factory.newConnection();
  
          // 2.创建通道Channel
          Channel channel = connection.createChannel();
  
          // 3.创建队列
          String queueName = "simple.queue";
          channel.queueDeclare(queueName, false, false, false, null);
  
          // 4.订阅消息
          channel.basicConsume(queueName, true, new DefaultConsumer(channel){
              @Override
              public void handleDelivery(String consumerTag, Envelope envelope,
                                         AMQP.BasicProperties properties, byte[] body) throws IOException {
                  // 5.处理消息
                  String message = new String(body);
                  System.out.println("接收到消息：【" + message + "】");
              }
          });
          System.out.println("等待接收消息。。。。");
      }
  }
  ```
  
  

#### SpringAMQP

- 准备

  - 依赖

    ```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>
    ```

  - 基础配置文件

    ```yml
    spring:
      rabbitmq:
        host: 192.168.36.132
        port: 5672
        virtual-host: /
        username: eli
        password: root
    ```

  - 发布测试类

    ```java
    @SpringBootTest
    public class Publisher {
        @Autowired
        private RabbitTemplate rabbitTemplate;
        // 测试
    }
    ```

- 类型一

  ![one](D:\picture\typora\java\rabbitmq\one.png)

  - 发送

    ```java
    @Test
    public void test01(){
        String queueName = "simple.queue";
        String message = "hello, spring amqp!";
        rabbitTemplate.convertAndSend(queueName, message);
    }
    ```

  - 接收

    ```java
    @Component
    public class SpringRabbitListener {
        @RabbitListener(queues = "simple.queue")
        public void listen01(String msg)throws InterruptedException {
            System.out.println("接收到消息：【" + msg + "】");
        }
    }
    ```

    

- 类型二

  ![two](D:\picture\typora\java\rabbitmq\two.png)

  - 发送

  - 接收

    - 多个consumer：多个@RabbitListener

    - 配置文件

      ```yaml
      spring:
        rabbitmq:
          host: 192.168.36.131
          port: 5672
          virtual-host: /
          username: eli
          password: root
          listener:
            simple:
              prefetch: 1 # 预处理机制，每次只获取一条消息
      ```

      

- 类型三

  ![three](D:\picture\typora\java\rabbitmq\three.png)

  - 发送到交换机

    ```java
    @Test
    public void test02(){
        String exchangeName = "eli.fanout";
        String message = "hello, everyone!";
        rabbitTemplate.convertAndSend(exchangeName, "", message);
    }
    ```

  - 交换机：fanout（广播）

    ```java
    // 基于配置类声明交换机
    @Configuration
    public class FanoutConfig {
        // 声明FanoutExchange交换机
        @Bean
        public FanoutExchange fanoutExchange(){
            return new FanoutExchange("eli.fanout");
        }
    
        // 声明第一个队列
        @Bean
        public Queue fanoutQueue1(){
            return new Queue("fanout.queue1");
        }
        
        // 绑定队列一和交换机
        @Bean
        public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){
            return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
        }
        
        // 声明并绑定其他队列
    }
    ```

  - 接收



- 类型四

  ![four](D:\picture\typora\java\rabbitmq\four.png)

  - 发送

    ```java
    @Test
    public void test03(){
        String exchangeName = "eli.direct";
        String key = "blue";
        String message = "hello, "+key;
        rabbitTemplate.convertAndSend(exchangeName, key, message);
    }
    ```

  - 交换机：direct（路由）

  - 接收

    ```java
    // 基于注解声明交换机
    @RabbitListener(bindings = @QueueBinding(
        value = @Queue(name = "direct.queue1"), // 定义队列
        exchange = @Exchange(name = "eli.direct", type = ExchangeTypes.DIRECT), // 定义交换机
        key = {"red","blue"} //绑定关键词
    ))
    public void Listen04(String msg)throws InterruptedException {
        System.out.println("4接收到消息：【" + msg + "】");
    }
    ```



- 类型五

  ![five](D:\picture\typora\java\rabbitmq\five.png)

  - 发送

    ```java
    @Test
    public void test04(){
        String exchangeName = "eli.topic";
        String key = "china.news.dir";
        rabbitTemplate.convertAndSend(exchangeName, key, key);
    }
    ```

  - 交换机：topic（话题）

  - 接收

    ```java
    // 基于注解声明交换机
    @RabbitListener(bindings = @QueueBinding(
        value = @Queue(name = "topic.queue1"), // 定义队列
        exchange = @Exchange(name = "eli.topic", type = ExchangeTypes.TOPIC), // 定义交换机
        key = {"china.#"} //绑定关键词
    ))
    public void Listen04(String msg)throws InterruptedException {
        System.out.println("4接收到消息：【" + msg + "】");
    }
    ```

- 交换机exchange负责消息路由，不负责存储，路由失败则消息消失

- 如果传输对象消息，默认序列化后再传输，该方法传出数据较大，可改用json

  - 在发送、接收服务引入依赖

    ```xml
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>
    ```

  - 在发送、接收服务声明MessageConverter

    ```java
    //import org.springframework.amqp.support.converter.MessageConverter;
    
    @Bean
    public MessageConverter messageConverter(){
        return new Jackson2JsonMessageConverter();
    }
    ```

  - 接收

    ```java
    @Component
    public class SpringRabbitListener {
        @RabbitListener(queues = "simple.queue")
        // 形参传递对应的对象类型
        public void Listen01(Obj obj)throws InterruptedException {
        }
    }
    ```







## 高级篇

### 分布式事务

- CAP定理
  - 分布式系统节点通过网络连接，一定会出现分区问题（P）
  - 当分区问题出现时，系统的一致性（C）和可用性（A）就无法同时满足
- BASE理论
  - Basically Available：基本可用，允许损失部分可用性，即保证核心可用
  - Soft State：软状态，允许出现中间状态，如临时的不一致状态
  - Eventually Consistent：最终一致性



#### seata

##### 部署

- 前置操作

  - 下载http://seata.io/zh-cn/blog/download.html

- 修改conf目录下的registry.conf文件

  ```properties
  registry {
    # 配置中心 file 、nacos 、eureka、redis、zk、consul、etcd3、sofa
    type = "nacos"
  
    nacos {
      application = "seata--server"
      serverAddr = "127.0.0.1:8848"
      group = "DEFAULT_GROUP"
      namespace = ""
      # 集群名称
      cluster = "default"
      username = ""
      password = ""
    }
  }
  
  config {
    type = "nacos"
    nacos {
      serverAddr = "127.0.0.1:8848"
      namespace = ""
      group = "SEATA_GROUP"
      username = ""
      password = ""
      dataId = "seataServer.properties"
    }
  }
  ```

- 在nacos中添加配置

  - DataId：seataServer.properties

  - Group：SEATA_GROUP

  - 配置格式：properties

  - 配置内容

    ```properties
    # 数据存储方式，db代表数据库
    store.mode=db
    store.db.datasource=druid
    store.db.dbType=mysql
    store.db.driverClassName=com.mysql.jdbc.Driver
    store.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&rewriteBatchedStatements=true
    store.db.user=root
    store.db.password=123
    store.db.minConn=5
    store.db.maxConn=30
    store.db.globalTable=global_table
    store.db.branchTable=branch_table
    store.db.queryLimit=100
    store.db.lockTable=lock_table
    store.db.maxWait=5000
    # 事务、日志等配置
    server.recovery.committingRetryPeriod=1000
    server.recovery.asynCommittingRetryPeriod=1000
    server.recovery.rollbackingRetryPeriod=1000
    server.recovery.timeoutRetryPeriod=1000
    server.maxCommitRetryTimeout=-1
    server.maxRollbackRetryTimeout=-1
    server.rollbackRetryTimeoutUnlockEnable=false
    server.undo.logSaveDays=7
    server.undo.logDeletePeriod=86400000
    
    # 客户端与服务端传输方式
    transport.serialization=seata
    transport.compressor=none
    # 关闭metrics功能，提高性能
    metrics.enabled=false
    metrics.registryType=compact
    metrics.exporterList=prometheus
    metrics.exporterPrometheusPort=9898
    ```

- 新建表

  ```sql
  SET NAMES utf8mb4;
  SET FOREIGN_KEY_CHECKS = 0;
  
  -- ----------------------------
  -- 分支事务表
  -- ----------------------------
  DROP TABLE IF EXISTS `branch_table`;
  CREATE TABLE `branch_table`  (
    `branch_id` bigint(20) NOT NULL,
    `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
    `transaction_id` bigint(20) NULL DEFAULT NULL,
    `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `status` tinyint(4) NULL DEFAULT NULL,
    `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `gmt_create` datetime(6) NULL DEFAULT NULL,
    `gmt_modified` datetime(6) NULL DEFAULT NULL,
    PRIMARY KEY (`branch_id`) USING BTREE,
    INDEX `idx_xid`(`xid`) USING BTREE
  ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;
  
  -- ----------------------------
  -- 全局事务表
  -- ----------------------------
  DROP TABLE IF EXISTS `global_table`;
  CREATE TABLE `global_table`  (
    `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
    `transaction_id` bigint(20) NULL DEFAULT NULL,
    `status` tinyint(4) NOT NULL,
    `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `timeout` int(11) NULL DEFAULT NULL,
    `begin_time` bigint(20) NULL DEFAULT NULL,
    `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `gmt_create` datetime NULL DEFAULT NULL,
    `gmt_modified` datetime NULL DEFAULT NULL,
    PRIMARY KEY (`xid`) USING BTREE,
    INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE,
    INDEX `idx_transaction_id`(`transaction_id`) USING BTREE
  ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;
  
  SET FOREIGN_KEY_CHECKS = 1;
  ```

- 通过bin目录下的指令启动seata



##### 集成

- 引入依赖

  ```xml
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
      <!-- 排除版本较低的依赖 -->
      <exclusions>
          <exclusion>
              <groupId>io.seata</groupId>
              <artifactId>seata-spring-boot-starter</artifactId>
          </exclusion>
      </exclusions>
  </dependency>
  <!-- 添加1.4.2版本依赖 -->
  <dependency>
      <groupId>io.seata</groupId>
      <artifactId>seata-spring-boot-starter</artifactId>
      <version>${seata.version}</version>
  </dependency>
  ```

- 基于注册中心获取tc服务地址

  ```yaml
  seata:
    registry:
      type: nacos
      nacos:
        server-addr: 127.0.0.1:8848
        namespace: "" # 空表示public命名空间
        group: DEFAULT_GROUP
        application: seata-tc-server
        username:
        password:
    tx-service-group: seata-demo # 事务组，根据这个获取tc服务的cluster名称
    service:
      vgroup-mapping: # 事务组与TC服务cluster的映射关系
        seata-demo: SH
  ```

  



#### 模式

##### XA

- 阶段

  - 一阶段：事务协调者通知事务参与者（RM）执行各自事务，执行后不提交事务并将结果告知事务协调者
  - 二阶段：
    - 若都成功，则告知事务参与者提交事务
    - 否则，则告知事务参与者回滚事务

- 总结

  - 优点
    - 事务的强一致性，满足ACID原则
    - 常用数据库都支持，实现简单，并且没有代码侵入

  - 缺点
    - 因为一阶段需要锁定数据库资源，二阶段结束才释放，性能差
    - 依赖关系型数据库实现事务

- Seata的stater已经完成了XA模式的自动装配，实现非常简单，步骤如下：

  - 修改application.yml文件（每个事务参与者的微服务），开启XA模式

    ```yml
    seata:
      data-source-proxy-mode: XA
    ```

  - 给发起全局事务的入口方法添加@GlobalTransactional注解，本例中是OrderServiceImpl中的create方法

    ```java
    @Override
    @GlobalTransactional
    public Long create(Order order) {
        // 创建订单
        orderMapper.insert(order);
        // 扣减余额
        // 扣减库存
        return order.getId();
    }
    ```



##### AT

- 阶段

  - 一阶段
    - 注册分支事务
    - 记录undo-log（数据快照）
    - 执行业务sql并**提交**
    - 报告事务状态
  - 二阶段
    - 全部成功：异步删除undo-log
    - 存在失败：根据undo-log恢复数据，再删除undo-log

- 总结：弱一致

- 脏数据问题

  - 描述：第一个事务获得DB锁，记录快照，修改数据，释放DB锁后，在等待其他分支事务执行的过程中，第二个事务又修改了该数据，而其他分支事务执行失败，所有事务都要回滚，此时第一个事务根据快照恢复事务是错误的
  - seata内部实现一个全局锁，由seata管理的事务需要获取到该锁才能执行。
    - 若第二个seata事务获取到db锁后，未获取到全局锁，会进行重试，重试一定次数后，会失败（若一直重试，第二个seata事务因无法获取全局锁执行业务而不能释放db锁，第一个seata事务因无法获取db锁而不能修改数据，会一直占用全局锁，从而形成死锁）
    - 若第二个事务并非seata管理，其不需要获取全局锁，进而产生脏数据问题
      - 解决：记录快照时，会记录两份快照，一份是执行前的快照，一份是执行后的快照，执行前的快照用于恢复数据，执行后的快照用于比对数据。在恢复数据前，比对执行后的快照与现在的数据是否一致，若一致，恢复数据，若不一致，则说明出现脏数据问题，可转由人工处理

- 使用

  - 因为快照和全局锁都是通过数据库实现的，因此需要导入两张表

    - 全局锁的表（lock_table）是由tc实现的，要导入tc的关联数据库中

      ```sql
      DROP TABLE IF EXISTS `lock_table`;
      CREATE TABLE `lock_table`  (
        `row_key` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
        `xid` varchar(96) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
        `transaction_id` bigint(20) NULL DEFAULT NULL,
        `branch_id` bigint(20) NOT NULL,
        `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
        `table_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
        `pk` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
        `gmt_create` datetime NULL DEFAULT NULL,
        `gmt_modified` datetime NULL DEFAULT NULL,
        PRIMARY KEY (`row_key`) USING BTREE,
        INDEX `idx_branch_id`(`branch_id`) USING BTREE
      ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;
      
      ```

    - 快照的表（undo_log）是由rm实现的，要导入rm的关联的数据库中

      ```sql
      DROP TABLE IF EXISTS `undo_log`;
      CREATE TABLE `undo_log`  (
        `branch_id` bigint(20) NOT NULL COMMENT 'branch transaction id',
        `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'global transaction id',
        `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'undo_log context,such as serialization',
        `rollback_info` longblob NOT NULL COMMENT 'rollback info',
        `log_status` int(11) NOT NULL COMMENT '0:normal status,1:defense status',
        `log_created` datetime(6) NOT NULL COMMENT 'create datetime',
        `log_modified` datetime(6) NOT NULL COMMENT 'modify datetime',
        UNIQUE INDEX `ux_undo_log`(`xid`, `branch_id`) USING BTREE
      ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'AT transaction mode undo table' ROW_FORMAT = Compact;
      ```

  - 修改application.yml文件（每个事务参与者的微服务），开启AT模式

    ```yaml
    seata:
      data-source-proxy-mode: AT
    ```

  - 入口添加注解@GlobalTransactional



##### TCC

- TCC模式与AT模式相似，每个阶段都是独立的事务，不同的是TCC通过人工编码来实现数据的恢复。需要实现三个方法
  - Try：资源的检测和预留
  - Confirm：完成资源操作业务；要求Try成功，Confirm一定要能成功
  - Cancel：预留资源的释放；要求Try失败，Cancel一定要能成功
- 总结：弱一致，性能好，不依赖于数据库，每项事务各自独立不需要锁

- 使用：以订单扣款为例

  - 需求

    - 修改account-service，编写try、confirm、cancel逻辑
      - try业务：添加冻结金额，扣减可用金额
      - confirm业务：删除冻结金额
      - cancel业务：删除冻结金额，恢复可用金额
      - 保证confirm、cancel接口的幂等性
    - 空回滚：当某个分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不应该做回滚
    - 业务悬挂：对于已经空回滚的业务，如果阻塞结束，可能会继续执行try操作，但此时分布式事务已经结束。因此应当阻止空回滚后的try操作，避免业务悬挂
    - 综上：创建冻结金额表，添加事务id、用户id、冻结金额、事务状态 字段
      - RootContext.getXID()：可获得事务id

  - 添加并实现接口

    ```java
    @LocalTcc
    public interface TCCService {
        @TwoPhaseBusinessAction(name="prepare", commitMethod="confirm", rollbackMethod="cancel")
        // 该注解修饰的参数可在下面BusinessActionContext对象中获取
        void prepare(@BusinessActionContextParameter(paramName="param") String param);
        
        // context.getXid()也可获取事务id
        boolean confirm (BusinessActionContext context);
        
        boolean cancel (BusinessActionContext context);
    }
    ```

    ```java
    public class TCCServiceImpl implements TCCService{
        @Override
        // 设计到原始用户表和冻结金额表两张表数据的修改，要添加事务管理
        @Transactional
        public void prepare(String param) {
            // 。。。
        }
    
        @Override
        public boolean confirm(BusinessActionContext context) {return false;}
    
        @Override
        public boolean cancel(BusinessActionContext context) {return false;}
    }
    ```

    

##### SAGA

- 阶段
  - 一阶段：直接提交本地事务
  - 二阶段：成功则什么也不做；失败则通过编写补偿业务来回滚
- 总结：最终一致、性能好、无锁可能存在脏数据问题

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                



### 缓存

![多级缓存](D:\picture\typora\java\多级缓存.png)

#### Caffeine

- 是JVM进程缓存的框架

- 快速入门

  ```xml
  <dependency>
      <groupId>com.github.ben-manes.caffeine</groupId>
      <artifactId>caffeine</artifactId>
      <version>2.5.5</version>
  </dependency>
  ```

  ```java
  @Test
  void test() {
      Cache<String, String> cache = Caffeine.newBuilder().build();
      // 存数据
      cache.put("key", "value");
      // 取数据，不存在返回null
      cache.getIfPresent("key");
      // 取数据，不存在返回后面方法的返回值,可在方法中调用redis
      cache.get("key2", key -> "value2");
  }
  ```

- 缓存驱逐策略：达到条件后不会立即驱逐

  - 基于容量：设置缓存的数量上限

    ```java
    Cache<String, String> cache = Caffeine.newBuilder()
        .initialCapacity(100) // 初始化大小为 100
        .maximumsize(10_000) // 设置缓存大小上限为 10000
        .build();
    ```

  - 基于时间：设置缓存的有效时间

    ```java
    Cache<String, String> cache = Caffeine.newBuilder()
        .expireAfterAccess(Duration.ofSeconds(10)) // 从最后一次获取开始保存10s
        .build();
    ```

  - 基于引用：设置缓存为软引用或弱引用，利用GC来回收缓存数据。





#### Canal

##### 概述

- 缓存同步策略
  - 设置有效期
    - 时效性差
  - 同步双写
    - 有代码侵入，耦合度高
  - 异步通知
    - 时效性较好，耦合度低



##### mysql主从

- 开启binlog

  - 修改my.cnf文件

  - 添加内容

    ```shell
    # 在部署mysql的系统的命令行
    # 先创建binlog文件夹
    mkdir /var/lib/mysql/binlog
    # 非必要：changed ownership of 'binlog' from root:root to mysql:mysql
    chown -R -v mysql:mysql /var/lib/mysql/binlog
    ```
    
    ```ini
    # 设置binary log文件存放的地址和文件名，叫做mysql-bin
    log-bin=/var/lib/mysql/binlog/weather-bin
    # 指定对哪个database记录binlog
    binlog-do-db=weather
    ```

- 设置用户权限：添加一个仅用于数据同步的账户，出于安全考虑，仅提供开启binlog的库的操作权限

  ```mysql
  create user canal@'%' IDENTIFIED by 'canal';
  GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO 'canal'@'%' identified by 'canal';
  FLUSH PPRIVILEGES;
  
  # 重启容器后查看主从状态
  SHOW MASTER STATUS;
  ```
  
- 创建网络并加入

  ```
  docker network create test
  docker network connect test mysql
  ```



##### canal

- 创建容器

  ```shell
  docker run -p 11111:11111 --name canal \
  # 集群名称
  -e canal.destinations=test \
  # 主节点地址，因为在同一docker网络，可用容器名代替
  -e canal.instance.master.address=mysql:3306 \
  -e canal.instance.dbUsername=canal \
  -e canal.instance.dbPassword=canal \
  -e canal.instance.connectionCharset=UTF-8 \
  -e canal.instance.tsdb.enable=true \
  -e canal.instance.gtidon=false \
  # 监听test库下所有的表
  -e canal.instance.filter.regex=test\\..* \
  --network test \
  -d canal/canal-server:v1.1.5
  ```

- 编写canal客户端：监听

  - 引入依赖

    ```xml
    <dependency>
        <groupId>org.springframework.data</groupId>
        <artifactId>spring-data-commons</artifactId>
    </dependency>
    <dependency>
        <groupId>top.javatool</groupId>
        <artifactId>canal-spring-boot-starter</artifactId>
        <version>1.2.1-RELEASE</version>
    </dependency>
    ```

  - 编写配置

    ```yaml
    canal:
      destination: test
      server: 192.168.36.132:11111
    ```

  - 编写监听器

    ```java
    @CanalTable("user")
    @Component
    public class UserHandler implements EntryHandler<User> {
        @Override
        public void insert(User user) {
            System.out.println("新增用户："+user);
        }
    
        @Override
        public void update(User before, User after) {
            System.out.println("修改用户");
        }
    
        @Override
        public void delete(User user) {
            System.out.println("删除用户："+user);
        }
    }
    ```

  - pojo类

    ```java
    public class User {
        @Id // 主键
        // 必须使用包装类
        private Long id;
        private String name;
        private Integer age;
        @Transient // 表中没有的字段用该注解
        private String msg;
    }
    ```

    







# Redis



## 基础篇

### 安装redis

#### 配置文件

```ini
# 开始启动时必须如下指定配置文件
# ./redis-server /path/to/redis.conf


# 存储单位如下所示
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes

################################## INCLUDES ###################################

# 如果需要使用多配置文件配置redis，请用include
# include /path/to/local.conf
# include /path/to/other.conf

################################## MODULES ##################################### modules

# 手动设置加载模块（当服务无法自动加载时设置）
# loadmodule /path/to/my_module.so
# loadmodule /path/to/other_module.so

################################## NETWORK #####################################

# Examples:
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1 ::1
# 设置绑定的ip
bind 127.0.0.1

# 保护模式：不允许外部网络连接redis服务
protected-mode yes

# 设置端口号
port 6379

# TCP listen() backlog.
# 
# TCP 连接数，此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度
tcp-backlog 511

# Unix socket.
# 
# 通信协议设置，本机通信使用此协议不适用tcp协议可大大提升性能
# unixsocket /tmp/redis.sock
# unixsocketperm 700

# 定期检测cli连接是否存活
tcp-keepalive 300

################################## 权限 ###################################

# 设置连接时密码
# requirepass 123456

################################# GENERAL #####################################

# 是否守护进程运行（后台运行）
# 与docker的-d冲突，docker部署时daemonize设为no
daemonize yes

# 是否通过upstart和systemd管理Redis守护进程
supervised no

# 以后台进程方式运行redis，则需要指定pid 文件
pidfile /var/run/redis_6379.pid

# 日志级别
# 可选项有： # debug（记录大量日志信息，适用于开发、测试阶段）； # verbose（较多日志信息）； # notice（适量日志信息，使用于生产环境）； 
# warning（仅有部分重要、关键信息才会被记录）。
loglevel notice

# 日志文件的位置
logfile ""

# 数据库的个数
databases 16

# 是否显示logo
always-show-logo yes

################################ RDB 持久化  ################################
# 900秒内触发一次请求进行持久化，300秒内触发10次请求进行持久化操作，60s内触发10000次请求进行持久化操作
# save "" # 禁用RDB
save 900 1
save 300 10
save 60 10000

# 持久化出现错误后，是否依然进行继续进行工作
stop-writes-on-bgsave-error yes

# 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间
rdbcompression yes

# 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗
rdbchecksum yes

# dbfilename的文件名
dbfilename dump.rdb

# dbfilename文件的存放位置
dir ./

############################## AOF持久化 ###############################

# 是否使用AOF持久化方式
appendonly no

# appendfilename的文件名
appendfilename "appendonly.aof"

# 持久化策略
# 表示每执行一次写命令，立即记录到AOF文件
# appendfsync always
# 写命令执行完先放到AOF缓冲区，然后每隔1秒将缓冲区数据写到AOF文件
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写入磁盘
# appendfsync no

# 持久化时（RDB的save | aof重写）是否可以运用Appendfsync，用默认no即可，保证数据安全性
no-appendfsync-on-rewrite no

# 触发重写的基准值
auto-aof-rewrite-percentage 100 # 相比上一次增大100%
auto-aof-rewrite-min-size 64mb # 文件大小为64mb

# 指定当发生AOF文件末尾截断时，加载文件还是报错退出
aof-load-truncated yes

# 开启混合持久化，更快的AOF重写和启动时数据恢复
aof-use-rdb-preamble yes

################################# 主从关系 #################################

# replicaof 即slaveof 设置主结点的ip和端口
# replicaof <masterip> <masterport>

# 集群节点访问密码
# masterauth <master-password>

# 从结点断开后是否仍然提供数据
replica-serve-stale-data yes

# 设置从节点是否只读
replica-read-only yes

# 是否启用无磁盘复制（不先写入磁盘IO流，而直接写入网络IO流，网络快磁盘慢时可使用）
repl-diskless-sync no

# master节点创建子进程前等待的时间
repl-diskless-sync-delay 5

# Replicas发送PING到master的间隔，默认值为10秒。
# repl-ping-replica-period 10

# repl-timeout 60
 
repl-disable-tcp-nodelay no

# repl-backlog-size 1mb
# repl-backlog-ttl 3600

replica-priority 100
 
# min-replicas-to-write 3
# min-replicas-max-lag 10
#
# replica-announce-ip 5.5.5.5
# replica-announce-port 1234

################################ Redis 集群  ###############################

# 是否开启集群
# cluster-enabled yes

# 集群结点信息文件
# cluster-config-file nodes-6379.conf

# 等待节点回复的时限
# cluster-node-timeout 5000

# 结点重连规则参数
# cluster-replica-validity-factor 10
# cluster-migration-barrier 1
# cluster-require-full-coverage yes
# cluster-replica-no-failover no

################################### CLIENTS ####################################

# 最大连接数
# maxclients 10000

############################## MEMORY MANAGEMENT ################################

# redis配置的最大内存容量
# maxmemory <bytes>

# 内存达到上限的处理策略
# maxmemory-policy noeviction

# 处理策略设置的采样值
# maxmemory-samples 5

# 是否开启 replica 最大内存限制
# replica-ignore-maxmemory yes

############################# LAZY FREEING ####################################

# 惰性删除或延迟释放
lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no
```



#### docker部署

- 创建/var/docker-volume/redis/conf文件，以便之后的文件挂载

  ```shell
  docker run \
  --privileged=true \
  -p 6379:6379 \
  --name redis \
  -v /var/docker-volume/redis/conf:/etc/redis/conf \
  -v /var/docker-volume/redis/data:/data \
  -d redis \
  redis-server /etc/redis/conf/redis.conf \
  --requirepass 123456
  ```
  
  - -p 6379:6379 端口映射：前表示主机部分，：后表示容器部分。
  - --name myredis  指定该容器名称，查看和进行操作都比较方便。
  - -v 挂载目录，规则与端口映射相同。
  - -d redis 表示后台启动redis
  - --privileged=true 这个参数，容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限
  - redis-server /etc/redis/conf/redis.conf  以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录
  - appendonly yes 开启redis 持久化
  - 解决：WARNING overcommit_memory is set to 0!（容器内执行）
    - 命令：echo 1 > /proc/sys/vm/overcommit_memory
    - To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot
    - run the command 'sysctl vm.overcommit_memory=1' for this to take effect.





### Redis命令

#### 使用命令行

- redis-cli [options] [commands]
  - 常用options
    - -h 127.0.0.1：指定redis节点的ip，默认为127.0.0.1
    - -p 6379：指定连接的redis节点的端口，默认是6379
    - -a redis：指定redis的访问密码
  - commands是redis的操作命令
    - ping：与redis服务做心跳测试，服务正常返回pong
    - AUTH redis：指定redis的访问密码
    - select (index)：切换库
  - 不指定commands，会进入redis-cli的交互控制台



#### 通用命令

- 查看帮助文档：help @generic
- 常用命令：
  - KEYS (pattern)：查看复合模板的所有key
    - keys *：查询所有键
    - keys a*：查询以a开头的键
  - DEL (key ...)：删除一个或多个key，返回值为删除的key的个数
  - EXISTS (key ...)：判断key是否存在，返回值为存在的key的个数
  - EXPIRE (key seconds)：设置一个key的存活时间
  - TTL (key)：查看一个key的剩余存活时间，返回值-2为不存在，-1为永久有效



#### String类型

- string类型的value是字符串，不过根据字符串的格式不同，又可分为3类
  - string：普通字符串
  - int：整数类型，可以做自增、自减操作
  - float：浮点类型，可以做自增、自减操作
- 不管哪种格式，底层都是字节数组格式存储，只不过数字类型为减小存储大小而采用不同编码方式。字符串类型的最大空间不能超过512m
- 常用命令
  - SET (key value) [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX] [GET]
  - GET (key)：由key获得value
  - MSET (key value ...)：创建多个key和value
  - MGET (key ...)：获得多个value
  - INCR (key)：让一个整型的key自增1
  - INCRBY (key increment)：让一个整型的key自增指定步长
  - INCRBYFLOAT (key increment)：让一个浮点型的key自增指定步长
  - SETNX (key value)：添加一个string类型的键值对，前提是这个key不存在，否则不执行
  - SETEX (key seconds value)：添加一个指定类型的键值对，并指定有效期



#### Hash类型

- 类型

  | key    | value |          |
  | ------ | ----- | -------- |
  |        | field | value    |
  | user:1 | name  | zhangsan |
  |        | age   | 21       |
  | user:2 | name  | lisi     |
  |        | age   | 18       |

- 常用指令

  - HSET key field value：添加或修改hash类型key的field的值

  - HGET key field：获取一个hash类型key的field的值

  - HMSET key field value：批量添加多个hash类型的key的field和值

  - HMGET：批量获取多个hash类型的key的field的值

  - HGETALL：获取一个hash类型的key中的所有field和value

  - HKEYS：获取一个hash类型的key中的所有的field

  - HVALS：获取一个hash类型的key中的所有的value

  - HINCRBY：让一个hash类型key的字段自增并指定步长

  - HSETNX：添加一个hash类型的key的field值，前提field不存在，否则不执行



#### List类型

- 常用指令
  - LPUSH key element ...：向key对应的列表左侧插入一个或多个元素
  - LPOP key [count]：移出并返回key对应的列表左侧前n个元素，没有则返回nil
  - RPUSH key element ...：向key对应的列表右侧插入一个或多个元素
  - RPOP key [count]：移出并返回key对应的列表右侧前n个元素，没有则返回nil
  - LRANGE key start end：返回一个角段内的所有元素
  - BLPOP和BRPOP key ... timeout：与LPOP和RPOP类似，不过在没有元素时，等待指定时间，而不是直接返回nil



#### Set类型

- 常用指令
  - SADD key member ... ：向set中添加一个或多个元素
  - SREM key member ... ：移出set中的指定元素
  - SCARD key：返回set中元素的个数
  - SISMEMBER key member：判断一个元素是否存在于set中
  - SMEMBERS：获取set中的所有元素
  - SINTER key1 key2 ...：求key1与key2的交集
  - SDIFF key1 key2 ...：求key1和key2的差集（key1中有key2中没有的）
  - SUNION key1 key2 ...：求key1和key2的并集



#### SortedSet类型

- 常用指令
  - ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score
  - ZREM key member：删除sorted set的一个指定元素
  - ZSORE key member：获取sorted set中的指定元素的score值
  - ZRANK key member：获取sorted set中的指定元素的排名
  - ZCARD key：获取sorted set中的元素个数
  - ZCOUNT key min max：统计score值在给定范围内的所有元素的个数
  - ZINCRBY key increment member：让sorted set中的指定元素的score值自增指定步长
  - ZRANGE key min max：按照score排序后，获取指定排名范围内的元素
  - ZRANGEBYSCORE key min max：按照socre排序后，获取指定score范围内的元素
  - ZDIFF、ZINTER、ZUNION：求差集、交集、并集





### Java

#### Jedis

##### 基本使用

- 引入依赖

  ```xml
  <dependency>
      <groupId>redis.clients</groupId>
      <artifactId>jedis</artifactId>
      <version>3.7.1</version>
  </dependency>
  <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter</artifactId>
      <version>5.8.2</version>
      <scope>test</scope>
  </dependency>
  ```

- 建立连接

  ```java
  private Jedis jedis;
  
  @BeforeEach
  void setUp(){
      jedis = new Jedis("192.168.36.131", 6379);
      jedis.auth("redis");
      jedis.select(0);
  }
  ```

- 测试

  ```java
  @Test
  void testString(){
      String result = jedis.set("name", "zhangsan"); // OK
      String name = jedis.get("name"); // 
  }
  ```

- 释放资源

  ```java
  @AfterEach
  void tearDown(){
      if(jedis != null){
          jedis.close();
      }
  }
  ```




##### jedis连接池

```java
public class JedisConnectionFactory {
    private static final JedisPool jedisPool;

    static {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        // 最大连接
        jedisPoolConfig.setMaxTotal(8);
        // 最大空闲连接
        jedisPoolConfig.setMaxIdle(8);
        // 最小空闲连接
        jedisPoolConfig.setMinIdle(0);
        // 连接池中没有连接时的最长等待时间，默认-1表示一直等待
        jedisPoolConfig.setMaxWaitMillis(200);
        jedisPool = new JedisPool(jedisPoolConfig, "192.168.36.131", 6379, 1000, "redis");
    }
    
    // 获取Jedis对象
    public static Jedis getJedis(){
        return jedisPool.getResource();
    }
}
```





#### SpringDataRedis

##### RedisTemplate

| API              | 返回值类型      | 说明                  |
| ---------------- | --------------- | --------------------- |
| rt.opsForValue() | ValueOperations | 操作String类型数据    |
| rt.opsForHash()  | HashOperations  | 操作Hash类型数据      |
| rt.opsForList()  | ListOperations  | 操作List类型数据      |
| rt.opsForSet()   | SetOperations   | 操作Set类型数据       |
| rt.opsForZSet()  | ZSETOperations  | 操作SortedSet类型数据 |
| rt               |                 | 通用的命令            |



##### 快速入门

- 引入依赖（基于boot）

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
  </dependency>
  <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-pool2</artifactId>
  </dependency>
  ```

- 配置文件

  ```yml
  spring:
    redis:
      host: 192.168.36.131
      port: 6379
      password: redis
      database: 0
      # spring默认使用lettuce，若用jedis，须导入jedis依赖
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: 1000ms
  ```

- 注入RedisTemplate

  ```java
  @Autowired
  private RedisTemplate redisTemplate;
  ```



##### 序列化

- 自动序列化

  - redisTemplate默认使用java的序列化方式

  - 导入jackson-databind依赖

  - 重写RedisTemplate的Bean

    ```java
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory){
        // 创建 RedisTemplate 对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 设置连接工厂
        template.setConnectionFactory(factory);
        // 创建JSON序列化工具
        GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
        // 设置Key的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置Value的序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        // 返回
        return template;
    }
    ```

  - 问题：存对象时，会存入类字节码路径

- 手动序列化

  - Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认是String方式。省去了自定义RedisTemplate的过程

  ```java
  private static final ObjectMapper mapper = new ObjectMapper();
  @Autowired
  private StringRedisTemplate stringRedisTemplate;
  
  @Test
  void testStringTemplate() throws JsonProcessingException {
      User temp = new User("zhangsan", 18);
      // 存入数据
      String json = mapper.writeValueAsString(temp);
      stringRedisTemplate.opsForValue().set("user", json);
      // 读取数据
      String jsonFromRedis = stringRedisTemplate.opsForValue().get("user");
      User user = mapper.readValue(jsonFromRedis, User.class);
      System.out.println(user);
  }
  ```








## 实战篇

### hutool

- json与对象的转换

  - 普通对象

    - ```java
      String shopJson = JSONUtil.toJsonStr(shop);
      ```

    - ```java
      Shop shop = JSONUtil.toBean(shopJson, Shop.class);
      ```

  - list集合

    - ```java
      String shopTypeJson = JSONUtil.toJsonStr(typeList);
      ```

    - ```java
      JSONArray jsonArray = JSONUtil.parseArray(shopTypeJson);
      List<ShopType> shopTypes = JSONUtil.toList(jsonArray, ShopType.class);
      ```

- 拷贝属性

  - ```java
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
    ```

- 对象转map

  - ```java
    Map<String, Object> userMap = null;
    userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(),
                                 // 可定义转换规则
                                 CopyOptions.create()
                                 .setIgnoreNullValue(true)
                                 .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()))
    ```

- 生成是否不带中划线的uuid

  - ```java
    String token = UUID.randomUUID().toString(false); // 生成带中划线的uuid
    ```

    

### 缓存

#### 预热

- 项目启动时，就向redis中缓存部分热点数据

  ```java
  @Component
  public class RedisHandler implements InitializingBean {
      @Autowired
      private StringRedisTemplate redisTemplate;
      
      @Override
      public void afterPropertiesSet() throws Exception {
          // 初始化缓存：查询热点信息，放入缓存
      }
  }
  ```

  

#### 使用

- 缓存穿透

  ![缓存穿透](D:\picture\typora\java\缓存穿透.png)

- 缓存雪崩

  - 问题：多项缓存同时失效或redis宕机
  - 解决
    - 多级缓存
    - 随机有效期
    - redis集群

- 缓存击穿

  ![缓存击穿](D:\picture\typora\java\缓存击穿.png)



#### 秒杀

- redis缓存商品信息和库存
- 可用redis的set集合







### Redisson

#### 基础配置

- 引入依赖

  - ```xml
    <dependency>
    	<groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>3.13.6</version>
    </dependency>
    ```

- 配置Redisson客户端

  - ```java
    @Configuration
    public class RedisConfig {
        @Bean
        public RedissonClient redissonClient() {
            // 配置类
            Config config = new Config();
            // 添加单点的redis地址，也可以使用config.userClusterServers()添加集群地址
            config.useSingleServer()
                .setAddress("redis://192.168.36.131:6379")
                .setPassword("redis");
            // 创建客户端并返回
            return Redisson.create(config);
        }
    }
    ```



#### 分布式锁

- 基于redis实现分布式锁
  - 以 lock:order:userId 作为键，以 uuid 作为值，设置合适的存活时间，以免死锁
  - 执行业务时，判断该键是否存在
  - 若键不存在，生成键值，执行业务
  - 执行完业务后，删除该键用来代表归还锁
  - 若键存在，说明用户在不同服务端下重复申请
  - 细节
    - 可通过 uuid 判断 生成键与将要销毁键 的是否是同一线程，若不是，则不允许该线程销毁
    - 是否是可重入的锁

- 单锁

  - ```java
    @Resource
    private RedissonClient redissonClient;
    
    // 此方法用于模拟分布式下一人一单的 锁 操作
    @Test
    void testRedisson(int userId) throws InterruptedException {
        // 获取锁（可重入），指定锁的名称
        RLock lock = redissonClient.getLock("lock:order:" + userId);
        // 尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位
        // 默认值：(-1, 30*1000, TimeUnit.毫秒); -1 表示不等待
        boolean isLock = lock.tryLock(2, 10, TimeUnit.SECONDS);
        // 判断是否获取成功
        if (isLock) {
            try {
                System.out.println("执行业务");
            }finally {
                lock.unlock();
            }
        }
    }
    ```

- 连锁（不使用redis集群，单纯在三个redis数据库间建立连锁。连锁：所有的锁都拿到，才能真正获得锁）

  - ```java
    @Resource
    private RedissonClient redissonClient1;
    @Resource
    private RedissonClient redissonClient2;
    @Resource
    private RedissonClient redissonClient3;
    
    private RLock lock;
    
    @BeforeEach
    void setUp() {
        RLock lock1 = redissonClient1.getLock("lock:order:" + userId);
        RLock lock2 = redissonClient2.getLock("lock:order:" + userId);
        RLock lock3 = redissonClient3.getLock("lock:order:" + userId);
        
        lock = redissonClient.getMultiLock(lock1, lock2, lock3);
    }
    ```





## 高级篇

- 数据丢失问题：实现Redis数据持久化
- 并发能力问题：搭建主从集群，实现读写分离
- 存储能力问题：利用redis哨兵，实现健康检测和自动恢复
- 故障恢复问题：搭建分片集群，利用插槽机制实现动态扩容



### redis持久化

- RDB持久化

  - Redis在正常关机时会触发一次数据持久化

  - Redis内部有触发RDB的机制，可以在redis.conf文件中找到

  - RDB方式bgsave的基本流程
    - fork主进程得到一个子进程，共享内存数据
      - fork并非拷贝数据，而是让子进程获得与物理内存中的数据的映射关系，fork的过程是阻塞的
    - 子进程读取内存数据并写入新的RDB文件
      - 在持久化数据的过程中，若有数据修改，为避免脏数据，会复制该部分数据，在此基础上查询修改，最后合并
    - 用新的RDB文件替换旧的RDB文件

- AOF持久化：记录指令，类似于指令的日志，恢复时重新调用这些指令即可恢复数据



### redis主从

- 搭建主从架构
- 数据同步步骤
  - 全量同步：首次连接时执行

    - 第一阶段
      - slave节点执行replicaof命令，建立连接
      - slave节点 携带replid和offset 请求数据同步
      - master根据 replid与自己是否相同 判断是否是第一次同步
      - 是第一次同步，返回master的replid和offset

    - 第二阶段
      - master执行bgsave，生成RDB
      - 发送RDB到salve节点
      - salve节点清空本地数据，加载RDB文件
      - 对master执行bgsave的过程中接收到的修改数据库指令进行记录，形成repl_baklog文件

    - 第三阶段
      - master发送repl_backlog中的命令，salve执行接收到的命令

  - 增量同步：后续数据同步
    - master持续记录，发送repl_baklog中的命令，salve执行接收到的命令
    - 增量同步失败
      - repl_backlog大小有上限，写满后会覆盖最早的数据。如果slave长时间不进行同步，repl_backlog写满后覆盖了slave尚未同步的数据，则无法做增量同步

- 数据同步原理
  - master如何判断slave是不是第一次来同步数据？这里会用到两个概念
    - Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid
    - offset：偏移量，随着记录在repl_backlog中的数据的增多而逐渐增大。slave完成同步时会记录当前同步的offset，如果slave的offset小于master的offset，说明slave数据落后于master，需要更新




### redis哨兵

- 原理

  - 服务状态监控
    - Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令
      - 主观下线：有sentinel节点发现某redis实例未在规定时间内响应，则认为该实例主观下线
      - 客观下线：超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过sentinel实例数量的一半

  - 选举新的master
    - 首先会判断slave节点与master节点断开时间长短，如果时间超过指定值（down-after-milliseconds*10）则会排除该slave节点
    - 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举
    - 如果slave-priority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高
    - 最后判断slave节点的运行id大小，越小优先级越高

  - 故障转移
    - 当选中一个slave成为新的master后
      - sentinel 给该slave节点发送slaveof no one命令，让该节点成为master
      - sentinel给所有其他slave发送slaveof \<host> \<port>命令，让其他节点成为新master的从节点
      - 最后，sentinel在故障节点的配置文件中添加slaveof指令，当故障节点恢复后会自动成为新的master的slave节点

- 搭建sentinel集群

  - sentinel配置文件：以 sentinel.conf 获取redis实例

    ```ini
    port 27001
    sentinel announce-ip 192.168.36.132
    # 配置redis主节点信息
    	# mymaster：主节点名称，自定义
    	# 192.168.36.132 7001：主节点的ip和端口
    	# 2：选举master时的quorum
    sentinel monitor mymaster 192.168.36.132 7001 2
    sentinel down-after-millisenconds mymaster 5000
    sentinel failover-timeout mymaster 60000
    # 指定工作目录
    dir "/tmp/sentinel1"
    ```

- redisTemplate的哨兵模式

  - 引入依赖

    ```xml
    <dependency>
    	<groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    ```

  - 因为master节点是变动的，所有不需要配置master地址，只需要配置sentinel信息

    ```yaml
    spring:
      redis:
        sentinel:
          master: mymaster # 指定master名称
          nodes: # 指定redis-sentinel集群信息
            - 192.168.36.131:27001
            - 192.168.36.131:27002
            - 192.168.36.131:27003
    ```

  - 配置主从分离

    ```java
    @Bean
    public LettuceClientConfigurationBuilderCustomizer configurationBuilderCustomizer() {
        return configBuilder -> configBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);
    }
    ```

    - ReadFrom是配置Redis的读取策略，是一个枚举，包括下面选择
      - MASTER：从主节点读取
      - MASTER_PREFERRED：优先从主节点读取
      - REPLICA：从slave节点读取
      - REPLICA_PREFERRED：优先从slave节点读取




### redis分片

- 搭建集群

  - 以 redis.conf 获取redis实例

  - redis5.0后，集群管理集成到redis-cli中，格式如下

    ```shell
    redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003
    ```

    - redis-cli --cluster：代表集群操作命令
    - create：表示创建集群
    - --replicas 1 或 --cluster-replicas 1：指定集群中每个master的副本个数为1，此时`节点总数 / (replicas + 1)`得到的就是master的数量。因此节点列表中的前n个就是master，其他节点都是slave节点，随机分配到不同的master上

- 散列插槽

  - 所有master分配 0-16383 共16384个插槽，存入数据时，由key经一定算法得到hash值，再对16384取余，将数据存储到该余数对应的插槽上
    - 若key中没有 {} ，根据整个key计算hash
    - 若key中有 {}， 根据 {} 内的部分计算hash
  - 相比于数据和节点绑定，数据和插槽绑定后，若该master宕机，可将插槽和数据一并交由下一个master管理

- 集群伸缩

  - 添加节点：新增的节点没有插槽，需要分配

    ```shell
    redis-cli \ 
    --cluster add-node <new_host>:<new_port> <existing_host>:<existing_port> \ 
    --cluster-slave \ # 表示添加的是从节点
    --cluster-master-id  <arg> # 指定该节点的master 
    ```

  - 分配插槽：reshard命令

    - 先压缩某master上的插槽

      ```shell
      redis-cli --cluster reshard <existing_host>:<existing_port>
      ```

    - How many slots do you want to move (from 1 to 16384)?

    - What is the receiving node ID?

    - Please enter all the source node IDS.

      - 填写插槽来源的masterID
      - 填写done表示完成

- 故障转移

  - 默认故障转移：有master节点宕机后，选举出新的master
  - 指定故障转移：在从节点上执行 CLUSTER FAILOVER 可让该从节点替换master节点

- RedisTemplate访问分片集群

  - 引入redis的starter依赖

  - 配置分片集群地址

    ```yaml
    spring:
      redis:
        cluster:
          nodes: # 指定分片集群的每个节点信息
            - 192.168.36.132:7001
            - 192.168.36.132:7002
            - 192.168.36.132:7003
            - 192.168.36.132:8001
            - 192.168.36.132:8002
            - 192.168.36.132:8003
    ```

  - 配置读写分离









# Nginx



## 部署

### nginx

- 下载镜像

  - ```shell
    docker pull nginx
    ```

- 创建挂载目录

  - ```shell
    mkdir -p /var/docker-volume/nginx/conf
    mkdir -p /var/docker-volume/nginx/log
    mkdir -p /var/docker-volume/nginx/html
    ```

- 复制文件到挂载目录

  - ```shell
    # 先生成容器
    docker run --name nginx -p 9999:80 -d nginx
    
    # 复制容器中的文件到挂载目录
    docker cp nginx:/etc/nginx/nginx.conf /var/docker-volume/nginx/conf/nginx.conf
    docker cp nginx:/etc/nginx/conf.d /var/docker-volume/nginx/conf/conf.d
    docker cp nginx:/usr/share/nginx/html /var/docker-volume/nginx/
    ```

- 移出nginx容器后重新运行

  - ```shell
    # 移出刚才生成的容器
    docker stop nginx
    docker rm nginx
    
    # 重新运行
    docker run \
    -p 9999:80 \
    --name nginx \
    -v /var/docker-volume/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
    -v /var/docker-volume/nginx/conf/conf.d:/etc/nginx/conf.d \
    -v /var/docker-volume/nginx/log:/var/log/nginx \
    -v /var/docker-volume/nginx/html:/usr/share/nginx/html \
    -d nginx
    ```




### openResty

- 拉取镜像

  ```shell
  docker pull openresty/openresty
  ```

- 运行镜像

  ```shell
  docker run --name openresty -p 80:80 -d openresty/openresty
  ```

- 拷贝文件

  ```java
  mkdir -p /var/docker-volume/openresty/openresty
  mkdir -p /var/docker-volume/openresty/conf.d
  docker cp openresty:/usr/local/openresty /var/docker-volume/openresty
  docker cp openresty:/etc/nginx/conf.d /var/docker-volume/openresty
  ```

- 删除容器

  ```shell
  docker stop openresty
  docker rm openresty
  ```

- 运行镜像

  ```shell
   docker run -p 80:80 -p 8081:8081 \
  --name openresty --privileged=true \
  -v /var/docker-volume/openresty/openresty:/usr/local/openresty \
  -v /var/docker-volume/openresty/conf.d:/etc/nginx/conf.d \
  -d openresty/openresty
  ```





## 基础篇

### 配置文件

```shell
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}

server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```



#### 虚拟主机

```shell
# 可配置多个主机
server {
    listen       80;
    # 域名、主机名
    server_name  localhost www.test.cn;

    location / {
        root   /usr/share/nginx/html/test01;
        index  index.html index.htm;
    }
}
    
server {
    listen       80;
    # 支持通配符。匹配顺序：精准匹配 > 头通配符匹配 > 尾通配符匹配 > 正则匹配
    server_name  *.test.*;

    location / {
        root   /usr/share/nginx/html/test02;
        index  index.html index.htm;
    }
}
```



#### 反向代理

```shell
server {
    listen       80;
    server_name  localhost www.test.cn;

    location / {
        # 代理
        proxy_pass https://www.baidu.com;
    }
}
```



#### 负载均衡

```shell
upstream weather-service {
    # 基于uri做hash算法，在路由到服务器上
    # hash $request_uri;
	# 配置负载均衡，可配置权重、是否进行负载均衡、配置备用机
	server 192.168.36.133:9999 weight=6 down;
	server 192.168.36.134:9999 weight=2;
	server 192.168.36.134:9999 weight=2 backup;
}
server {
    listen       80;
    server_name  localhost www.test.cn;

    location / {
        proxy_pass http://weather-service;
    }
}
```



#### 动静分离

```shell
# 配置多个location
server {
    listen       80;
    server_name  localhost www.test.cn;

    location / {
    	# 定义匹配规则："$1" 表示匹配第一个 "(正则表达式)"
    	# last 本条规则匹配完成后，获得的新的URI会再次进行location匹配
    	# break 本条规则匹配完成即终止，不再匹配后面任何规则
    	# redirect 返回302临时重定向，浏览器地址栏会显示跳转后的URL地址
    	# permanent 返回301永久重定向，浏览器地址栏会显示跳转后的URL地址
    	rewrite ^/([0-9]+).html$   /index.html?pageNum=$1  break;
        proxy_pass http://httpds;
    }
    
    location ~*/(css|img|css) {
    	root /usr/share/nginx/html;
    	index index.html index.htm;
    }
}
```





## openResty

### lua入门

- 数据类型

  - nil：表示无效值（在条件表达式中相当于false）
  - boolean：false和true
  - number：表示双精度类型的实浮点数
  - string：可用双引号或单引号表示（拼接：str1 .. str2）
  - function：函数
  - table：表
    - local arr = {'java', 'python', 'lua'}：
      - arr[1]（索引从1开始）
    - local map = {name='zhangsan', age=18}
      - map['name']
      - map.name

- 循环

  - local arr = {'java', 'python', 'lua'}

    ```lua
    for index,value in ipairs(arr) do
        print(index, value)
    end
    ```

  - local map = {name='jack', age=18}

    ```lua
    for key,value in pairs(map) do
        print(key, value)
    end
    ```

- 函数

  ```lua
  function 函数名(arg1, arg2 ..., argn)
      -- 函数体
      return 返回值
  end
  ```

- 条件控制

  ```lua
  if(布尔表达式)
      then
      -- true 的语句块
      else
      -- flase 的语句块
  end
  ```

  - and：与
  - or：或
  - not：非



### 快速入门

- 编辑conf.d下的default.config文件

  ```ini
  upstream openresty-service {
      server 192.168.36.132:8081;
  }
  
  server {
      listen       80;
      server_name  localhost;
  
      location / {
          root   /usr/local/openresty/nginx/html;
          index  index.html index.htm;
      }
  
      location /test {
          proxy_pass http://openresty-service;
      }
  
      error_page   500 502 503 504  /50x.html;
      location = /50x.html {
          root   /usr/local/openresty/nginx/html;
      }
  }
  
  
  # lua 模块
  lua_package_path "/usr/local/openresty/lualib/?.lua;;";
  # c 模块
  lua_package_cpath "/usr/local/openresty/lualib/?.so;;";
  
  server {
      listen       8081;
      server_name  localhost;
  
      location /test {
          # 设置response格式
          default_type application/json;
          # 在 nginx 的目录下寻找
          content_by_lua_file lua/test.lua;
      }
  }
  ```

- 在nginx目录下创建 lua/test.lua 文件

- 编辑lua脚本

  ```lua
  -- 返回假数据，这里的ngx.say()函数，就是将数据写到Response中
  ngx.say('{"name":"zhangsan","gender":"male","age":18}')
  ```

  

### 参数获取

- 路径占位符：/item/1001

  ```ini
  location ~ /item/(\d+) {
      content_by_file lua/item.lua;
  }
  ```

  ```lua
  local id = ngx.var[1]
  ```

- 请求头：id: 1001

  ```lua
  local headers = ngx.req.get_headers()
  ```

- get请求参数：?id=1001

  ```lua
  local getParams = ngx.req.get_uri_args()
  ```

- post表单惨数：id=1001

  ```lua
  ngx.req.read_body() -- 读取请求体
  local postParams = ngx.req.get_post_args()
  ```

- JSON参数：{"id": 1001}

  ```lua
  ngx.req.read_body()
  local jsonBody = ngx.req.get_body_data()
  ```




### 发送请求

- nginx提供了内部API用以发送http请求

  ```lua
  local cjson = require('cjson')
  
  local resp = ngx.location.capture("/path", {
          method = ngx.HTTP_GET, -- 请求方式
          args = {a=1, b=2}, -- get 方式传参
          body = "c=3&d=4" -- post 方式传参
      })
  
  local item = cjson.decode(resp.body)
  local json = cjson.encode(item)
  ngx.say(json)
  ```

- 返回的响应内容包括

  - resp.status：响应状态码
  - resp.header：响应头，是一个table
  - resp.body：响应体，就是响应数据

- 这里的path是路径，并不包括ip端口。这个请求会被nginx内部的server监听并处理

  ```ini
  location /path {
      proxy_pass http://192.168.36.132:8080;
  }
  ```



### 连接redis

- 引入redis模块，并初始化redis对象

  ```lua
  local redis = require("resty.redis") -- 引入redis模块
  local red = redis:new() -- 初始化redis对象
  -- 设置redis超时时间
  -- 分别是 建立连接 发送请求 响应结果 的超时时间
  red:set_timeouts(1000, 1000, 1000)
  ```

- 封装函数，用来释放redis连接，其实是放入连接池

  ```lua
  local function close_redis(red)
      local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒
      local pool_size = 100
      local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)
      if not ok then
          ngx.log(ngx.ERR, "放入Redis连接池失败", err)
      end
  end
  ```

- 封装函数，从Redis中读取并返回数据

  ```lua
  local function read_redis(ip, port, key)
      local ok, err = red:connect(ip, port)
      if not ok then
          ngx.log(ngx.ERR, "连接redis失败：", err)
          return nil
      end
      -- 密码和选择的桶
      -- red:auth(password)
      -- red:select(17) -- redis桶索引从0开始
      local resp, err = red:get(key)
      if not resp then
          ngx.log(ngx.ERR, "查询Redis失败：", err, ", key = ", key)
      end
      if resp == ngx.null then
          resp = nil
          ngx.log(ngx.ERR, "查询Redis数据为空，key = ", key)
      end
      close_redis(red)
      return resp
  end
  ```

  

### 本地缓存

- OpenResty为Nginx提供了shard dict的功能，可以在nginx的多个worker之间共享数据，实现数据缓存功能

  - 开启共享字典，在nginx.conf的http下添加配置：

    ```ini
    # 共享字典，名称为item_cache，大小为150m
    lua_shared_dict item_cache 150m;
    ```

  - 操作共享字典：

    ```lua
    --  获取本地缓存对象
    local item_cache = ngx.shared.item_cache
    -- 存储，指定key、value、过期时间，单位为s，默认为0代表永不过期
    item_cache:set('key', 'value', 1000)
    -- 读取
    local val = item_cache:get('key')
    ```

    =
